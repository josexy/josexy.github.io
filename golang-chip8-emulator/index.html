

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="CHIP-8是由 Joseph Weisbecker 编写的解释型语言，使用该语言编写的程序可以在 CHIP-8 虚拟机上运行，因此可以运行一些简单的游戏。本文使用Go语言实现一个简单的CHIP8模拟器，just for fun">
  <meta name="author" content="Joseph XRays">
  <meta name="keywords" content="">
  
  <title>Golang实现Chip8模拟器 - JoXrays&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/monokai.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"www.joxrays.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"AzPbImmMjm5nQc1Xm9ulWCoH-gzGzoHsz","app_key":"xJqILn8nSbhYmdkB2VVQm8vI","server_url":"https://azpbimmm.lc-cn-n1-shared.com"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>JoXrays's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Golang实现Chip8模拟器">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-15 00:00" pubdate>
        2021年11月15日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      47
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Golang实现Chip8模拟器</h1>
            
            <div class="markdown-body">
              <p>CHIP-8是由 Joseph Weisbecker 编写的解释型语言，使用该语言编写的程序可以在 CHIP-8 虚拟机上运行，因此可以运行一些简单的游戏。本文使用Go语言实现一个简单的CHIP8模拟器，just for fun</p>
<span id="more"></span>
<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3>
<blockquote>
<p>博客已经有1年多没有更新了，期间也换了一个好看点的主题，但也没有继续写的动力（太懒了😂）。不过今天开始继续写博客，目前本人已经转Go，因此后续可能会发布一些有关Go的文章</p>
</blockquote>
<p>为什么要自己实现一个模拟器？其实一开始是出于好玩，而且之前也学过计算机组成原理、操作系统和编译原理这三门课程，自己也实现过一个基于栈式虚拟机的小型编译器，后来萌生了一个写模拟器的想法。</p>
<p>本人之前打算实现一个简单的NES模拟器，但是由于NES模拟器PPU那块过于复杂，涉及到各种Mirroring和内存映射各种骚操作，因此在实现了CPU和其他一些模块后就放弃了😓。既然难的不行，那么就实现一个简单的CHIP8模拟器吧。</p>
<h3 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h3>
<p>在介绍CHIP8模拟器实现之前，让我们来了解下关于CHIP8的知识，更详细的可以从维基百科上查看: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CHIP-8">https://en.wikipedia.org/wiki/CHIP-8</a></p>
<h4 id="cpu"><a class="markdownIt-Anchor" href="#cpu"></a> CPU</h4>
<p>对于CHIP8，CPU中应该包含必须的一些基础寄存器，其中包括：</p>
<ul>
<li>程序计数器 <code>PC</code>，保存下一条指令的地址，16bit</li>
<li>地址寄存器 <code>I</code>，涉及内存操作，12bit</li>
<li>栈指针寄存器 <code>SP</code>，用于在函数调用时保存返回地址，8bit</li>
<li>数据寄存器 <code>V</code>，共有16个，分别命名为 <code>V0~VF</code>。其中 <code>VF</code> 表示的是 <strong>进位标志</strong></li>
</ul>
<p>除此之外，CHIP8还有两个计时器，分别为 DelayTimer 和 SoundTimer。由于这两个计时器在实现过程中可以忽略，因此这里不对两者作过多描述。</p>
<h4 id="操作码"><a class="markdownIt-Anchor" href="#操作码"></a> 操作码</h4>
<p>CHIP8一共有35个操作码，每个操作码大端存储且占用2个字节，每一个操作码可以用16进制表示，即得到下面的操作码表，该表改自维基百科</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>伪代码</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>0NNN</td>
<td></td>
<td>目前对于大部分ROMs不使用</td>
</tr>
<tr>
<td>00E0</td>
<td><code>display_clear()</code></td>
<td>清屏</td>
</tr>
<tr>
<td>00EE</td>
<td><code>return</code></td>
<td>从子程序中返回</td>
</tr>
<tr>
<td>1NNN</td>
<td><code>goto NNN</code></td>
<td>无条件跳转到地址 0xNNN</td>
</tr>
<tr>
<td>2NNN</td>
<td><code>*(0xNNN)()</code></td>
<td>在地址 0xNNN 处调用子程序</td>
</tr>
<tr>
<td>3XNN</td>
<td><code>if (Vx == NN)</code></td>
<td>如果 Vx 等于 0xNN 则跳过下一条指令</td>
</tr>
<tr>
<td>4XNN</td>
<td><code>if (Vx != NN)</code></td>
<td>如果 Vx 不等于 0xNN 则跳过下一条指令</td>
</tr>
<tr>
<td>5XY0</td>
<td><code>if (Vx == Vy)</code></td>
<td>如果 Vx 等于 Vy 则跳过下一条指令</td>
</tr>
<tr>
<td>6XNN</td>
<td><code>Vx = NN</code></td>
<td>设置 Vx 为 0xNN</td>
</tr>
<tr>
<td>7XNN</td>
<td><code>Vx += NN</code></td>
<td>加 0xNN</td>
</tr>
<tr>
<td>8XY0</td>
<td><code>Vx = Vy</code></td>
<td>赋值 Vy</td>
</tr>
<tr>
<td>8XY1</td>
<td><code>Vx |= Vy</code></td>
<td>位或 Vy</td>
</tr>
<tr>
<td>8XY2</td>
<td><code>Vx &amp;= Vy</code></td>
<td>位与 Vy</td>
</tr>
<tr>
<td>8XY3</td>
<td><code>Vx ^= Vy</code></td>
<td>位异或 Vy</td>
</tr>
<tr>
<td>8XY4</td>
<td><code>Vx += Vy</code></td>
<td>加 Vy</td>
</tr>
<tr>
<td>8XY5</td>
<td><code>Vx -= Vy</code></td>
<td>减 Vy</td>
</tr>
<tr>
<td>8XY6</td>
<td><code>Vx &gt;&gt;= 1</code></td>
<td>Vx 右移一位</td>
</tr>
<tr>
<td>8XY7</td>
<td><code>Vx = Vy - Vx</code></td>
<td>Vy 减 Vx</td>
</tr>
<tr>
<td>8XYE</td>
<td><code>Vx &lt;&lt;= 1</code></td>
<td>Vx 左移一位</td>
</tr>
<tr>
<td>9XY0</td>
<td><code>if (Vx != Vy)</code></td>
<td>如果 Vx 不等于 Vy 则跳过下一条指令</td>
</tr>
<tr>
<td>ANNN</td>
<td><code>I = NNN</code></td>
<td>设置地址寄存器 I</td>
</tr>
<tr>
<td>BNNN</td>
<td><code>PC = V0 + NNN</code></td>
<td>设置 PC</td>
</tr>
<tr>
<td>CXNN</td>
<td><code>Vx = rand() &amp; NN</code></td>
<td>设置 Vx 为 <strong>[0,255]</strong> 的整数随机数</td>
</tr>
<tr>
<td>DXYN</td>
<td><code>draw(Vx, Vy, N)</code></td>
<td>在位置 (Vx,Vy) 绘制一个宽和高分别为8、N像素的精灵</td>
</tr>
<tr>
<td>EX9E</td>
<td><code>if (key() == Vx)</code></td>
<td>如果存储在Vx寄存器的键被按下，则跳过下一条指令</td>
</tr>
<tr>
<td>EXA1</td>
<td><code>if (key() != Vx)</code></td>
<td>如果存储在Vx寄存器的键未被按下，则跳过下一条指令</td>
</tr>
<tr>
<td>FX07</td>
<td><code>Vx = get_delay()</code></td>
<td>设置 Vx 为延迟计时器的值</td>
</tr>
<tr>
<td>FX0A</td>
<td><code>Vx = get_key()</code></td>
<td>阻塞所有指令操作并等待，直到一个键被按下并存储到 Vx 中</td>
</tr>
<tr>
<td>FX15</td>
<td><code>delay_timer(Vx)</code></td>
<td>设置延迟计时器</td>
</tr>
<tr>
<td>FX18</td>
<td><code>sound_timer(Vx)</code></td>
<td>设置声音计时器</td>
</tr>
<tr>
<td>FX1E</td>
<td><code>I += Vx</code></td>
<td>设置地址寄存器 I</td>
</tr>
<tr>
<td>FX29</td>
<td><code>I = sprite_addr[Vx]</code></td>
<td>设置地址寄存器 I 为某个字体精灵的起始地址</td>
</tr>
<tr>
<td>FX33</td>
<td><code>set_BCD(Vx)</code></td>
<td>将 Vx 按照BCD形式存储到连续内存中</td>
</tr>
<tr>
<td>FX55</td>
<td><code>reg_dump(Vx, &amp;I)</code></td>
<td>从 I 地址开始依次写入 V0-Vx</td>
</tr>
<tr>
<td>FX65</td>
<td><code>reg_load(Vx, &amp;I)</code></td>
<td>从 I 地址依次读取值到 V0-Vx</td>
</tr>
</tbody>
</table>
<h4 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h4>
<p>CHIP8总共只有4K的内存大小，从下面的内存布局中可以看出，CHIP8解释器本身需要占用 512 字节。<br />
因此对于大部分的ROM加载时一般都是加载到起始地址 0x200 处。</p>
<ul>
<li>0x000-0x04F 存储字体数据</li>
<li>0xEA0-0xEFF 保留用于调用堆栈、内部使用和其他变量</li>
<li>0xF00-0xFFF 存储用于显示的64*32像素，总共 256 字节</li>
</ul>
<figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">+---------------+= 0xFFF (4095) End of Chip-8 RAM<br>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string"> 0x200 to 0xFFF</span>|<br>|<span class="hljs-string">     Chip-8    </span>|<br>|<span class="hljs-string"> Program / Data</span>|<br>|<span class="hljs-string">     Space     </span>|<br>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string">               </span>|<br>+- - - - - - - -+= 0x600 (1536) Start of ETI 660 Chip-8 programs<br>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string">               </span>|<br>+---------------+= 0x200 (512) Start of most Chip-8 programs<br>|<span class="hljs-string"> 0x000 to 0x1FF</span>|<br>|<span class="hljs-string"> Reserved for  </span>|<br>|<span class="hljs-string">  interpreter  </span>|<br>+---------------+= 0x000 (0) Start of Chip-8 RAM<br></code></pre></div></td></tr></table></figure>
<h4 id="显示"><a class="markdownIt-Anchor" href="#显示"></a> 显示</h4>
<p>CHIP8显示屏宽高为 64x32，每个字节8bit，由于 CHIP8 只有黑白两色，因此可以用1bit表示一个像素，这样可以节省空间。</p>
<p>用于保存显示屏256字节数据位于内存空间 0xF00-0xFFF 处。</p>
<p>CHIP8绘制屏幕使用位运算将发生改变的像素位翻转。</p>
<h4 id="输入"><a class="markdownIt-Anchor" href="#输入"></a> 输入</h4>
<p>CHIP8键盘使用16个十六进制的按键 0-F，比如下面的这个布局</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>	<span class="hljs-number">2</span>	<span class="hljs-number">3</span>	C<br><span class="hljs-attribute">4</span>	<span class="hljs-number">5</span>	<span class="hljs-number">6</span>	D<br><span class="hljs-attribute">7</span>	<span class="hljs-number">8</span>	<span class="hljs-number">9</span>	E<br><span class="hljs-attribute">A</span>	<span class="hljs-number">0</span>	B	F<br></code></pre></div></td></tr></table></figure>
<p>在本文实现的Go代码使用了SDL2库，因此在处理按键输入时可以将实际键盘上的按键映射到CHIP8键。比如下面这个布局</p>
<figure class="highlight tp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tp"><span class="hljs-number">1</span>   <span class="hljs-number">2</span>   <span class="hljs-number">3</span>   <span class="hljs-number">4</span><br>Q   <span class="hljs-keyword">W</span>   E   <span class="hljs-keyword">R</span><br>A   S   D   F<br><span class="hljs-keyword">Z</span>   <span class="hljs-keyword">X</span>   C   V<br></code></pre></div></td></tr></table></figure>
<h3 id="golang实现"><a class="markdownIt-Anchor" href="#golang实现"></a> Golang实现</h3>
<p>前面只是简单的介绍了关于实现CHIP8模拟器的一些基本准则，下面用代码来讲解如何实现CHIP8模拟器</p>
<p>完整代码位于 Github： <a target="_blank" rel="noopener" href="https://github.com/josexy/gochip8">https://github.com/josexy/gochip8</a></p>
<p>项目代码结构如下</p>
<figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">.<br>├── chip8<br>│   ├── cpu.<span class="hljs-built_in">go</span><br>│   ├── emulator.<span class="hljs-built_in">go</span><br>│   ├── keyboard.<span class="hljs-built_in">go</span><br>│   ├── mem.<span class="hljs-built_in">go</span><br>│   ├── rom.<span class="hljs-built_in">go</span><br>│   └── screen.<span class="hljs-built_in">go</span><br>├── <span class="hljs-built_in">go</span>.<span class="hljs-built_in">mod</span><br>├── <span class="hljs-built_in">go</span>.<span class="hljs-built_in">sum</span><br>├── main.<span class="hljs-built_in">go</span><br>├── res<br>│   └── roms<br></code></pre></div></td></tr></table></figure>
<p>我在实现CHIP8时采用模块化设计，这样的好处是易于管理和定位错误。下面我将从整体到局部讲解各个模块是如何设计的。</p>
<h4 id="maingo"><a class="markdownIt-Anchor" href="#maingo"></a> main.go</h4>
<p>首先让我们来看下main.go中的main函数是怎样的：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;github.com/josexy/gochip8/chip8&quot;</span><br>	<span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(os.Args) == <span class="hljs-number">1</span> &#123;<br>		os.Exit(<span class="hljs-number">0</span>)<br>	&#125;<br>	emulator := chip8.NewEmulator(os.Args[<span class="hljs-number">1</span>])<br>	emulator.Start()<br>&#125;<br><br></code></pre></div></td></tr></table></figure>
<p>可以看到，我将主要功能实现放在了chip8包下的 emulator.go 文件中。运行一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 编译</span><br>go build main.go<br><span class="hljs-meta">#</span><span class="bash"> 运行</span><br>./main res/roms/UFO<br></code></pre></div></td></tr></table></figure>
<h4 id="emulatorgo"><a class="markdownIt-Anchor" href="#emulatorgo"></a> emulator.go</h4>
<p>CHIP8模拟器包含以下几个模块CPU、内存、显示屏、处理键盘输入、加载ROM文件。因此我们可以定义这样的一个结构体</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Emulator <span class="hljs-keyword">struct</span> &#123;<br>	Rom      *Rom<br>	CPU      *CPU<br>	Keyboard *Keyboard<br>	Screen   *Screen<br>	Memory   *Memory<br>	running  <span class="hljs-keyword">bool</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>模拟器的初始化工作由 <code>NewEmulator()</code> 完成，这主要是对Emulator结构体各个字段进行初始化。需要注意的是，在初始化内存之后，需要将ROM文件数据和字体数据加载到对应的内存位置。</p>
<p>通过 <code>Start()</code> 方法开始运行：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Emulator)</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">defer</span> e.Screen.destroy()<br><br>	<span class="hljs-keyword">for</span> e.running &#123;<br>		e.clock()<br><br>		<span class="hljs-keyword">for</span> event := sdl.PollEvent(); event != <span class="hljs-literal">nil</span>; event = sdl.PollEvent() &#123;<br>			<span class="hljs-keyword">switch</span> event.(<span class="hljs-keyword">type</span>) &#123;<br>			<span class="hljs-keyword">case</span> *sdl.QuitEvent: <span class="hljs-comment">// 关闭窗口</span><br>				e.running = <span class="hljs-literal">false</span><br>				<span class="hljs-keyword">break</span><br>			<span class="hljs-keyword">case</span> *sdl.KeyboardEvent: <span class="hljs-comment">// 键盘事件</span><br>				ke := event.(*sdl.KeyboardEvent)<br>				<span class="hljs-keyword">if</span> ke.Keysym.Sym == sdl.K_ESCAPE &#123;<br>					e.running = <span class="hljs-literal">false</span><br>					<span class="hljs-keyword">break</span><br>				&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> code, ok := e.Keyboard.GetKey(ke.Keysym.Sym); ok &#123;<br>					<span class="hljs-comment">// 按键按下</span><br>					<span class="hljs-keyword">if</span> ke.State == sdl.PRESSED &#123;<br>						e.Keyboard.PressKey(code)<br>					&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ke.State == sdl.RELEASED &#123;<br>						<span class="hljs-comment">// 按键释放</span><br>						e.Keyboard.ReleaseKey(code)<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">// 延迟 1000/60 毫秒</span><br>		sdl.Delay(<span class="hljs-number">1000</span> / <span class="hljs-number">60</span>)<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>显示屏刷新频率一般是 60Hz，也就是需要延迟 1000/60 毫秒。当然如果你嫌运行慢的话也可以自行修改延迟时间。</p>
<p>CPU单步执行以及是否重绘窗口通过 <code>clock()</code> 方法，每当CPU单步执行，然后根据情况判断是否需要重新绘制显示屏。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Emulator)</span> <span class="hljs-title">clock</span><span class="hljs-params">()</span></span> &#123;<br>	e.CPU.Step()<br><br>	<span class="hljs-comment">// 重绘</span><br>	<span class="hljs-keyword">if</span> e.CPU.drawAction &#123;<br>		e.Screen.update()<br>		e.CPU.drawAction = <span class="hljs-literal">false</span><br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="screengo"><a class="markdownIt-Anchor" href="#screengo"></a> screen.go</h4>
<p>该模块主要是创建模拟器的窗口和绘制精灵对象，由于显示屏数据保存在内存 0xF00-0xFFF，因此我们在更新时需要通过位运算来翻转某个像素。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Screen <span class="hljs-keyword">struct</span> &#123;<br>	pixels   []<span class="hljs-keyword">byte</span><br>	window   *sdl.Window<br>	renderer *sdl.Renderer<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewScreen</span><span class="hljs-params">(memory *Memory)</span> *<span class="hljs-title">Screen</span></span> &#123;<br>	s := &amp;Screen&#123;<br>		<span class="hljs-comment">// 显示屏数据存储在内存 [0xF00-0xFFF] 区域，即 256 字节</span><br>		pixels: memory.mem[<span class="hljs-number">0xF00</span>:],<br>	&#125;<br>	s.InitScreen() <span class="hljs-comment">// 使用SDL2库创建窗口</span><br>	<span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>该库主要使用SDL2来渲染窗口，关于重绘部分可以查看完整的代码，这部分比较简单</p>
<p>下面来看一下获取某个像素和翻转像素方法，这涉及到位运算</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Screen)</span> <span class="hljs-title">pixel</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>	addr := y*WIDTH + x<br>	<span class="hljs-comment">// 判断一个字节中对应的某位是是1还是0</span><br>	<span class="hljs-keyword">return</span> s.pixels[addr/<span class="hljs-number">8</span>]&amp;(<span class="hljs-number">1</span>&lt;&lt;(addr%<span class="hljs-number">8</span>)) != <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Screen)</span> <span class="hljs-title">flip</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	addr := y*WIDTH + x<br>	<span class="hljs-comment">// 将某个字节中某位反转</span><br>	s.pixels[addr/<span class="hljs-number">8</span>] ^= <span class="hljs-number">1</span> &lt;&lt; (addr % <span class="hljs-number">8</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>由于CHIP8模拟器的宽为8字节（64像素），高为4字节（32像素），在内存区域 0xF00-0xFFF 是线性存储的，因此对于每个字节，给定一个 <code>pixel=screen(x,y)</code> 像素，假设 x=2,y=1（需要注意的是这里所指的xy并非数学上xy坐标轴，而是按照行列来计算的且从零开始，即行y，列x），则取出的是第 1*64+2=66 个像素，那么该像素位于第 66/8=8 个字节，第 66%8=2 个位置</p>
<p>如果还是无法理解上面什么意思，那么可以从下面这张图来理解<br />
<img src="../uploads/images/chip8/gochip8_1.jpg" srcset="/img/loading.gif" lazyload alt="" /></p>
<h4 id="memgo"><a class="markdownIt-Anchor" href="#memgo"></a> mem.go</h4>
<p>该模块主要模拟CHIP8的内存，在Go语言中使用切片(Slice)来表示这片大小为4096字节的区域</p>
<p>这个模块比较简单，大家可以自行查看源码。不过有一点需要注意的是CHIP8采用大端存储，因此从内存读取两个字节的操作码时要稍加注意，第一个字节是高位，第二个字节是低位</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Memory <span class="hljs-keyword">struct</span> &#123;<br>	mem []<span class="hljs-keyword">byte</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Memory)</span> <span class="hljs-title">ReadOpCode</span><span class="hljs-params">(addr Address)</span> <span class="hljs-title">Opcode</span></span> &#123;<br>	m.checkAddress(addr)<br>	high := Opcode(m.mem[addr]) <span class="hljs-comment">// 高位字节</span><br>	low := Opcode(m.mem[addr+<span class="hljs-number">1</span>]) <span class="hljs-comment">// 低位字节</span><br>	<span class="hljs-keyword">return</span> (high &lt;&lt; <span class="hljs-number">8</span>) | low<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="romgo"><a class="markdownIt-Anchor" href="#romgo"></a> rom.go</h4>
<p>在初始化内存之后，除了将字体数据加载到内存，还需要将ROM游戏数据加载到内存 0x200 起始处，下面这段代码很easy</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Rom <span class="hljs-keyword">struct</span> &#123;<br>	data []<span class="hljs-keyword">byte</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Rom)</span> <span class="hljs-title">load</span><span class="hljs-params">(filename <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>	file, err := os.Open(filename)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> err<br>	&#125;<br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		_ = file.Close()<br>	&#125;()<br>	r.data, err = ioutil.ReadAll(file)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> err<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="keyboardgo"><a class="markdownIt-Anchor" href="#keyboardgo"></a> keyboard.go</h4>
<p>用于处理按键输入的 keyboard.go 模块主要是将CHIP8按键和用户自定义的按键布局映射起来。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Keyboard <span class="hljs-keyword">struct</span> &#123;<br>	kb []<span class="hljs-keyword">bool</span> <span class="hljs-comment">// 记录 16个键 0-F 按下和释放情况</span><br>	km KeyMap <span class="hljs-comment">// 按键映射</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>默认按键映射表如下</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> KeyMap <span class="hljs-keyword">map</span>[sdl.Keycode]<span class="hljs-keyword">byte</span><br><br><span class="hljs-keyword">var</span> DefaultKeyMap = KeyMap&#123;<br>	sdl.K_1: Key1,<br>	sdl.K_2: Key2,<br>	sdl.K_3: Key3,<br>	sdl.K_4: KeyC,<br>	sdl.K_q: Key4,<br>	sdl.K_w: Key5,<br>	sdl.K_e: Key6,<br>	sdl.K_r: KeyD,<br>	sdl.K_a: Key7,<br>	sdl.K_s: Key8,<br>	sdl.K_d: Key9,<br>	sdl.K_f: KeyE,<br>	sdl.K_z: KeyA,<br>	sdl.K_x: Key0,<br>	sdl.K_c: KeyB,<br>	sdl.K_v: KeyF,<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="cpugo"><a class="markdownIt-Anchor" href="#cpugo"></a> cpu.go</h4>
<p>该模块的主要功能就是模拟CPU单步执行，不过这些执行的指令都是规定好的，我们只需要按照规范去模拟每一个指令即可，对于CHIP8来说不必想得太难</p>
<p>我们首先来看下CPU结构体是如何描述的</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">uint16</span><br><span class="hljs-keyword">type</span> Opcode <span class="hljs-keyword">uint16</span><br><br><span class="hljs-keyword">type</span> external <span class="hljs-keyword">struct</span> &#123;<br>	screen   *Screen   <span class="hljs-comment">// 屏幕</span><br>	keyboard *Keyboard <span class="hljs-comment">// 键盘</span><br>	mem      *Memory   <span class="hljs-comment">// 内存</span><br>&#125;<br><br><span class="hljs-keyword">type</span> CPU <span class="hljs-keyword">struct</span> &#123;<br>	external<br>	PC Address <span class="hljs-comment">// 程序计数器</span><br>	I  Address <span class="hljs-comment">// 地址寄存器</span><br>	SP <span class="hljs-keyword">byte</span>    <span class="hljs-comment">// 栈指针寄存器</span><br>	STACK      []<span class="hljs-keyword">byte</span> <span class="hljs-comment">// 用于存储 subroutine 返回地址</span><br>	V          []<span class="hljs-keyword">byte</span> <span class="hljs-comment">// 通用寄存器，其中 V[0xF]是进位标志</span><br>	delayTimer <span class="hljs-keyword">int</span> <br>	soundTimer <span class="hljs-keyword">int</span><br>	halted     <span class="hljs-keyword">bool</span> <span class="hljs-comment">// 标志是否挂起CPU执行</span><br>	haltedReg  <span class="hljs-keyword">int</span>  <span class="hljs-comment">// 指定哪一个键需要等待按下</span><br>	drawAction <span class="hljs-keyword">bool</span> <span class="hljs-comment">// 指示 Screen 是否需要重绘</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>CPU单步执行方法是 <code>Step()</code>，该方法代码较长，完整的代码可以在GitHub查看，这里我说下需要注意的点。</p>
<p>首先是大致的执行逻辑</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *CPU)</span> <span class="hljs-title">Step</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// 是否挂起CPU直到某个键被按下</span><br><br>	<span class="hljs-comment">// 读取操作码</span><br>	<br>	<span class="hljs-comment">// 移动PC</span><br>	<br>	<span class="hljs-comment">// 分析操作码执行指令</span><br><br>	<span class="hljs-comment">// 递减计时器</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>绘制精灵主要实现如下</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Draws a sprite at coordinate (VX, VY) that has a width of 8 pixels and a height of N pixels.</span><br><span class="hljs-comment">Each row of 8 pixels is read as bit-coded starting from memory location I;</span><br><span class="hljs-comment">I value does not change after the execution of this instruction.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">As described above,</span><br><span class="hljs-comment">VF is set to 1 if any screen pixels are flipped from set to unset when the sprite is drawn,</span><br><span class="hljs-comment">and to 0 if that does not happen</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *CPU)</span> <span class="hljs-title">draw</span><span class="hljs-params">(vx, vy, n <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	<span class="hljs-comment">// 如果发生过翻转，则设置VF=1</span><br>	c.V[<span class="hljs-number">0xF</span>] = <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> y := <span class="hljs-number">0</span>; y &lt; n; y++ &#123;<br>		<span class="hljs-comment">// 依次从内存中取出一个字节（8像素）</span><br>		b := c.mem.Read(c.I + Address(y))<br>		<span class="hljs-comment">// 并计算哪一位需要翻转</span><br>		<span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">8</span>; x++ &#123;<br>			<span class="hljs-comment">// 该位是否需要翻转，翻转的目的是产生其他的sprite</span><br>			<span class="hljs-keyword">if</span> b&amp;(<span class="hljs-number">1</span>&lt;&lt;(<span class="hljs-number">7</span>-x)) &gt; <span class="hljs-number">0</span> &#123;<br>				nx := (vx + x) % WIDTH<br>				ny := (vy + y) % HEIGHT<br>				<span class="hljs-comment">// 判断该像素是否为1</span><br>				<span class="hljs-keyword">if</span> c.screen.pixel(nx, ny) &#123;<br>					c.V[<span class="hljs-number">0xF</span>] = <span class="hljs-number">1</span><br>				&#125;<br>				<span class="hljs-comment">// 翻转位</span><br>				c.screen.flip(nx, ny)<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>
<p>由于CPU在单步执行的过程中可能接收按键输入，此时我们需要等待某一个键被按下。在此过程中CPU必须被挂起，直到按键被按下才可以继续执行指令。</p>
</li>
<li>
<p>调用 subroutine 时，需要将PC压入栈，用于后续返回 subroutine</p>
</li>
<li>
<p>在进行数值运算时需要注意改变 VF 进位标志</p>
</li>
<li>
<p>对于操作码 FX29，由于每个字体占用5个字节且位于内存区域 0x00-0x4F 中，且 Vx 保存的是字体的索引(0-F)，因此 <code>Vx*0x5</code> 表示的是对应字体的起始内存地址</p>
</li>
<li>
<p>对于操作码 DXYN，在起始像素点(x,y)绘制一个宽8像素，高n像素的精灵</p>
</li>
</ul>
<figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams">精灵表示：[vx, vy, vx+<span class="hljs-number">8</span>, vy+n]<br>比如字体 <span class="hljs-string">&quot;0&quot;</span> 在内存中表示: <span class="hljs-number">0xF0</span> <span class="hljs-number">0x90</span> <span class="hljs-number">0x90</span> <span class="hljs-number">0x90</span> <span class="hljs-number">0xF0</span><br><span class="hljs-string">&quot;0&quot;</span>	  <span class="hljs-keyword">Binary</span>  Hex<br><span class="hljs-comment">**** 11110000 0xF0</span><br><span class="hljs-comment">*  * 10010000 0x90</span><br><span class="hljs-comment">*  * 10010000 0x90</span><br><span class="hljs-comment">*  * 10010000 0x90</span><br><span class="hljs-comment">**** 11110000 0xF0</span><br></code></pre></div></td></tr></table></figure>
<h4 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果"></a> 运行结果</h4>
<p><img src="uploads/images/../../../uploads/images/chip8/gochip8_2.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<p><img src="uploads/images/../../../uploads/images/chip8/gochip8_3.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<p><img src="uploads/images/../../../uploads/images/chip8/gochip8_4.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<p>完整的代码实现可以在 <a target="_blank" rel="noopener" href="https://github.com/josexy/gochip8">GitHub</a> 上找到，可以自行下载并运行（需要提前安装SDL2库）</p>
<p>好了，本文也就到此结束～</p>
<h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CHIP-8">https://en.wikipedia.org/wiki/CHIP-8</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cs.columbia.edu/~sedwards/classes/2016/4840-spring/reports/Chip8.pdf">http://www.cs.columbia.edu/~sedwards/classes/2016/4840-spring/reports/Chip8.pdf</a></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Golang/">Golang</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Golang/">Golang</a>
                    
                      <a class="hover-with-bg" href="/tags/Emulatorm/">Emulatorm</a>
                    
                      <a class="hover-with-bg" href="/tags/Chip8/">Chip8</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/v2ray-ws-tls/">
                        <span class="hidden-mobile">v2ray ws tls</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"AzPbImmMjm5nQc1Xm9ulWCoH-gzGzoHsz","appKey":"xJqILn8nSbhYmdkB2VVQm8vI","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"requiredFields":[]},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/katex.min.css" />
  








  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
