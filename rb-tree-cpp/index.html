<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=7.2.0">


  <link rel="mask-icon" href="/images/favicon.ico?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="红黑树（Red–Black Tree）是一种自平衡二叉查找树，用于实现关联数组。它在1972年由鲁道夫·贝尔（Rudolf Bayer）发明，被称为”对称二叉B树”。">
<meta name="keywords" content="C++,DataStructures,C,红黑树">
<meta property="og:type" content="article">
<meta property="og:title" content="我所理解的红黑树(RBT)">
<meta property="og:url" content="http://www.joxrays.com/rb-tree-cpp/index.html">
<meta property="og:site_name" content="JoXrays&#39;s Blog">
<meta property="og:description" content="红黑树（Red–Black Tree）是一种自平衡二叉查找树，用于实现关联数组。它在1972年由鲁道夫·贝尔（Rudolf Bayer）发明，被称为”对称二叉B树”。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/01.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/02.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/04.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/03.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/05.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/06.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/07.gif">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/08.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/09.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/10.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/11.gif">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/12.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/13.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/14.gif">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/15.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/16.gif">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/17.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/18.gif">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/19.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/20.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/48.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/21.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/22.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/23.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/24.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/25.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/26.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/27.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/28.gif">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/29.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/30.gif">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/31.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/32.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/33.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/34.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/35.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/36.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/37.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/38.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/39.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/40.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/41.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/42.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/43.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/44.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/45.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/46.png">
<meta property="og:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/47.gif">
<meta property="og:updated_time" content="2020-02-03T03:54:06.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我所理解的红黑树(RBT)">
<meta name="twitter:description" content="红黑树（Red–Black Tree）是一种自平衡二叉查找树，用于实现关联数组。它在1972年由鲁道夫·贝尔（Rudolf Bayer）发明，被称为”对称二叉B树”。">
<meta name="twitter:image" content="http://www.joxrays.com/uploads/images/data_structure/rbtree_cpp/01.png">



  <link rel="alternate" href="/atom.xml" title="JoXrays's Blog" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://www.joxrays.com/rb-tree-cpp/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  
  <title>我所理解的红黑树(RBT) | JoXrays's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-duotone-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JoXrays's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">All my interesting ...</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.joxrays.com/rb-tree-cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joseph XRays">
      <meta itemprop="description" content="Share the knowledge">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JoXrays's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">我所理解的红黑树(RBT)

              
            
          </h2>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-01 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-01T00:00:00+08:00">2020-02-01</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-03 11:54:06" itemprop="dateModified" datetime="2020-02-03T11:54:06+08:00">2020-02-03</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/rb-tree-cpp/" class="post-meta-item leancloud_visitors" data-flag-title="我所理解的红黑树(RBT)">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">16k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">15 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>红黑树（Red–Black Tree）是一种自平衡二叉查找树，用于实现<strong>关联数组</strong>。它在1972年由鲁道夫·贝尔（Rudolf Bayer）发明，被称为”对称二叉B树”。</p>
<a id="more"></a>

<h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>由于红黑树过于复杂，因此在讲述之前我们先来大致了解一下<code>2-3树</code>，2-3树类似红黑树，也是平衡树，时间复杂度均为$O(\log n)$。<br>2–3树早于红黑树出现，由约翰·霍普克洛夫特于1970年发明。2-3树也称为<code>3阶B-树</code>、<code>3叉搜索树</code>。<br>2-3树中的一个父节点可以有2个子节点也可以有3个子节点。<br>有2个子节点的父节点称为<code>2-</code>节点，该节点有1个key。这类似二叉树的节点<br>有3个子节点的父节点称为<code>3-</code>节点，该节点有2个key。假设父节点键为key1和key2且key1 &lt; key2，左子树L、中子树M、右子树R。则左子树L &lt; key1，key1 &lt; 中子树M &lt; key2 ，右子树 &gt; key2。</p>
<p>2-3树是一棵<code>完全3插搜索树</code>。每个节点要么是<code>叶子节点</code>，要么是<code>2-节点</code>或<code>3-节点</code>，，而且每个节点的子树一定是<code>等高</code>的。<br><img src="/uploads/images/data_structure/rbtree_cpp/01.png" alt></p>
<p>如上图，关键字为 <code>[f h]</code> 的<code>3-节点</code>有3个子节点<code>e</code>、<code>g</code>、<code>[i j]</code>，且 <code>e&lt;f</code>、<code>f&lt;g&lt;h</code>、<code>[i j]&gt;h</code></p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>2-3树的查找类似bst，比如查找上图的<code>g</code></p>
<ol>
<li>首先g和d比较，g&gt;d，查找右子树</li>
<li>f&lt;g&lt;h，进入中子树</li>
<li>g=g，返回节点，查找结束</li>
</ol>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>插入操作只需在<code>叶子节点</code>处插入一个新节点，不过由于2-3树的定义需要调整树的结构，使其平衡。<br>在叶子节点而不是空节点处插入节点的好处是以后维护平衡就简单了，而且树的高度也是尽可能的低。<br>插入新节点处的叶子节点可为<code>2-节点</code>或<code>3-节点</code><br><img src="/uploads/images/data_structure/rbtree_cpp/02.png" alt></p>
<p>如上图就是在2-节点位置<code>i</code>直接插入一个新节点<code>j</code>而变成一个3-节点，这种情况下无需调整树结构就已经平衡。 </p>
<p>在3-节点处插入新节点同样也是在叶子节点插入，不过这样会导致形成一个<code>4-节点</code>，在2-3树中这是不允许的，因此需要调整。调整方式为就是将<code>4-节点</code>分裂与合并。</p>
<p><code>节点分裂</code> 是将一个4-节点的中间值key节点提取处来作为父节点，左边key作为左节点，右边key作为右节点。<br>若该4-节点存在子节点，那么将左边key作为最左边两个子节点父节点，将右边key作为最右边两个子节点父节点。</p>
<p><img src="/uploads/images/data_structure/rbtree_cpp/04.png" alt></p>
<p>节点分裂一般伴随着<code>节点合并</code>，也就是将分裂后的父节点与之前未分裂4-节点的父节点合并成一个新的节点，如果新节点依旧是4-节点，那么继续向上分裂合并直到满足平衡。</p>
<p>举个例子：<br>向这棵2-3树插入<code>k</code>节点后成为4-节点，不符合定义，需要分裂该节点。<br><img src="/uploads/images/data_structure/rbtree_cpp/03.png" alt></p>
<p>将节点<code>[i j k]</code>中的<code>j</code>提取出来与与父节点<code>[f h]</code>合并成<code>[f h j]</code>，发现该节点依然是一个4-节点，因此需要继续分裂+合并。<br><img src="/uploads/images/data_structure/rbtree_cpp/05.png" alt></p>
<p>此时<code>[d h]</code>已经是一个3-节点了，而且整个2-3树也是等高的，调整结束。<br><img src="/uploads/images/data_structure/rbtree_cpp/06.png" alt></p>
<p>插入<code>a-k</code>的整个过程如下<br><img src="/uploads/images/data_structure/rbtree_cpp/07.gif" alt></p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>2-3树的删除虽然较为复杂，但大致可分为两类：删除叶子节点和删除非叶子节点。</p>
<h5 id="删除叶子节点"><a href="#删除叶子节点" class="headerlink" title="删除叶子节点"></a>删除叶子节点</h5><p>删除叶子节点又可以分为<code>删除2-节点</code>和<code>删除3-节点</code>。<br>删除3-节点的情况最简单，直接删除即可。如下删除key为k的情况<br><img src="/uploads/images/data_structure/rbtree_cpp/08.png" alt></p>
<p>删除2-节点不能简单的删除该节点，因为这样一删除后，该位置为空，2-3树是不允许存在这种情况的。此时可分为如下几类情况来处理：</p>
<ul>
<li>待删除节点的<code>临近兄弟节点</code>是<code>3-节点</code></li>
<li>待删除节点的<code>临近兄弟节点</code>是<code>2-节点</code>，但<code>父节点</code>是<code>3-节点</code></li>
<li>待删除节点的<code>临近兄弟节点</code>和<code>父节点</code>均是<code>2-节点</code></li>
</ul>
<p>对于第一种情况，删除该节点后只需向<code>临近兄弟节点</code>“借”<strong>一个key与待删除节点相近</strong>作为新的节点并<code>调整其与父节点</code>，此时树的高度不变。<br>如下图，删除<code>i</code>节点，而且兄弟是3-节点，将兄弟节点中key<code>k</code>与删除节点相近的key<code>j</code>而不是<code>l</code>作为已删除节点。由于<code>k&gt;j</code>，因此需要调整父子节点键值<br><img src="/uploads/images/data_structure/rbtree_cpp/09.png" alt></p>
<p>对于第二种情况，首先删除该节点后，发现<code>临近兄弟节点g</code>是一个2-节点且父节点<code>[f h]</code>为3-节点。因此将父节点分解为2-节点，由于<code>e&lt;f&lt;g</code>，于是将<code>f</code>与<code>临近兄弟节点g</code>合并成3-节点，并作为一个新的左孩子<br><img src="/uploads/images/data_structure/rbtree_cpp/10.png" alt></p>
<p>演示过程如下<br><img src="/uploads/images/data_structure/rbtree_cpp/11.gif" alt></p>
<p>第三种情况待删除节点的兄弟节点和父节点均是2-节点，删除节点后将<code>父节点b</code>和<code>兄弟节点c</code>合并成3-节点。<br>1.若此时<code>兄弟节点f和父节点d又是2-节点</code>，故继续合并d、f直到平衡，最终的结构如下。图中空位置只是直观上表示一棵等高的2-3树且该节点被“删除”了。<br><img src="/uploads/images/data_structure/rbtree_cpp/12.png" alt></p>
<p>2.若此时<code>临近兄弟节点是2-节点、父节点是3-节点</code>，则可看作是上述第二种删除情况。<br>如下，删除<code>2-节点a</code>，此时兄弟节点c和父节点b均为2-节点，因此合并成<code>3-节点[b c]</code>，此时仍然未平衡，且<code>临近兄弟节f点是2-节点、父节点[d h]是3-节点</code>，因此分解父节点<code>[d h]</code>，将<code>d</code>与临近兄弟节<code>f</code>合并为3-节点<code>[d-f]</code><br><img src="/uploads/images/data_structure/rbtree_cpp/13.png" alt></p>
<p>演示过程如下<br><img src="/uploads/images/data_structure/rbtree_cpp/14.gif" alt></p>
<p>3.若此时<code>临近兄弟节点是3-节点</code>，该过程也可看作是上述第一种删除情况，此处不再叙述。<br><img src="/uploads/images/data_structure/rbtree_cpp/15.png" alt></p>
<p>演示过程如下<br><img src="/uploads/images/data_structure/rbtree_cpp/16.gif" alt></p>
<h5 id="删除非叶子节点"><a href="#删除非叶子节点" class="headerlink" title="删除非叶子节点"></a>删除非叶子节点</h5><p>删除非叶子节点首先也需要找到一个<code>前驱/后继节点</code>，有点类似BST。<br>总之简单来说，前驱节点就是节点的左子树的最右节点，后继节点就是节点的右子树的最左节点。</p>
<p>如下删除<code>key=d</code>的节点，该key位于3-节点，不过没关系。找到其<code>前驱节点c</code>，将键值替换后删除<code>前驱节点c</code>，删除操作就转化为上述3种情况之一。<br><img src="/uploads/images/data_structure/rbtree_cpp/17.png" alt></p>
<p>演示过程如下<br><img src="/uploads/images/data_structure/rbtree_cpp/18.gif" alt></p>
<p>以上大致是关于2-3树的一些基本操作了。说了这么多，就是为了2-3树和为红黑树之间的转化。<br>先来看这张图，将2-3树的<code>3-节点</code>拆解成父子节点，且用红色箭头表明两者父子关系，将子节点染成红色，父节点染成黑色；再将其余<code>2-节点</code>全部染成黑色。经过适当调整树结构后发现这是一棵红黑树！实际上，这是红黑树的变体——<code>左偏红黑树</code>。<br><img src="/uploads/images/data_structure/rbtree_cpp/19.png" alt></p>
<p>实际上向一棵普通的红黑树插入key为<code>a-l</code>应该是这样的：<br><img src="/uploads/images/data_structure/rbtree_cpp/20.png" alt></p>
<p>2-3树一定能转化为红黑树(左偏红黑树)，而红黑树不一定能转化为2-3树！<br>由于<code>2-3-4树</code>是红黑树的一种等同，故2-3-4树一定能转化为红黑树，而红黑树也一定能转化为2-3-4树！</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote>
<p>红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它在1972年由鲁道夫·贝尔发明，被称为”对称二叉B树”，它现代的名字源于Leo J. Guibas和Robert Sedgewick于1978年写的一篇论文。红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在 $\log N$ 时间内完成查找，插入和删除，这里的 $N$ 是树中元素的数目。</p>
<p>红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。</p>
</blockquote>
<p>根据2-3树转化为红黑树可以这样定义红黑树，或者是<code>规则</code>：</p>
<ul>
<li>红黑树一定是二叉搜索树，因为2-3树也是二叉搜索树；</li>
<li>根节点和所有外部节点(Nil)都是<code>黑色</code>，根据2-3树转化为左偏红黑树可看出来；</li>
<li>在根至外部节点(Nil)路径上，没有连续两个节点是<code>红色</code>的；</li>
<li>在所有根至外部节点的路径上，<code>黑色</code>节点的数目相同，即<code>黑高</code>相等。</li>
</ul>
<p>如果再添加这一规则<code>红色节点位于左侧</code>，那么这个红黑树是一棵左偏红黑树。不过本文主要是介绍普通的红黑树。<br>上述规则3和规则4是极其重要的，但凡涉及插入和删除操作都是要使红黑树满足这两条规则。</p>
<p>本文红黑树C++类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedBlackTree</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RBNodeEntry *m_RB_Root;</span><br><span class="line">    RBNodeEntry *m_Nil;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RedBlackTree();</span><br><span class="line">    RedBlackTree(<span class="keyword">int</span> key,<span class="keyword">int</span> data);</span><br><span class="line">    ~RedBlackTree();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">int</span> key)</span></span>;</span><br><span class="line">    <span class="function">RBNodeEntry* <span class="title">Search</span><span class="params">(RBNodeEntry* pNode,<span class="keyword">int</span> key)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ClearAll</span><span class="params">(RBNodeEntry*&amp; root)</span></span>;</span><br><span class="line">    <span class="function">RBNodeEntry* <span class="title">successor</span><span class="params">(RBNodeEntry* pnode)</span></span>;</span><br><span class="line">    <span class="function">RBNodeEntry* <span class="title">predecessor</span><span class="params">(RBNodeEntry* pnode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">(RBNodeEntry* pnode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pnode==m_Nil)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hl= Height(pnode-&gt;leftChild);</span><br><span class="line">        <span class="keyword">int</span> hr= Height(pnode-&gt;rightChild);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(hl,hr)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RBNodeEntry* &amp;<span class="title">root</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_RB_Root;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(RBNodeEntry* pnode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(RBNodeEntry* pnode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(RBNodeEntry* pnode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(RBNodeEntry* pnode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(RBNodeEntry *pnode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">(RBNodeEntry *pnode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RedBlack_insertFixup</span><span class="params">(RBNodeEntry* pnode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RedBlack_removeFixup</span><span class="params">(RBNodeEntry* pnode)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="哨兵节点"><a href="#哨兵节点" class="headerlink" title="哨兵节点"></a>哨兵节点</h4><p>本文红黑树利用了<code>哨兵节点</code>技巧，省去了判断nullptr的麻烦，不过BST部分代码需要稍微修改。<br><img src="/uploads/images/data_structure/rbtree_cpp/48.png" alt></p>
<p>由于哨兵节点也是<code>RBNodeEntry</code>结构，但哨兵节点无父节点，因此设置为<code>nullptr</code>；同时还需要设置其<code>leftChild</code>和<code>rightChild</code>指向自身。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RedBlackTree::RedBlackTree()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_RB_Root=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 哨兵节点</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Nil=<span class="keyword">new</span> RBNodeEntry;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Nil-&gt;color=BLACK;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Nil-&gt;key=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Nil-&gt;data=<span class="number">0xffffff</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Nil-&gt;leftChild=<span class="keyword">this</span>-&gt;m_Nil;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Nil-&gt;rightChild=<span class="keyword">this</span>-&gt;m_Nil;</span><br><span class="line">&#125;</span><br><span class="line">RedBlackTree::RedBlackTree(<span class="keyword">int</span> key,<span class="keyword">int</span> data):RedBlackTree&#123;&#125;&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_RB_Root=<span class="keyword">new</span> RBNodeEntry(key,data);</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_RB_Root-&gt;parent=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_RB_Root-&gt;leftChild=<span class="keyword">this</span>-&gt;m_Nil;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_RB_Root-&gt;rightChild=<span class="keyword">this</span>-&gt;m_Nil;    </span><br><span class="line">    <span class="keyword">this</span>-&gt;m_RB_Root-&gt;color=BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><p>由于红黑树也是平衡树，其查找也为$O(\log N)$，查找过程与普通的二叉查找树没有太大区别。不过红黑树和AVL树相比，在最坏情况下却是AVL树占优势。这是因为AVL树是严格的自平衡树，在最坏情况下同样多的节点，其高度小于红黑树，这就导致其查找效率高于红黑树。</p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>红黑树的旋转操作只有左旋和右旋，而且也是核心。<br>以这张图为例，插入红色节点42后无需进行任何操作就满足红黑树性质。<br><img src="/uploads/images/data_structure/rbtree_cpp/21.png" alt></p>
<p>下面这个例子就是典型的<code>LLb</code>型，至于什么是LLb，此处简单介绍下。<br>图中u表示pu的左孩子、pu表示gu的左孩子、gr表示gu的右孩子，也就是pu的兄弟，u的叔叔。<br>而LLb的意思是：pu是gu的左孩子、u是pu的左孩子，且gu的另外一个孩子是黑色的（<code>Nil节点是黑色节点</code>）。</p>
<p>首先插入节点41后违背<code>规则3</code>，需要对节点45右旋，不过为了直观表示，我将图中的旋转箭头方向位置于42与45之间。旋转操作实质是对节点指针关系的修改。<br><img src="/uploads/images/data_structure/rbtree_cpp/22.png" alt></p>
<p>而这个例子就是<code>LRb</code>型，对节点42<code>左旋</code>后再对节点45<code>右旋</code>。这说明LRb可以转化为LLb类型，也就是说对于插入操作其实也就那几种不平衡类型。<br><img src="/uploads/images/data_structure/rbtree_cpp/23.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> COLOR&#123;</span><br><span class="line">    RED,</span><br><span class="line">    BLACK</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 红黑树节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RBNodeEntry</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> color;</span><br><span class="line">    RBNodeEntry *parent;</span><br><span class="line">    RBNodeEntry *leftChild;</span><br><span class="line">    RBNodeEntry *rightChild;</span><br><span class="line">    RBNodeEntry()&#123;&#125;</span><br><span class="line">    RBNodeEntry(<span class="keyword">int</span> k,<span class="keyword">int</span> d)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key=k;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data=d;</span><br><span class="line">        <span class="keyword">this</span>-&gt;color=RED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedBlackTree::leftRotate</span><span class="params">(RBNodeEntry *pnode)</span></span>&#123;</span><br><span class="line">    RBNodeEntry *right = pnode-&gt;rightChild;</span><br><span class="line">    pnode-&gt;rightChild = right-&gt;leftChild;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right-&gt;leftChild != m_Nil)</span><br><span class="line">        right-&gt;leftChild-&gt;parent = pnode;</span><br><span class="line">    right-&gt;parent = pnode-&gt;parent;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示根节点</span></span><br><span class="line">    <span class="keyword">if</span> (pnode-&gt;parent == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        root = right;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">          parent                    parent</span></span><br><span class="line"><span class="comment">           / \                      /    \</span></span><br><span class="line"><span class="comment">       pnode  brother           right  brother</span></span><br><span class="line"><span class="comment">        /  \            ---&gt;     / \</span></span><br><span class="line"><span class="comment">       l    right           pnode  y</span></span><br><span class="line"><span class="comment">           / \                / \</span></span><br><span class="line"><span class="comment">           x  y              l  x</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pnode-&gt;parent-&gt;leftChild == pnode)&#123;</span><br><span class="line">        pnode-&gt;parent-&gt;leftChild = right;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        parent                    parent</span></span><br><span class="line"><span class="comment">        / \                       /   \</span></span><br><span class="line"><span class="comment">   brother pnode            brother  right</span></span><br><span class="line"><span class="comment">           /  \        ---&gt;          /  \</span></span><br><span class="line"><span class="comment">           l   right             pnode   y</span></span><br><span class="line"><span class="comment">              / \                 / \</span></span><br><span class="line"><span class="comment">              x  y                l  x</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pnode-&gt;parent-&gt;rightChild = right;            </span><br><span class="line">    &#125;</span><br><span class="line">    right-&gt;leftChild = pnode;</span><br><span class="line">    pnode-&gt;parent = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedBlackTree::rightRotate</span><span class="params">(RBNodeEntry *pnode)</span></span>&#123;</span><br><span class="line">    RBNodeEntry *left = pnode-&gt;leftChild;</span><br><span class="line">    pnode-&gt;leftChild=left-&gt;rightChild;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left-&gt;rightChild!=m_Nil)&#123;</span><br><span class="line">        left-&gt;rightChild-&gt;parent=pnode;</span><br><span class="line">    &#125;</span><br><span class="line">    left-&gt;parent=pnode-&gt;parent;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">if</span>(pnode-&gt;parent==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_RB_Root=left;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">          parent                parent</span></span><br><span class="line"><span class="comment">           / \                   / \</span></span><br><span class="line"><span class="comment">       pnode  brother        left   brother</span></span><br><span class="line"><span class="comment">        /  \          ---&gt;   / \</span></span><br><span class="line"><span class="comment">     left   r               x   pnode</span></span><br><span class="line"><span class="comment">      / \                        / \</span></span><br><span class="line"><span class="comment">     x   y                      y   r</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pnode-&gt;parent-&gt;leftChild==pnode)&#123;</span><br><span class="line">        pnode-&gt;parent-&gt;leftChild=left;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         parent                  parent</span></span><br><span class="line"><span class="comment">          /  \                    /  \</span></span><br><span class="line"><span class="comment">    brother   pnode         brother  left   </span></span><br><span class="line"><span class="comment">              /  \   ---&gt;             / \</span></span><br><span class="line"><span class="comment">            left  r                  x   pnode</span></span><br><span class="line"><span class="comment">            / \                          / \</span></span><br><span class="line"><span class="comment">           x   y                        y   r</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pnode-&gt;parent-&gt;rightChild=left;</span><br><span class="line">    &#125;</span><br><span class="line">    left-&gt;rightChild=pnode;</span><br><span class="line">    pnode-&gt;parent=left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><p>红黑树的插入操作类似BST插入，除此之外还要对节点进行<code>染色</code>。那么问题来了，毕竟是红黑树嘛到底是染成黑色还是红色？<br>1.若染成<code>黑色</code>，那么就会一定会违背<code>规则4</code>，即黑色节点数目不相同，之后还需要重新调整红黑树，要知道红黑树调整是很复杂的，若是改写成代码那估计得累死人。<br>2.若染成<code>红色</code>，此时一定不会违背<code>规则4</code>，不过这有<code>可能</code>会违背<code>规则3</code>，即有连续两个节点是<code>红色</code>的。虽说还需要进行调整，不过这代码量相比之前就会少很多了……基于此，染成<code>红色</code>是正确的选择。</p>
<p>插入完成后往往需要<code>修正Fixup</code>树结构，而修正过程需要<code>旋转Rotate</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RedBlackTree::Insert</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_RB_Root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_RB_Root=<span class="keyword">new</span> RBNodeEntry(key,data);</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_RB_Root-&gt;leftChild=m_Nil;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_RB_Root-&gt;rightChild=m_Nil;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_RB_Root-&gt;parent=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_RB_Root-&gt;color=BLACK;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RBNodeEntry *x=<span class="keyword">this</span>-&gt;m_RB_Root;</span><br><span class="line">    RBNodeEntry *p=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x!=m_Nil)&#123;</span><br><span class="line">        <span class="comment">// 保存父节点p</span></span><br><span class="line">        p=x;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; x-&gt;key)</span><br><span class="line">            x=x-&gt;leftChild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; x-&gt;key)</span><br><span class="line">            x=x-&gt;rightChild;</span><br><span class="line">        <span class="comment">// 已经存在</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            x-&gt;data=data;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RBNodeEntry *pnode=<span class="keyword">new</span> RBNodeEntry(key,data);</span><br><span class="line">    pnode-&gt;leftChild=m_Nil;</span><br><span class="line">    pnode-&gt;rightChild=m_Nil;</span><br><span class="line">    pnode-&gt;color=RED;</span><br><span class="line">    pnode-&gt;parent=p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断插入节点位于父节点的哪边</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; p-&gt;key)</span><br><span class="line">        p-&gt;leftChild=pnode;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        p-&gt;rightChild=pnode;</span><br><span class="line">    <span class="comment">// 检查是否满足红黑树的平衡条件并重新平衡</span></span><br><span class="line">    RedBlack_insertFixup(pnode);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="InsertFixup"><a href="#InsertFixup" class="headerlink" title="InsertFixup"></a>InsertFixup</h4><p>插入操作所引起的不平衡主要是以下8种类型（主要针对插入在红色节点之后）：<br>LLr、LRr、RRr、RLr、LLb、LRb、RRb、RLb。<br><img src="/uploads/images/data_structure/rbtree_cpp/24.png" alt><br>图中u表示pu的左孩子、pu表示gu的左孩子、gr表示gu的右孩子，也就是pu的兄弟，u的叔叔。而LLb的意思是：pu是gu的左孩子、u是pu的左孩子，且gu的另外一个孩子(可以是Nil节点)是黑色的。</p>
<p>可以总结为下面这两种类型，插入新节点后的平衡主要是对<code>新插入节点u、其父节点pu、爷爷节点gu以及叔叔节点gl/gr</code>来操作的。<br><img src="/uploads/images/data_structure/rbtree_cpp/25.png" alt></p>
<p>如果叔叔节点不存在一定是<code>Nil黑色节点</code>！！！</p>
<p>根据<code>叔叔节点uncle</code>的颜色是红色或黑色，InsertFixup大致可以分为以下两种类型：</p>
<ul>
<li>uncle节点是<code>红色</code>，也就是<code>LLr、LRr、RRr、RLr</code>类型，直接<code>换色</code>即可完成红黑树平衡；</li>
<li>uncle节点是<code>黑色</code>，也就是<code>LLb、LRb、RRb、RLb</code>类型，需要旋转和换色。</li>
</ul>
<h5 id="LLr、LRr、RRr、RLr"><a href="#LLr、LRr、RRr、RLr" class="headerlink" title="LLr、LRr、RRr、RLr"></a>LLr、LRr、RRr、RLr</h5><p>处理这类不平衡问题，只需要换色即可，这是因为<code>父节点和叔叔节点</code>此时一定是<code>红色</code>的，那么<code>爷爷节点</code>也一定是<code>黑色</code>的。<br>这个过程是这样的：</p>
<ul>
<li>若<code>父节点pu/parent存在且为红色</code>，则执行该过程；否则将<code>根节点root</code>染成为<code>黑色</code>并结束；</li>
<li>将<code>父节点pu/parent和叔叔节点gl/gr/uncle</code>染成黑色；</li>
<li>将<code>爷爷节点gu</code>染成红色；</li>
<li>移动当前<code>新插入红色节点u</code>到<code>爷爷节点gu</code>，重复执行第一步骤。</li>
</ul>
<p>第4步的作用是确保整棵红黑树均符合其规则，因此将<code>爷爷节点gu</code>染成红色之后，可能<code>爷爷节点gu的父节点是红色</code>，那么还需要再次向上修正，直到某个节点的父节点不存在（根节点）或其父节点是黑色节点。</p>
<p>例子：<br>插入节点30，导致形成LLr不平衡，将<code>父节点和叔叔节点</code>与<code>爷爷节点</code>换色后移动u到gu，此时再判断其父节点为nullptr表示达到了根节点root，因此修正结束，并将根节点root染成黑色。<br><img src="/uploads/images/data_structure/rbtree_cpp/26.png" alt></p>
<p>其他3种情况处理类似。</p>
<h5 id="LLb、LRb、RRb、RLb"><a href="#LLb、LRb、RRb、RLb" class="headerlink" title="LLb、LRb、RRb、RLb"></a>LLb、LRb、RRb、RLb</h5><p>这4种情况只需解释其中一种就能够举一反三了。<br>处理过程如下：</p>
<ul>
<li>若<code>父节点pu/parent存在且为红色</code>，则执行该过程；否则将<code>根节点root</code>染成为<code>黑色</code>并结束；</li>
<li>根据<code>插入节点u</code>位于<code>父节点pu</code>的哪一侧对<code>父节点pu</code>旋转：若u在pu左边，对pu右旋；否则左旋；</li>
<li>旋转完成后对<code>父节点pu/parent和叔叔节点gl/gr/uncle（如果存在）</code>与<code>爷爷节点gu</code>交换颜色；（实际上，只需要对父节点和爷爷节点换色）</li>
<li>根据<code>爷爷节点gu</code>位于<code>爷爷节点gu父节点pgu</code>的哪一侧对<code>爷爷节点gu</code>旋转：若gu在pgu左边，对gu右旋；否则左旋。</li>
</ul>
<p>注意，这种类型无需向上修正：<code>移动当前新插入红色节点u到爷爷节点gu，再重复执行第一步骤</code>，这是因为经过第2步旋转换色后，此时<code>父节点pu</code>一定是<code>黑色</code>的，那么下一次再旋转后，此时<code>新的爷爷节点gu</code>也一定是黑色的。</p>
<p>例子：<br>向这棵红黑树插入节点35，可以看出这是LRb型，虽然爷爷节点40的右孩子是Nil节点。先是对父节点30左旋后再交换爷爷节点40(黑)和父节点35(红)的颜色（此处叔叔节点为Nil，因此没有换色），然后对爷爷节点40右旋后完成了修正。<br>实际上，LRb型经过<code>左旋</code>转化为LLb型，同样RLb型经过<code>右旋</code>转化为RRb型。</p>
<p><img src="/uploads/images/data_structure/rbtree_cpp/27.png" alt><br><img src="/uploads/images/data_structure/rbtree_cpp/28.gif" alt></p>
<p>再看一个例子，其大致过程：插入节点41后形成<code>LLr</code>型，那么交换<code>爷爷节点45</code>和<code>父节点44、叔叔节点46</code>的颜色；移动u到gu位置后发现此时u<code>存在父节点且为红色</code>，那么还得继续修正；而此时是<code>LRb</code>型，故先对<code>父节点40</code>左旋后还要交换<code>爷爷节点50</code>和<code>父节点45、叔叔节点60</code>的颜色；之后再对<code>爷爷节点45</code>右旋；最后还要将<code>根节点root</code>染成黑色，至此红黑树平衡，修正结束。<br><img src="/uploads/images/data_structure/rbtree_cpp/29.png" alt></p>
<p>演示过程<br><img src="/uploads/images/data_structure/rbtree_cpp/30.gif" alt></p>
<h5 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedBlackTree::RedBlack_insertFixup</span><span class="params">(RBNodeEntry *pNode)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 父节点</span></span><br><span class="line">    RBNodeEntry *parent=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 爷爷节点</span></span><br><span class="line">    RBNodeEntry *gparent=<span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果父节点存在且为红色</span></span><br><span class="line">    <span class="keyword">while</span>((parent=pNode-&gt;parent) &amp;&amp; parent-&gt;color==RED)&#123;</span><br><span class="line">        gparent=parent-&gt;parent;</span><br><span class="line">        <span class="comment">// L-型</span></span><br><span class="line">        <span class="keyword">if</span>(parent==gparent-&gt;leftChild)&#123;        </span><br><span class="line">            RBNodeEntry * uncle=gparent-&gt;rightChild;</span><br><span class="line">            <span class="comment">// LLr/LRr型 叔叔节点是红色，那么直接换色</span></span><br><span class="line">            <span class="keyword">if</span>(uncle!=m_Nil &amp;&amp; uncle-&gt;color==RED)&#123;</span><br><span class="line">                parent-&gt;color=BLACK;</span><br><span class="line">                uncle-&gt;color=BLACK;</span><br><span class="line">                gparent-&gt;color=RED;</span><br><span class="line">                <span class="comment">// 从当前爷爷节点开始继续向上调整</span></span><br><span class="line">                pNode=gparent;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// LRb，叔叔节点gr是黑色节点(可以Nil)，且当前节点是父节点的右孩子</span></span><br><span class="line">            <span class="comment">// 将LRb转化为LLb型</span></span><br><span class="line">            &#125;<span class="keyword">if</span>(pNode==parent-&gt;rightChild)&#123;</span><br><span class="line">                <span class="comment">// 对父节点左旋</span></span><br><span class="line">                leftRotate(parent);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理LLb的情况</span></span><br><span class="line">            <span class="comment">// 先换色，在旋转</span></span><br><span class="line">            parent-&gt;color=BLACK;</span><br><span class="line">            gparent-&gt;color=RED;</span><br><span class="line">            rightRotate(gparent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// R-型</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            RBNodeEntry *uncle=gparent-&gt;leftChild;</span><br><span class="line">            <span class="comment">// RLr/RRr型 叔叔节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> (uncle!=m_Nil &amp;&amp; uncle-&gt;color==RED)&#123;</span><br><span class="line">                uncle-&gt;color=BLACK;</span><br><span class="line">                parent-&gt;color=BLACK;</span><br><span class="line">                gparent-&gt;color=RED;</span><br><span class="line">                <span class="comment">// 继续向上调整</span></span><br><span class="line">                pNode=gparent;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">             <span class="comment">// RLb型 叔叔是黑色，且当前节点是左孩子</span></span><br><span class="line">             <span class="comment">// 转化为 RRb</span></span><br><span class="line">            &#125; <span class="keyword">if</span>(pNode==parent-&gt;leftChild)&#123;</span><br><span class="line">                rightRotate(parent);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// RRb型</span></span><br><span class="line">            parent-&gt;color=BLACK;</span><br><span class="line">            gparent-&gt;color=RED;</span><br><span class="line">            leftRotate(gparent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点必须为黑色！</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_RB_Root-&gt;color=BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>红黑树删除类似BST，删除操作的前半部分代码一样，差别在于删除后红黑树的修正。事实上删除操作的修正要十分复杂，要考虑的情况较多。</p>
<ul>
<li>在红黑树中查找该节点是否存在；</li>
<li>若存在左子树和右子树，寻找<code>前驱/后继节点</code>将其转化为<code>只有一个子树/叶子</code>情况；</li>
<li>根据<code>child节点</code>、<code>child的兄弟节点</code>、<code>child的父节点</code>修正删除后的红黑树；</li>
<li>删除该节点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RedBlackTree::Remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    RBNodeEntry *node=Search(<span class="keyword">this</span>-&gt;m_RB_Root,key);</span><br><span class="line">    <span class="keyword">if</span>(!node)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    RBNodeEntry *child=m_Nil;</span><br><span class="line">    RBNodeEntry *parent=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在左子树和右子树，将其转化为只有一个子树/叶子情况</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;leftChild!=m_Nil &amp;&amp; node-&gt;rightChild!=m_Nil) &#123;</span><br><span class="line">        <span class="comment">// 后继节点，即将是要被删除的节点</span></span><br><span class="line">        RBNodeEntry *successor = <span class="keyword">this</span>-&gt;successor(node);</span><br><span class="line">        <span class="comment">// 数据替换</span></span><br><span class="line">        node-&gt;key=successor-&gt;key;</span><br><span class="line">        node-&gt;data=successor-&gt;data;</span><br><span class="line">        <span class="comment">// 删除后继节点</span></span><br><span class="line">        node=successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若node是叶子节点那么leftChild=rightChild=m_Nil</span></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;leftChild!=m_Nil)&#123;</span><br><span class="line">        child=node-&gt;leftChild;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        child=node-&gt;rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 即使child是Nil也要设置child的parent。因为removeFixup需要parent来修正</span></span><br><span class="line">    child-&gt;parent=node-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是根节点</span></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;parent==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_RB_Root=child;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;parent-&gt;leftChild==node)&#123;</span><br><span class="line">        node-&gt;parent-&gt;leftChild=child;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;parent-&gt;rightChild=child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;color==BLACK)&#123;</span><br><span class="line">        RedBlack_removeFixup(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接删除节点即可</span></span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    node=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RemoveFixup"><a href="#RemoveFixup" class="headerlink" title="RemoveFixup"></a>RemoveFixup</h4><p>给出下图的删除操作所引起的不平衡情况模板<br><img src="/uploads/images/data_structure/rbtree_cpp/31.png" alt><br>其中<code>白色节点</code>处于<code>未定型状态</code>，表示可以为黑/红/节点甚至Nil节点，但根节点一定是黑色节点。<code>节点u</code>表示删除节点的<code>child节点</code>。</p>
<p>我们首先讨论删除<code>黑色节点</code>的复杂情况。而且是上图的第一个模板，另一个也是类似的（旋转方向相反）。</p>
<h5 id="删除黑色节点"><a href="#删除黑色节点" class="headerlink" title="删除黑色节点"></a>删除黑色节点</h5><p>删除黑色节点引起的不平衡大致有4种情况：</p>
<ul>
<li>Case1：<code>兄弟节点brother</code>为<code>红色</code>；</li>
<li>Case2：<code>兄弟节点brother</code>为<code>黑色</code>，而且<code>brother</code>的<code>两个child</code>也都是黑色；</li>
<li>Case3：<code>兄弟节点brother</code>为<code>黑色</code>，而且<code>brother</code>的<code>leftchild</code>是红色，<code>rightchild</code>是黑色；</li>
<li>Case4：<code>兄弟节点brother</code>为<code>黑色</code>，而且<code>brother</code>的<code>rightchild</code>是红色。</li>
</ul>
<p><img src="/uploads/images/data_structure/rbtree_cpp/32.png" alt></p>
<h6 id="Case1"><a href="#Case1" class="headerlink" title="Case1"></a>Case1</h6><p>这种情况下是<code>兄弟节点brother</code>为<code>红色</code>，那么<code>parent节点</code>一定黑色。修正过程为：</p>
<ul>
<li>将<code>兄弟节点brother</code>染成<code>黑色</code>；</li>
<li>将<code>u的父节点parent</code>染成<code>红色</code>；</li>
<li>对<code>parent</code>进行<code>左旋</code>；</li>
<li>移动<code>brother</code>到<code>u的父节点parent</code>的<code>右孩子rightchild</code>。</li>
</ul>
<p>注意，这种情况下修正还没有结束！<br><img src="/uploads/images/data_structure/rbtree_cpp/33.png" alt></p>
<p>假设存在如下红黑树，删除节点a后为<code>case 1</code>情况，然而经过第一次修正发现并没有完全平衡，不过经过<code>case 1</code>却意外的进入了<code>case 2/3/4</code>，那么就继续修正。<br><img src="/uploads/images/data_structure/rbtree_cpp/34.png" alt></p>
<h6 id="Case2"><a href="#Case2" class="headerlink" title="Case2"></a>Case2</h6><p>这种情况是：<code>brother</code>为<code>黑色</code>，而且<code>brother</code>的<code>两个child</code>也都是黑色。修正的方法如下：</p>
<ul>
<li>将<code>brother</code>染成<code>红色</code>；</li>
<li>移动<code>u</code>到其<code>父节点parent</code>；</li>
</ul>
<p>至此，再根据<code>u</code>(图中的<code>B</code>)的颜色可以分两种情况：</p>
<ul>
<li><code>u</code>是<code>红色</code>，结束修正同时把<code>u</code>染成<code>黑色</code>；</li>
<li><code>u</code>是<code>黑色且不是根节点root</code>，则继续下一轮修正过程，再根据不同情况进行修正。</li>
</ul>
<p><img src="/uploads/images/data_structure/rbtree_cpp/35.png" alt></p>
<h6 id="Case3"><a href="#Case3" class="headerlink" title="Case3"></a>Case3</h6><p>这种情况是：<code>brother</code>为<code>黑色</code>，而且<code>brother</code>的<code>leftchild</code>是红色，<code>rightchild</code>是黑色。修正的方法如下：</p>
<ul>
<li>将<code>brother</code>的<code>左孩子leftchild</code>染成<code>黑色</code>；</li>
<li>将<code>brother</code>染成<code>红色</code>；</li>
<li>对<code>brother</code>右旋；</li>
<li>移动<code>brother</code>到<code>u的父节点parent</code>的<code>右孩子rightchild</code>。</li>
</ul>
<p><img src="/uploads/images/data_structure/rbtree_cpp/36.png" alt></p>
<h6 id="Case4"><a href="#Case4" class="headerlink" title="Case4"></a>Case4</h6><p>这是最后一种情况了：<code>brother</code>为<code>黑色</code>，而且<code>brother</code>的<code>rightchild</code>是红色。修正方法：</p>
<ul>
<li>将<code>brother</code>染成<code>u的父节点parent</code>的颜色(黑或红)；</li>
<li>将<code>parent</code>染成黑色；</li>
<li>将<code>brother</code>的<code>右孩子rightchild</code>染成黑色；</li>
<li>对<code>parent</code>左旋；</li>
<li>移动<code>u</code>移至<code>根节点root</code>，用于结束修正循环（图中节点b只是起演示作用，不一定为root）；</li>
<li>最后修改根节点root颜色为黑色。</li>
</ul>
<p><img src="/uploads/images/data_structure/rbtree_cpp/37.png" alt></p>
<p>总结以上4种情况，它们之间的转化关系大概如下：</p>
<ul>
<li>Case1-&gt;Case2/3/4</li>
<li>Case3-&gt;Case4</li>
<li>Case1-&gt;Case3-&gt;Case4</li>
</ul>
<p>修正完Case4就说明红黑树平衡了</p>
<h6 id="Case5"><a href="#Case5" class="headerlink" title="Case5"></a>Case5</h6><p>其实这类情况最简单了，也就是删除一个<code>黑色节点p</code>，但其<code>子节点child</code>是一个<code>红色节点</code>，无论黑色节点p的父节点是黑色还是红色。这样的话根本没必要再去考虑上述4种情况了。</p>
<ul>
<li>删除黑色节点，如果存在<code>红色child节点</code>，那么将其染成<code>黑色</code>。</li>
</ul>
<p><img src="/uploads/images/data_structure/rbtree_cpp/38.png" alt></p>
<h5 id="删除红色节点"><a href="#删除红色节点" class="headerlink" title="删除红色节点"></a>删除红色节点</h5><p>删除红色节点可能是删除叶子节点或者含有子树的节点。前者很容易实现，对于后者需要找到一个<code>前驱/后继节点</code>，而这个前驱/后继节点可能是黑色或红色的。如果是红色，那就删除该红色前驱/后继节点并向上修正直到平衡；如果是黑色，那么就判断不同的情况<code>case1/2/3/4/5</code>并进行修正；</p>
<p>删除红色节点55，前驱节点53也是红色节点<br><img src="/uploads/images/data_structure/rbtree_cpp/39.png" alt></p>
<p>删除红色节点65，前驱节点60是黑色节点，需要进入<code>case3</code>和<code>case4</code>修正过程；<br>删除红色节点65，后继节点67是红色节点。<br><img src="/uploads/images/data_structure/rbtree_cpp/40.png" alt></p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>为了说明情况，现在以下面这棵红黑树为例子来说明删除操作。<br><img src="/uploads/images/data_structure/rbtree_cpp/41.png" alt></p>
<p>删除<code>黑色节点55</code>，由于其子节点为<code>Nil</code>，故形成如下的<code>case4</code>：</p>
<ul>
<li>将<code>兄弟节点57</code>染成<code>u节点Nil</code>的<code>父节点56</code>的<code>红色</code>；</li>
<li>将<code>父节点56</code>染成<code>黑色</code>和<code>兄弟节点57</code>的<code>右节点58</code>染成<code>黑色</code>；</li>
<li>对<code>父节点56</code>左旋；</li>
<li>移动<code>u</code>移至根节点root，结束修正循环；</li>
<li>修改<code>根节点root</code>颜色为黑色。</li>
</ul>
<p><img src="/uploads/images/data_structure/rbtree_cpp/42.png" alt><br>最终效果<br><img src="/uploads/images/data_structure/rbtree_cpp/43.png" alt><br>删除<code>黑色节点58</code>，由于其子节点也为<code>Nil</code>，故形成如下的<code>case2</code>：</p>
<ul>
<li>将<code>兄弟节点56</code>染成<code>红色</code>；</li>
<li>移动<code>u</code>到其<code>父节点57</code>；</li>
<li>由于<code>u</code>是<code>红色</code>的，因此把<code>父节点57</code>染成<code>黑色</code>；</li>
<li>结束修正。</li>
</ul>
<p><img src="/uploads/images/data_structure/rbtree_cpp/44.png" alt><br>最终效果<br><img src="/uploads/images/data_structure/rbtree_cpp/45.png" alt><br>现在删除<code>黑色节点60</code>，由于其存在左右子树，因此需要寻找前驱/后继节点，此处寻找得<code>前驱黑色节点57</code>，替换<code>前驱黑色节点57</code>键值到<code>黑色节点60</code>。此时转化为删除<code>前驱黑色节点57</code>后形成<code>case5</code>，由于其<code>子节点56</code>为红色，故删除了<code>前驱黑色节点57</code>后，将<code>子节点56</code>染成<code>黑色</code>并结束修正。<br><img src="/uploads/images/data_structure/rbtree_cpp/46.png" alt></p>
<p>上述演示过程<br><img src="/uploads/images/data_structure/rbtree_cpp/47.gif" alt></p>
<h5 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++代码"></a>C++代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedBlackTree::RedBlack_removeFixup</span><span class="params">(RBNodeEntry*node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// case5:</span></span><br><span class="line">    <span class="comment">// 若node是红色，那么把子节点node直接染黑</span></span><br><span class="line">    <span class="comment">// 若node是root，那么也把它直接染黑</span></span><br><span class="line">    <span class="keyword">while</span> (node!=m_RB_Root &amp;&amp; node-&gt;color==BLACK) &#123;</span><br><span class="line">        <span class="comment">// node是左节点</span></span><br><span class="line">        <span class="keyword">if</span> (node==node-&gt;parent-&gt;leftChild) &#123;</span><br><span class="line">            RBNodeEntry *brother=node-&gt;parent-&gt;rightChild;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            case1:</span></span><br><span class="line"><span class="comment">            case1最终转化为case2/3/4</span></span><br><span class="line"><span class="comment">                1.将兄弟节点brother染成黑色；</span></span><br><span class="line"><span class="comment">                2.将node的父节点parent染成红色；</span></span><br><span class="line"><span class="comment">                3.对parent进行左旋；</span></span><br><span class="line"><span class="comment">                4.移动brother到node的父节点parent的右孩子rightchild。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(brother-&gt;color==RED)&#123;</span><br><span class="line">                brother-&gt;color=BLACK;</span><br><span class="line">                node-&gt;parent-&gt;color=RED;</span><br><span class="line">                leftRotate(node-&gt;parent);</span><br><span class="line">                brother=node-&gt;parent-&gt;rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            case2:(单独处理)</span></span><br><span class="line"><span class="comment">                1.将brother染成红色；</span></span><br><span class="line"><span class="comment">                2.移动node到其父节点parent；</span></span><br><span class="line"><span class="comment">            */</span>    </span><br><span class="line">            <span class="keyword">if</span>(brother-&gt;leftChild-&gt;color==BLACK&amp;&amp;brother-&gt;rightChild-&gt;color==BLACK)&#123;</span><br><span class="line">                brother-&gt;color=RED;</span><br><span class="line">                node=node-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// case3-&gt;case4</span></span><br><span class="line">            <span class="keyword">else</span> &#123;   </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                case3:</span></span><br><span class="line"><span class="comment">                    1.将brother的左孩子leftchild染成黑色；</span></span><br><span class="line"><span class="comment">                    2.将brother染成红色；</span></span><br><span class="line"><span class="comment">                    3.对brother右旋；</span></span><br><span class="line"><span class="comment">                    4.移动brother到node的父节点parent的右孩子rightchild。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span>(brother-&gt;rightChild-&gt;color==BLACK)&#123;</span><br><span class="line">                    brother-&gt;leftChild-&gt;color=BLACK;</span><br><span class="line">                    brother-&gt;color=RED;</span><br><span class="line">                    rightRotate(brother);</span><br><span class="line">                    brother=node-&gt;parent-&gt;rightChild;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                case4:</span></span><br><span class="line"><span class="comment">                    1.将brother染成node的父节点parent的颜色(黑或红)；</span></span><br><span class="line"><span class="comment">                    2.将parent染成黑色；</span></span><br><span class="line"><span class="comment">                    3.将brother的右孩子rightchild染成黑色；</span></span><br><span class="line"><span class="comment">                    4.对parent左旋；</span></span><br><span class="line"><span class="comment">                    5.移动node移至根节点root，用于结束修正循环。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                brother-&gt;color=node-&gt;parent-&gt;color;</span><br><span class="line">                node-&gt;parent-&gt;color=BLACK;</span><br><span class="line">                brother-&gt;rightChild-&gt;color=BLACK;</span><br><span class="line">                leftRotate(node-&gt;parent);</span><br><span class="line">                node=<span class="keyword">this</span>-&gt;m_RB_Root;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// node是右节点</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            RBNodeEntry *brother=node-&gt;parent-&gt;leftChild;</span><br><span class="line">            <span class="comment">// case1-&gt;case2/3/4:</span></span><br><span class="line">            <span class="keyword">if</span> (brother-&gt;color == RED) &#123;</span><br><span class="line">                brother-&gt;color = BLACK;</span><br><span class="line">                node-&gt;parent-&gt;color = RED;</span><br><span class="line">                rightRotate(node-&gt;parent);</span><br><span class="line">                brother = node-&gt;parent-&gt;leftChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// case2:</span></span><br><span class="line">            <span class="keyword">if</span> (brother-&gt;leftChild-&gt;color == BLACK&amp;&amp;brother-&gt;rightChild-&gt;color == BLACK) &#123;</span><br><span class="line">                brother-&gt;color = RED;</span><br><span class="line">                node = node-&gt;parent;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// case3:</span></span><br><span class="line">                <span class="keyword">if</span> (brother-&gt;leftChild-&gt;color == BLACK)&#123;</span><br><span class="line">                    brother-&gt;rightChild-&gt;color = BLACK;</span><br><span class="line">                    brother-&gt;color = RED;</span><br><span class="line">                    leftRotate(brother);</span><br><span class="line">                    brother = node-&gt;parent-&gt;leftChild;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// case4: </span></span><br><span class="line">                brother-&gt;color = node-&gt;parent-&gt;color;</span><br><span class="line">                node-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                brother-&gt;leftChild-&gt;color = BLACK;</span><br><span class="line">                rightRotate(node-&gt;parent);</span><br><span class="line">                node = <span class="keyword">this</span>-&gt;m_RB_Root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 即使node是Nil也染黑</span></span><br><span class="line">    node-&gt;color=BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>红黑树实在是太复杂了，还得慢慢来～关于红黑树和AVL树差别，可以看看 <a href="https://stackoverflow.com/questions/13852870/red-black-tree-over-avl-tree" target="_blank" rel="noopener">https://stackoverflow.com/questions/13852870/red-black-tree-over-avl-tree</a><br>篇幅有限，红黑树全部源码就不全放出来了，毕竟也参考了别人写的，仅供学习罢了～<br>有兴趣的可以去看看本文红黑树大概实现源码：<a href="https://josephxrays.coding.net/p/rbt_cpp_learn/d/rbt_cpp_learn/git" target="_blank" rel="noopener">源码链接</a></p>
<p>总之，红黑树上红黑果，红黑树下你和我～</p>
<p>bye~</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://zh.wikipedia.org/zh-hans/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">红黑树-维基百科</a><br><a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html" target="_blank" rel="noopener">Red Black Tree: Intro(簡介)</a><br><a href="https://riteme.site/blog/2016-3-12/2-3-tree-and-red-black-tree.html" target="_blank" rel="noopener">2-3树与红黑树</a><br>《数据结构、算法与应用 C++语言描述》</p>

      
    </div>

    

    
      
    

    
    
    

    

    
      
    
    
      <div>
        <div id="reward-container">
  <div>Give a rose, leave a handful of fragrance; life is not easy, I use the arch</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.png" alt="Joseph XRays 微信支付">
        <p>微信支付</p>
      </div>
    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"> <i class="fa fa-tag"></i> C++</a>
          
            <a href="/tags/DataStructures/" rel="tag"> <i class="fa fa-tag"></i> DataStructures</a>
          
            <a href="/tags/C/" rel="tag"> <i class="fa fa-tag"></i> C</a>
          
            <a href="/tags/红黑树/" rel="tag"> <i class="fa fa-tag"></i> 红黑树</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/avl-tree-cpp/" rel="next" title="数据结构-AVL树">
                <i class="fa fa-chevron-left"></i> 数据结构-AVL树
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/binaryheap-cpp/" rel="prev" title="二叉堆-堆排序">
                二叉堆-堆排序 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMTkwNC84NDY4"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  
    <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Joseph XRays">
  
  <p class="site-author-name" itemprop="name">Joseph XRays</p>
  <div class="site-description motion-element" itemprop="description">Share the knowledge</div>
</div>


  <nav class="site-state motion-element">
    
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>





  <div class="links-of-author motion-element">
    
      <span class="links-of-author-item">
      
      
      
        
      
        <a href="https://github.com/josexy" title="GitHub &rarr; https://github.com/josexy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
    
  </div>






  <div class="links-of-blogroll motion-element links-of-blogroll-block">
    <div class="links-of-blogroll-title">
      <i class="fa  fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
      
        <li class="links-of-blogroll-item">
          <a href="https://github.com/josexy" title="https://github.com/josexy" rel="noopener" target="_blank">Github</a>
        </li>
      
    </ul>
  </div>


          
          
        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3树"><span class="nav-number">1.</span> <span class="nav-text">2-3树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#查找"><span class="nav-number">1.1.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入"><span class="nav-number">1.2.</span> <span class="nav-text">插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除"><span class="nav-number">1.3.</span> <span class="nav-text">删除</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#删除叶子节点"><span class="nav-number">1.3.1.</span> <span class="nav-text">删除叶子节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删除非叶子节点"><span class="nav-number">1.3.2.</span> <span class="nav-text">删除非叶子节点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#红黑树"><span class="nav-number">2.</span> <span class="nav-text">红黑树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本概念"><span class="nav-number">2.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哨兵节点"><span class="nav-number">2.2.</span> <span class="nav-text">哨兵节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查找-1"><span class="nav-number">2.3.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#旋转"><span class="nav-number">2.4.</span> <span class="nav-text">旋转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入-1"><span class="nav-number">2.5.</span> <span class="nav-text">插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InsertFixup"><span class="nav-number">2.6.</span> <span class="nav-text">InsertFixup</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LLr、LRr、RRr、RLr"><span class="nav-number">2.6.1.</span> <span class="nav-text">LLr、LRr、RRr、RLr</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LLb、LRb、RRb、RLb"><span class="nav-number">2.6.2.</span> <span class="nav-text">LLb、LRb、RRb、RLb</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-代码"><span class="nav-number">2.6.3.</span> <span class="nav-text">C++代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除-1"><span class="nav-number">2.7.</span> <span class="nav-text">删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RemoveFixup"><span class="nav-number">2.8.</span> <span class="nav-text">RemoveFixup</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#删除黑色节点"><span class="nav-number">2.8.1.</span> <span class="nav-text">删除黑色节点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Case1"><span class="nav-number">2.8.1.1.</span> <span class="nav-text">Case1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Case2"><span class="nav-number">2.8.1.2.</span> <span class="nav-text">Case2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Case3"><span class="nav-number">2.8.1.3.</span> <span class="nav-text">Case3</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Case4"><span class="nav-number">2.8.1.4.</span> <span class="nav-text">Case4</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Case5"><span class="nav-number">2.8.1.5.</span> <span class="nav-text">Case5</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删除红色节点"><span class="nav-number">2.8.2.</span> <span class="nav-text">删除红色节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#例子"><span class="nav-number">2.8.3.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-代码-1"><span class="nav-number">2.8.4.</span> <span class="nav-text">C++代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结尾"><span class="nav-number">2.9.</span> <span class="nav-text">结尾</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考"><span class="nav-number">2.10.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Joseph XRays</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">286k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">4:20</span>
  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  













  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  


  
    


<script>
  window.livereOptions = {
    refer: 'rb-tree-cpp/'
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>

  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  
  
  <script>
    
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .done(function() {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.time + 1);
              })
            
              .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
              })
          } else {
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text('Counter not initialized! More info at console err msg.');
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'ehzm3BScCXAfURCsC2NYbFVy-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': 'ehzm3BScCXAfURCsC2NYbFVy-gzGzoHsz',
                'X-LC-Key': 'fxtNKXa7qvFfjvm1ORNSAejo',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            const localhost = /http:\/\/(localhost|127.0.0.1|0.0.0.0)/;
            if (localhost.test(document.URL)) return;
            addCount(Counter);
          
        });
    });
  </script>



  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      document.getElementById(all[i].inputID + '-Frame').parentNode.className += ' has-jax';
    }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  


  



<script type="text/javascript" src="/js/float_wenzi.js"></script>
</body>
</html>



